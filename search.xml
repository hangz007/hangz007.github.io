<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activiti5入门--Activiti5项目构建和核心API介绍</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-Activiti5%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%92%8C%E6%A0%B8%E5%BF%83API%E4%BB%8B%E7%BB%8D.html</url>
    <content><![CDATA[<p>上篇介绍了如何安装Activiti的IDE插件，本篇将介绍Activiti项目的构建和核心API。</p>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>选择菜单<em>File</em>-&gt;<em>New</em>-&gt;<em>Other…</em>，创建<em>Activiti Project</em></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/Activiti%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA.png" alt="创建工作流项目"></p>
<p>此时，生成一个类似<em>Maven</em>项目结构的<em>Activiti</em>项目，其<code>src/main/resources</code>目录下存在一个名为<em>diagrams</em>的包</p>
<h4 id="导入Activiti项目相关jar包"><a href="#导入Activiti项目相关jar包" class="headerlink" title="导入Activiti项目相关jar包"></a>导入Activiti项目相关jar包</h4><ol>
<li>选中项目，右键<em>New</em>-&gt;<em>Folder</em>，新建lib目录</li>
<li><p>将下列jar包复制到lib目录下</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/Activiti%E9%A1%B9%E7%9B%AE%E6%89%80%E9%9C%80jar%E5%8C%85.png" alt="项目所需jar包"><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%89%80%E9%9C%80jar%E5%8C%852.png" alt="项目所需jar包"><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/mysql%E7%9A%84jar%E5%8C%85.png" alt="mysql相关的jar包"></p>
</li>
<li><p>展开lib目录，选中所有jar包，右键<em>Build Path</em>-&gt;<em>Add To Build Path</em>。此时，项目所需的jar就被导入了</p>
</li>
</ol>
<h4 id="生成Activiti相关数据表及其核心对象"><a href="#生成Activiti相关数据表及其核心对象" class="headerlink" title="生成Activiti相关数据表及其核心对象"></a>生成Activiti相关数据表及其核心对象</h4><p>在<code>src/test/java</code>下创建类<em>TestActiviti</em>，新增测试方法<em>createTable</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngineConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActiviti</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*使用代码创建工作流需要的23张表*/</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();</span><br><span class="line">		processEngineConfiguration.setJdbcDriver(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		processEngineConfiguration.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/activiti?useUnicode=true&amp;characterEncoding=utf8"</span>);</span><br><span class="line">		processEngineConfiguration.setJdbcUsername(<span class="string">"root"</span>);</span><br><span class="line">		processEngineConfiguration.setJdbcPassword(<span class="string">"123456"</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * public static final String DB_SCHEMA_UPDATE_FALSE = "false"; public 不能自动创建表，需要表存在</span></span><br><span class="line"><span class="comment">		 * static final String DB_SCHEMA_UPDATE_CREATE_DROP = "create-drop"; 先删除表，再创建表</span></span><br><span class="line"><span class="comment">		 * public static final String DB_SCHEMA_UPDATE_TRUE = "true"; 如果表不存在，则自动创建表</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		processEngineConfiguration.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);</span><br><span class="line">		<span class="comment">// 工作流的流程引擎</span></span><br><span class="line">		ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();</span><br><span class="line">		System.out.println(<span class="string">"processEngine="</span>+processEngine);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码生成了支撑Activiti的23张数据表及其核心对象——流程引擎对象processEngine，其步骤如下</p>
<ol>
<li>首先，调用<em>ProcessEngineConfiguration类</em>的<em>createStandaloneProcessEngineConfiguration</em>方法生成流程引擎配置对象实例<em>processEngineConfiguration</em></li>
<li>接着，通过processEngineConfiguration对象的<em>setJdbcDriver</em>、<em>setJdbcUrl</em>、<em>setJdbcUsername</em>、<em>setJdbcPassword</em>分别设置数据库驱动、地址、用户名、密码</li>
<li>然后，通过<em>processEngineConfiguration</em>对象的<em>setDatabaseSchemaUpdate</em>方法设置数据表的生成策略。其总共有三种策略，选择其中的一种即可<ul>
<li><em>DB_SCHEMA_UPDATE_FALSE</em>，不自动创建表，工作流相关表必须先创建，否则抛异常</li>
<li><em>DB_SCHEMA_UPDATE_CREATE_DROP</em>，每次先删除旧表，再创建新表</li>
<li><em>DB_SCHEMA_UPDATE_TRUE</em>，如果表不存在，则自动创建表，否则，直接使用</li>
</ul>
</li>
<li>最后，通过<em>processEngineConfiguration</em>对象的<em>buildProcessEngine</em>方法生成核心的流程引擎对象<em>processEngine</em></li>
</ol>
<p>在<em>Activiti</em>中，在创建核心的流程引擎对象时会自动建表。如果程序正常执行，mysql会自动建库，然后创建23张表。 </p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>Activiti工作流框架的核心是流程引擎<em>ProcessEngine</em>，其完整功能的实现还需要创建23张底层的数据库表作为支撑</li>
<li>在实际情况中，需要先创建<em>ProcessEngineConfiguration</em>对象，设置数据库相关属性及数据库表生成策略，再生成核心的<em>ProcessEngine</em>对象</li>
</ol>
<h4 id="项目所用到的jar包"><a href="#项目所用到的jar包" class="headerlink" title="项目所用到的jar包"></a>项目所用到的jar包</h4><p>下载地址：<a href="https://pan.baidu.com/s/1cSlxvevKn717wyVj9izbaQ" target="_blank" rel="noopener">项目所需jar包</a></p>
<p>密码：fre5</p>
<h3 id="定义配置文件"><a href="#定义配置文件" class="headerlink" title="定义配置文件"></a>定义配置文件</h3><p>在上一节中，学习了使用代码生成数据库表以及获取流程引擎，本节将引入一个配置文件<em>activiti.cfg.xml</em>。</p>
<p>继续上一节的项目，在<code>src/main/resources</code>下添加文件<em>activiti.cfg.xml</em>，定义数据库的连接配置和建表策略</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 流程引擎配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"processEngineConfiguration"</span> <span class="attr">class</span>=<span class="string">"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--数据库配置--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcDriver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/activiti?useUnicode=true&amp;amp;characterEncoding=utf8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUsername"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcPassword"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 没有表,创建表 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"databaseSchemaUpdate"</span> <span class="attr">value</span>=<span class="string">"true"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对比上一节中的代码，可以发现，两者的配置是一致的。</p>
<p>在<em>TestActiviti</em>中增加测试方法<em>createTable2</em>，获取流程引擎配置对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTable2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ProcessEngine processEngine = ProcessEngineConfiguration</span><br><span class="line">			.createProcessEngineConfigurationFromResource(<span class="string">"activiti.cfg.xml"</span>).buildProcessEngine();</span><br><span class="line">	System.out.println(<span class="string">"processEngine="</span>+processEngine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，完整的<em>TestActiviti</em>就如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngineConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActiviti</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用代码创建工作流需要的23张表 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration</span><br><span class="line">				.createStandaloneProcessEngineConfiguration();</span><br><span class="line">		processEngineConfiguration.setJdbcDriver(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		processEngineConfiguration</span><br><span class="line">				.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/activiti?useUnicode=true&amp;characterEncoding=utf8"</span>);</span><br><span class="line">		processEngineConfiguration.setJdbcUsername(<span class="string">"root"</span>);</span><br><span class="line">		processEngineConfiguration.setJdbcPassword(<span class="string">"123456"</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * public static final String DB_SCHEMA_UPDATE_FALSE = "false"; public</span></span><br><span class="line"><span class="comment">		 * 不能自动创建表，需要表存在 static final String DB_SCHEMA_UPDATE_CREATE_DROP =</span></span><br><span class="line"><span class="comment">		 * "create-drop"; 先删除表，再创建表 public static final String</span></span><br><span class="line"><span class="comment">		 * DB_SCHEMA_UPDATE_TRUE = "true"; 如果表不存在，则自动创建表</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		processEngineConfiguration.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);</span><br><span class="line">		<span class="comment">// 工作流的流程引擎</span></span><br><span class="line">		ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();</span><br><span class="line">		System.out.println(<span class="string">"processEngine="</span> + processEngine);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTable2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载classpath路径下的配置文件，创建核心流程引擎对象，数据库表若不存在自动创建</span></span><br><span class="line">		ProcessEngine processEngine = ProcessEngineConfiguration</span><br><span class="line">		.createProcessEngineConfigurationFromResource(<span class="string">"activiti.cfg.xml"</span>).buildProcessEngine();</span><br><span class="line">        <span class="comment">// 还可以调用ProcessEngines的getDefaultProceeEngine方法，该方法会自动加载classpath下名为activiti.cfg.xml文件创建流程引擎</span></span><br><span class="line">        <span class="comment">// ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span></span><br><span class="line">		System.out.println(<span class="string">"processEngine="</span>+processEngine);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<em>createTable2</em>方法可以看出，通过引入配置文件可以使java代码更加简洁</p>
<h3 id="流程引擎的作用"><a href="#流程引擎的作用" class="headerlink" title="流程引擎的作用"></a>流程引擎的作用</h3><p><strong>ProccessEngine是Activiti中最核心的类，其他的类都是由它而来，通过流程引擎，可以创建各个Service，这些Service是调用工作流23张表的服务 </strong>，其分类和作用如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">服务</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>RepositoryService</strong></td>
<td style="text-align:center">管理流程定义</td>
</tr>
<tr>
<td style="text-align:center"><strong>RuntimeService</strong></td>
<td style="text-align:center">执行管理，包括启动、推进、删除流程实例等操作</td>
</tr>
<tr>
<td style="text-align:center"><strong>TaskService</strong></td>
<td style="text-align:center">任务管理</td>
</tr>
<tr>
<td style="text-align:center"><strong>HistoryService</strong></td>
<td style="text-align:center">历史管理(执行完的数据的管理)</td>
</tr>
<tr>
<td style="text-align:center"><strong>IdentityService</strong></td>
<td style="text-align:center">组织机构管理</td>
</tr>
<tr>
<td style="text-align:center">FormService nguage</td>
<td style="text-align:center">一个可选服务，任务表单管理</td>
</tr>
<tr>
<td style="text-align:center">ManagerService</td>
<td style="text-align:center">——</td>
</tr>
</tbody>
</table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建流程引擎主要有两种方式</p>
<ul>
<li>纯代码方式，通过代码创建流程引擎以及生成数据库表</li>
<li>引入配置文件<em>activiti.cfg.xml</em>，通过加载配置文件来创建流程引擎和数据库表</li>
</ul>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--HelloWorld程序演示流程执行</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-HelloWorld%E7%A8%8B%E5%BA%8F%E6%BC%94%E7%A4%BA%E6%B5%81%E7%A8%8B%E6%89%A7%E8%A1%8C.html</url>
    <content><![CDATA[<p>通过学习上一篇的内容，我们已经完成了项目的初始化。Activiti流程引擎所需要的23张数据表已经在数据库中创建成功，在这一篇中，我们将通过<em>HelloWorld</em>示例模拟流程的运行过程，初步体会流程的执行过程和框架核心API的使用。</p>
<p>本篇将分为两个部分，第一部分是绘制流程图，第二部分通过代码模拟一个完整流程的运行过程。</p>
<h3 id="绘制流程图"><a href="#绘制流程图" class="headerlink" title="绘制流程图"></a>绘制流程图</h3><h4 id="创建bpmn文件"><a href="#创建bpmn文件" class="headerlink" title="创建bpmn文件"></a>创建bpmn文件</h4><p>继续上一篇创建的工程，选中项目<code>src/main/resources</code>目录下的包<em>diagrams</em>，右键<em>New</em>-&gt;<em>Other…</em>-&gt;<em>Activiti</em>,选择创建<em>Activiti Diagram</em>，将文件命名为<em>helloworld</em>，然后，按照一般步骤点击直到结束。</p>
<p>这样我们就创建好了一个<em>helloworld.bpmn</em>文件。</p>
<h4 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h4><p>打开<em>helloworld.bpmn</em>文件，可以在IDE右侧看到如下面板，遵循如下步骤创建流程图</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti%E9%9D%A2%E6%9D%BF.png" alt="Activiti面板"></p>
<ol>
<li><p>拖拽<em>Start event</em>下的<em>StartEvent</em>，创建开始节点</p>
</li>
<li><p>拖拽<em>End event</em>下的<em>EndEvent</em>，创建结束节点</p>
</li>
<li><p>拖拽<em>Task</em>下的<em>UserTask</em>，创建任务节点</p>
</li>
<li><p>选择IDE顶部菜单<em>Window</em>-&gt;<em>Show View</em>-&gt;<em>Properties</em>，此时会打开一个界面，这个界面有助于我们编辑这些节点的属性,对于不同节点，<em>Properties</em>面板里的内容会有一定的差异，这是未选中节点时流程图的<em>全局Propertis配置项</em>界面</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/properties%E9%9D%A2%E6%9D%BF.png" alt="properties面板"></p>
</li>
<li><p>选择任务节点时的界面</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%94%A8%E6%88%B7%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE.png" alt="任务节点配置"></p>
</li>
<li><p>编辑任务节点，设置任务节点名称</p>
<ul>
<li>选择刚才创建的任务节点，将Name改为<em>提交申请</em>；</li>
<li>再创建一个任务节点，将Name改为<em>审批【部门经理】</em></li>
<li>最后创建一个任务节点，将Name改为<em>审批【总经理】</em></li>
</ul>
</li>
<li><p>找到右侧Activiti面板里<em>Connection</em>-&gt;<em>SequenceFlow</em>，将各个节点从开始节点到结束节点依次连接起来，如下图所示</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/helloworld.png" alt="流程图"></p>
</li>
<li><p>编辑任务节点，设置每个任务节点的办理人，在Properties界面里的<em>Main config</em>-&gt;<em>Assignee</em>里设置</p>
<ul>
<li>提交申请任务节点的<em>Assignee</em>为张三</li>
<li>审批【部门经理】任务节点的<em>Assignee</em>为李四</li>
<li>审批【总经理】任务节点的<em>Assignee</em>为王五</li>
</ul>
</li>
<li><p>点击空白处，此时出现<em>全局Propertis配置项</em>界面</p>
<ul>
<li>设置<em>Process</em>-&gt;<em>Id</em>为<em>helloworld</em></li>
<li>设置<em>Process</em>-&gt;<em>Name</em>为<em>helloworldProcess</em></li>
</ul>
</li>
<li><p>点击保存，即会生成对应流程图的图片文件</p>
</li>
</ol>
<p>使用XML方式打开bpmn文件，可以看到如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/MODEL"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:activiti</span>=<span class="string">"http://activiti.org/bpmn"</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/DI"</span> <span class="attr">xmlns:omgdc</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DC"</span> <span class="attr">xmlns:omgdi</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DI"</span> <span class="attr">typeLanguage</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">expressionLanguage</span>=<span class="string">"http://www.w3.org/1999/XPath"</span> <span class="attr">targetNamespace</span>=<span class="string">"http://www.activiti.org/test"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">"helloworld"</span> <span class="attr">name</span>=<span class="string">"helloworldProcess"</span> <span class="attr">isExecutable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">"startevent1"</span> <span class="attr">name</span>=<span class="string">"Start"</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">"endevent1"</span> <span class="attr">name</span>=<span class="string">"End"</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask1"</span> <span class="attr">name</span>=<span class="string">"提交申请"</span> <span class="attr">activiti:assignee</span>=<span class="string">"张三"</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask2"</span> <span class="attr">name</span>=<span class="string">"审批【部门经理】"</span> <span class="attr">activiti:assignee</span>=<span class="string">"李四"</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask3"</span> <span class="attr">name</span>=<span class="string">"审批【总经理】"</span> <span class="attr">activiti:assignee</span>=<span class="string">"王五"</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow1"</span> <span class="attr">sourceRef</span>=<span class="string">"startevent1"</span> <span class="attr">targetRef</span>=<span class="string">"usertask1"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow2"</span> <span class="attr">sourceRef</span>=<span class="string">"usertask1"</span> <span class="attr">targetRef</span>=<span class="string">"usertask2"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow3"</span> <span class="attr">sourceRef</span>=<span class="string">"usertask2"</span> <span class="attr">targetRef</span>=<span class="string">"usertask3"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow4"</span> <span class="attr">sourceRef</span>=<span class="string">"usertask3"</span> <span class="attr">targetRef</span>=<span class="string">"endevent1"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">"BPMNDiagram_helloworld"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">"helloworld"</span> <span class="attr">id</span>=<span class="string">"BPMNPlane_helloworld"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"startevent1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_startevent1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"35.0"</span> <span class="attr">width</span>=<span class="string">"35.0"</span> <span class="attr">x</span>=<span class="string">"390.0"</span> <span class="attr">y</span>=<span class="string">"50.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"endevent1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_endevent1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"35.0"</span> <span class="attr">width</span>=<span class="string">"35.0"</span> <span class="attr">x</span>=<span class="string">"390.0"</span> <span class="attr">y</span>=<span class="string">"380.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"usertask1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_usertask1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"105.0"</span> <span class="attr">x</span>=<span class="string">"355.0"</span> <span class="attr">y</span>=<span class="string">"120.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"usertask2"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_usertask2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"105.0"</span> <span class="attr">x</span>=<span class="string">"355.0"</span> <span class="attr">y</span>=<span class="string">"200.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"usertask3"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_usertask3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"105.0"</span> <span class="attr">x</span>=<span class="string">"355.0"</span> <span class="attr">y</span>=<span class="string">"290.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow1"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"85.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"120.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow2"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"175.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"200.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow3"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"255.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"290.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow4"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow4"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"345.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"380.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，该<em>XML</em>代码描述的过程和<em>bpmn</em>文件所图示的内容是一致的</p>
<h3 id="模拟流程执行"><a href="#模拟流程执行" class="headerlink" title="模拟流程执行"></a>模拟流程执行</h3><p>在绘画完流程图后，此时，可以写代码模拟流程运行了。在<code>src/main/java</code>下新建包<code>cn.demo.helloworld</code>，并创建类<em>HelloWorld</em></p>
<p>该流程执行的主要步骤有</p>
<ol>
<li>部署流程定义</li>
<li>启动流程实例</li>
<li>查询当前人的个人任务</li>
<li>完成个人的任务</li>
</ol>
<p>下面来看一下这些步骤的相关代码</p>
<h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 存在于act_re_deployment表</span></span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">			.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">			.name(<span class="string">"helloworld入门程序"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">			.addClasspathResource(<span class="string">"diagrams/helloworld.bpmn"</span>) <span class="comment">// 从classpath的资源中加载，一次只能加载一个文件</span></span><br><span class="line">			.addClasspathResource(<span class="string">"diagrams/helloworld.png"</span>).deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个流程来说，首先需要做的就是部署流程定义，而流程部署和定义需要使用<em>repositoryService</em>，通过该服务，我们可以获得一个部署对象，获取流程定义相关信息</p>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"helloworld"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() <span class="comment">// 与正在执行的流程实例和执行对象相关的Service</span></span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); <span class="comment">// 使用流程定义的key启动实例，key对应helloworld.bpmn文件中Id的属性值,默认是按照最新版本的流程定义启动</span></span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); <span class="comment">// 流程实例Id</span></span><br><span class="line"><span class="comment">// 对应act_ru_execution表中的ID</span></span><br><span class="line"><span class="comment">// 101</span></span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); <span class="comment">// 流程定义Id</span></span><br><span class="line"><span class="comment">// 对应act_re_procdef表中的ID 														/ 	  // helloworld:1:4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署完流程之后，就可以使用<em>runtimeService</em>启动一个具体流程实例</p>
<h4 id="查询当前人的个人任务"><a href="#查询当前人的个人任务" class="headerlink" title="查询当前人的个人任务"></a>查询当前人的个人任务</h4><p>流程在不断的执行，当流程执行到当前人的时候，就可以查询到当前人的个人任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"张三"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">				.list();</span><br><span class="line">		<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完成个人的任务"><a href="#完成个人的任务" class="headerlink" title="完成个人的任务"></a>完成个人的任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"104"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们查询到当前我们有任务时，可以对该任务进行处理。当处理完毕之后，流程就执行到下一步了。当流程全部步骤执行完成后，会存储到历史表中</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngines;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.repository.Deployment;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.runtime.ProcessInstance;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.task.Task;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取流程引擎</span></span><br><span class="line">	ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 部署流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 存在于act_re_deployment表</span></span><br><span class="line">		Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">				.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">				.name(<span class="string">"helloworld入门程序"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">				.addClasspathResource(<span class="string">"diagrams/helloworld.bpmn"</span>) <span class="comment">// 从classpath的资源中加载，一次只能加载一个文件</span></span><br><span class="line">				.addClasspathResource(<span class="string">"diagrams/helloworld.png"</span>).deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">		System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">		System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 启动流程实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 流程定义的key</span></span><br><span class="line">		String processDefinitionKey = <span class="string">"helloworld"</span>;</span><br><span class="line">		ProcessInstance processInstance = processEngine.getRuntimeService() <span class="comment">// 与正在执行的流程实例和执行对象相关的Service</span></span><br><span class="line">				.startProcessInstanceByKey(processDefinitionKey); <span class="comment">// 使用流程定义的key启动实例，key对应helloworld.bpmn文件中Id的属性值,默认是按照最新版本的流程定义启动</span></span><br><span class="line">		System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); <span class="comment">// 流程实例Id</span></span><br><span class="line">			<span class="comment">// 对应act_ru_execution表中的ID</span></span><br><span class="line">			<span class="comment">// 101</span></span><br><span class="line">		System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); <span class="comment">// 流程定义Id</span></span><br><span class="line">		<span class="comment">// 对应act_re_procdef表中的ID															//helloworld:1:4</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"张三"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">				.list();</span><br><span class="line">		<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 完成我的任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"104"</span>;</span><br><span class="line">		processEngine.getTaskService().complete(taskId);</span><br><span class="line">		System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="演示流程任务执行"><a href="#演示流程任务执行" class="headerlink" title="演示流程任务执行"></a>演示流程任务执行</h4><p>根据上面所绘制的流程图步骤，如下操作</p>
<ol>
<li>首先，设置当前人的任务的assignee为张三并执行查询当前人的任务方法，得到张三的任务ID</li>
<li>将当前人的任务ID带入并执行完成个人任务方法</li>
<li>然后将步骤1中的assignee设置为李四，得到李四的任务ID，将李四的任务ID带入并执行步骤2</li>
<li>最后将assignee设置为王五，得到王五的任务ID，将王五的任务ID带入并执行步骤2</li>
<li>当以上步骤都完成时，就完成了模拟流程任务执行的过程</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">当前人</th>
<th style="text-align:center">任务ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">104</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">202</td>
</tr>
<tr>
<td style="text-align:center">王五</td>
<td style="text-align:center">302</td>
</tr>
</tbody>
</table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的例子，可以总结出一般流程执行的主要步骤</p>
<ol>
<li>部署流程定义</li>
<li>启动流程实例</li>
<li>查询当前人的个人任务</li>
<li>完成个人的任务</li>
<li>重复执行3、4步，直到满足条件结束</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--个人任务分配</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E4%B8%AA%E4%BA%BA%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D.html</url>
    <content><![CDATA[<p>在前面的章节中，我们指定用户任务的办理人(<strong>assignee</strong>)时，通常都是直接在bpmn文件中直接指定特定的人。本章，我们将学习动态指定用户任务办理人。</p>
<p>为了更好地学习动态指定用户任务办理人的相关知识，我们新建包<strong>cn.demo.personaltask</strong>，类<strong>TaskTest</strong>，流程图文件<strong>task.bpmn</strong>，并定义一个审批流程，该流程只含有一个用户任务-<strong>审批</strong>任务，我们将使用不同的方法演示如何动态改变用户任务的办理人。</p>
<h2 id="定义审批流程"><a href="#定义审批流程" class="headerlink" title="定义审批流程"></a>定义审批流程</h2><p>这个审批流程相当简单，只有一个用户任务节点以及开始和结束节点</p>
<ol>
<li>创建一个开始和结束节点</li>
<li>创建一个用户任务节点，设置其Name值为<strong>审批</strong>，并且暂时指定其Assignee为<strong>张三丰</strong></li>
<li>使用连线连接三个节点</li>
<li>点击空白处，设置Id的值为<strong>task</strong> ,Name的值为<strong>taskProcess</strong></li>
</ol>
<p>这样，经过上述两个步骤，一个审批流程就定义好了。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E4%B8%AA%E4%BA%BA%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E4%B8%AA%E4%BA%BA%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D.png" alt="个人任务分配"></p>
<h2 id="三种方式指定用户任务"><a href="#三种方式指定用户任务" class="headerlink" title="三种方式指定用户任务"></a>三种方式指定用户任务</h2><p>在activi中，有三种指定用户任务办理人的方式</p>
<ol>
<li>直接指定办理人，即直接设置用户任务Assignee字段的值</li>
<li>使用流程变量，通过流程变量动态指定办理人的值</li>
<li>使用实现<strong>org.activiti.engine.delegate.TaskListener</strong>接口的类方法来动态指定办理人的值</li>
</ol>
<h3 id="直接指定办理人"><a href="#直接指定办理人" class="headerlink" title="直接指定办理人"></a>直接指定办理人</h3><h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><p>和前面一样，我们先要部署一个新的流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	InputStream inputStreamBpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"task.bpmn"</span>);</span><br><span class="line">	InputStream inputStreamPng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"task.png"</span>);</span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">			.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">			.name(<span class="string">"任务"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">			.addInputStream(<span class="string">"task.bpmn"</span>, inputStreamBpmn)</span><br><span class="line">			.addInputStream(<span class="string">"task.png"</span>,inputStreamPng)</span><br><span class="line">			.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出如下结果</p>
<blockquote>
<p>部署ID: 5101<br>部署名称: 任务</p>
</blockquote>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><p>紧接着部署流程定义之后的，就是启动流程实例了，我们来启动一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"task"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() </span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 																			<span class="comment">// 对应act_re_procdef表中的ID																				// helloworld:1:4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>流程实例ID: 5201<br>流程定义ID: task:1:5104</p>
</blockquote>
<p>这样，我们就启动好了流程实例了。</p>
<h4 id="查询个人任务"><a href="#查询个人任务" class="headerlink" title="查询个人任务"></a>查询个人任务</h4><p>很明显，我们指定的办理人是<strong>张三丰</strong>，于是，我们查询张三丰的个人任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"张三丰"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				<span class="comment">/*返回结果集*/</span></span><br><span class="line">				<span class="comment">// .singleResult() // 返回唯一结果集</span></span><br><span class="line">				<span class="comment">// .count() // 返回结果集数量</span></span><br><span class="line">				<span class="comment">// .listPage(arg0, arg1) // 分页查询结果集</span></span><br><span class="line">				.list();</span><br><span class="line">		<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，我们可以得到张三丰个人任务的详细信息</p>
<blockquote>
<p>任务ID: 5204<br>任务名称: 审批<br>任务的创建时间: Sat Oct 27 23:08:47 CST 2018<br>任务的办理人: 张三丰<br>流程实例ID: 5201<br>执行对象ID: 5201<br>流程定义ID: task:1:5104</p>
</blockquote>
<h4 id="完成个人任务"><a href="#完成个人任务" class="headerlink" title="完成个人任务"></a>完成个人任务</h4><p>通过上面获取的张三丰个人任务的任务Id，我们可以很容易地使用taskId完成任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"5204"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这种直接指定办理人的方式不够灵活。所以，下面介绍两种动态指定办理人的方式。</p>
<h3 id="使用流程变量指定办理人"><a href="#使用流程变量指定办理人" class="headerlink" title="使用流程变量指定办理人"></a>使用流程变量指定办理人</h3><p>动态指定办理人的方式其中之一就是使用流程变量。在这个流程中，我们选中<strong>审批</strong>用户任务，将Assignee的值修改为一个变量的取值。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E4%B8%AA%E4%BA%BA%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F%E6%8C%87%E5%AE%9A%E5%8A%9E%E7%90%86%E4%BA%BA.png" alt="使用流程变量指定办理人"></p>
<h4 id="部署流程定义和启动流程实例"><a href="#部署流程定义和启动流程实例" class="headerlink" title="部署流程定义和启动流程实例"></a>部署流程定义和启动流程实例</h4><p>我们重新部署流程定义以及启动流程实例。首先，重新部署流程定义</p>
<blockquote>
<p>部署ID: 5401<br>部署名称: 任务</p>
</blockquote>
<p>然后启动流程实例，并在启动时设置流程变量userID的值，指定办理人为周芷若</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"task"</span>;</span><br><span class="line">	<span class="comment">// 启动流程实例的同时，设置流程变量，使用流程变量来指定办理人</span></span><br><span class="line">	Map&lt;String,Object&gt; variables = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">	variables.put(<span class="string">"userID"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() 	</span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey,variables); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出如下结果</p>
<blockquote>
<p>流程实例ID: 5501<br>流程定义ID: task:2:5404</p>
</blockquote>
<h4 id="查询个人任务-1"><a href="#查询个人任务-1" class="headerlink" title="查询个人任务"></a>查询个人任务</h4><p>为了验证这种方式是否有效，我们查询一下办理人周芷若的个人任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"周芷若"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">				<span class="comment">// .taskCandidateUser(arg0) 组任务的办理人</span></span><br><span class="line">				<span class="comment">// .processDefinitionId(arg0)  流程定义id</span></span><br><span class="line">				<span class="comment">// .processInstanceId(arg0) // 流程实例id</span></span><br><span class="line">				<span class="comment">// .executionId(arg0) // 执行对象id</span></span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				<span class="comment">/*返回结果集*/</span></span><br><span class="line">				<span class="comment">// .singleResult() // 返回唯一结果集</span></span><br><span class="line">				<span class="comment">// .count() // 返回结果集数量</span></span><br><span class="line">				<span class="comment">// .listPage(arg0, arg1) // 分页查询结果集</span></span><br><span class="line">				.list();</span><br><span class="line">		<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，我们得到了周芷若的个人任务详细信息，说明使用流程变量指定办理人这样方式是有效的。</p>
<blockquote>
<p>任务ID: 5505<br>任务名称: 审批<br>任务的创建时间: Sun Oct 28 15:20:59 CST 2018<br>任务的办理人: 周芷若<br>流程实例ID: 5501<br>执行对象ID: 5501<br>流程定义ID: task:2:5404</p>
</blockquote>
<h4 id="完成个人任务-1"><a href="#完成个人任务-1" class="headerlink" title="完成个人任务"></a>完成个人任务</h4><p>这样，我们再使用任务ID完成周芷若的个人任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"5505"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，该流程就结束了，下面，我们介绍另外一种指定任务办理人的方式。</p>
<h3 id="使用类指定办理人"><a href="#使用类指定办理人" class="headerlink" title="使用类指定办理人"></a>使用类指定办理人</h3><p>在本节中，我们将使用类来动态指定任务办理人。为了更好地演示，我们新建一个包<strong>cn.demo.personaltaskbyclass</strong>，并复制一份代码，将<strong>TaskTest.java</strong>、<strong>task.bpmn</strong>的复制到新包中来，并将</p>
<p>bpmn文件中<strong>审批</strong>用户任务的办理人字段的内容清空。</p>
<p>为了使用类动态分配个人任务，我们将创建一个新类<strong>TaskListenerImpl</strong>，该类要实现TaskListener接口，并实现notify方法达到指定用户任务办理人的目的。在这里，我们指定办理人为<strong>灭绝师太</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.personaltaskbyclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.delegate.DelegateTask;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.delegate.TaskListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskListenerImpl</span> <span class="keyword">implements</span> <span class="title">TaskListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(DelegateTask arg0)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 指定个人任务的办理人，也可以指定组任务的办理人</span></span><br><span class="line">		<span class="comment">// 通过类去查询数据库，将下一个任务的办理人查询获取，</span></span><br><span class="line">		<span class="comment">// 然后通过setAssignee()的方法指定任务的办理</span></span><br><span class="line">		arg0.setAssignee(<span class="string">"灭绝师太"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这样做是还不够的，我们还需要选中<strong>审批</strong>用户任务节点，设置Listener的实现类。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E4%B8%AA%E4%BA%BA%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%88%86%E9%85%8D%E4%B8%AA%E4%BA%BA%E4%BB%BB%E5%8A%A1.png" alt="设置Listener的实现类"></p>
<p>我们查看一下XML文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/MODEL"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:activiti</span>=<span class="string">"http://activiti.org/bpmn"</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/DI"</span> <span class="attr">xmlns:omgdc</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DC"</span> <span class="attr">xmlns:omgdi</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DI"</span> <span class="attr">typeLanguage</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">expressionLanguage</span>=<span class="string">"http://www.w3.org/1999/XPath"</span> <span class="attr">targetNamespace</span>=<span class="string">"http://www.activiti.org/test"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">"task"</span> <span class="attr">name</span>=<span class="string">"taskProcess"</span> <span class="attr">isExecutable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">"startevent1"</span> <span class="attr">name</span>=<span class="string">"Start"</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask1"</span> <span class="attr">name</span>=<span class="string">"审批"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activiti:taskListener</span> <span class="attr">event</span>=<span class="string">"create"</span> <span class="attr">class</span>=<span class="string">"cn.demo.personaltaskbyclass.TaskListenerImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">activiti:taskListener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">"endevent1"</span> <span class="attr">name</span>=<span class="string">"End"</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow1"</span> <span class="attr">sourceRef</span>=<span class="string">"startevent1"</span> <span class="attr">targetRef</span>=<span class="string">"usertask1"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow2"</span> <span class="attr">sourceRef</span>=<span class="string">"usertask1"</span> <span class="attr">targetRef</span>=<span class="string">"endevent1"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">"BPMNDiagram_task"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">"task"</span> <span class="attr">id</span>=<span class="string">"BPMNPlane_task"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"startevent1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_startevent1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"35.0"</span> <span class="attr">width</span>=<span class="string">"35.0"</span> <span class="attr">x</span>=<span class="string">"360.0"</span> <span class="attr">y</span>=<span class="string">"20.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"usertask1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_usertask1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"105.0"</span> <span class="attr">x</span>=<span class="string">"325.0"</span> <span class="attr">y</span>=<span class="string">"120.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"endevent1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_endevent1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"35.0"</span> <span class="attr">width</span>=<span class="string">"35.0"</span> <span class="attr">x</span>=<span class="string">"360.0"</span> <span class="attr">y</span>=<span class="string">"240.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow1"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"377.0"</span> <span class="attr">y</span>=<span class="string">"55.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"377.0"</span> <span class="attr">y</span>=<span class="string">"120.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow2"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"377.0"</span> <span class="attr">y</span>=<span class="string">"175.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"377.0"</span> <span class="attr">y</span>=<span class="string">"240.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到下面这一段，可以看到我们设置的Listener实现类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask1"</span> <span class="attr">name</span>=<span class="string">"审批"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activiti:taskListener</span> <span class="attr">event</span>=<span class="string">"create"</span> <span class="attr">class</span>=<span class="string">"cn.demo.personaltaskbyclass.TaskListenerImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">activiti:taskListener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="部署流程定义和启动流程实例-1"><a href="#部署流程定义和启动流程实例-1" class="headerlink" title="部署流程定义和启动流程实例"></a>部署流程定义和启动流程实例</h4><p>和前面一样，我们重新部署一下流程定义</p>
<blockquote>
<p>部署ID: 5701<br>部署名称: 任务</p>
</blockquote>
<p>部署好流程定义以后，启动流程实例。此时，我们不再需要设置流程变量了，指定办理人的操作交给了监听类<strong>TaskListenerImpl</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"task"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() 	</span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>流程实例ID: 5801<br>流程定义ID: task:3:5704</p>
</blockquote>
<h4 id="查询个人任务-2"><a href="#查询个人任务-2" class="headerlink" title="查询个人任务"></a>查询个人任务</h4><p>现在，我们查询一下灭绝师太的个人任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String assignee = <span class="string">"灭绝师太"</span>;</span><br><span class="line">	List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">			.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">			<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">			.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">			<span class="comment">// .taskCandidateUser(arg0) 组任务的办理人</span></span><br><span class="line">			<span class="comment">// .processDefinitionId(arg0)  流程定义id</span></span><br><span class="line">			<span class="comment">// .processInstanceId(arg0) // 流程实例id</span></span><br><span class="line">			<span class="comment">// .executionId(arg0) // 执行对象id</span></span><br><span class="line">			<span class="comment">/*排序*/</span></span><br><span class="line">			.orderByTaskCreateTime().asc()</span><br><span class="line">			<span class="comment">/*返回结果集*/</span></span><br><span class="line">			<span class="comment">// .singleResult() // 返回唯一结果集</span></span><br><span class="line">			<span class="comment">// .count() // 返回结果集数量</span></span><br><span class="line">			<span class="comment">// .listPage(arg0, arg1) // 分页查询结果集</span></span><br><span class="line">			.list();</span><br><span class="line">	<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">			System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">			System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">			System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">			System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">			System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">			System.out.println(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出灭绝师太个人任务详情</p>
<blockquote>
<p>任务ID: 5804<br>任务名称: 审批<br>任务的创建时间: Sun Oct 28 16:08:46 CST 2018<br>任务的办理人: 灭绝师太<br>流程实例ID: 5801<br>执行对象ID: 5801<br>流程定义ID: task:3:5704</p>
</blockquote>
<p>可以看到，使用类动态分配个人任务也是可行的。</p>
<h4 id="认领和完成任务"><a href="#认领和完成任务" class="headerlink" title="认领和完成任务"></a>认领和完成任务</h4><p>有些时候，我们需要将一个人的任务分配给另一个人，那么，我们就可以使用<strong>taskService</strong>的<strong>setAssignee</strong>方法将灭绝师太的任务转给张翠山。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAssigneeTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"5804"</span>;</span><br><span class="line">	String assignee = <span class="string">"张翠山"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.setAssignee(taskId, assignee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询一下张翠山的个人任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"张翠山"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">				<span class="comment">// .taskCandidateUser(arg0) 组任务的办理人</span></span><br><span class="line">				<span class="comment">// .processDefinitionId(arg0)  流程定义id</span></span><br><span class="line">				<span class="comment">// .processInstanceId(arg0) // 流程实例id</span></span><br><span class="line">				<span class="comment">// .executionId(arg0) // 执行对象id</span></span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				<span class="comment">/*返回结果集*/</span></span><br><span class="line">				<span class="comment">// .singleResult() // 返回唯一结果集</span></span><br><span class="line">				<span class="comment">// .count() // 返回结果集数量</span></span><br><span class="line">				<span class="comment">// .listPage(arg0, arg1) // 分页查询结果集</span></span><br><span class="line">				.list();</span><br><span class="line">		<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>若没有异常，可以看到我们成功将灭绝师太的任务转给了张翠山</p>
<blockquote>
<p>任务ID: 5804<br>任务名称: 审批<br>任务的创建时间: Sun Oct 28 16:08:46 CST 2018<br>任务的办理人: 张翠山<br>流程实例ID: 5801<br>执行对象ID: 5801<br>流程定义ID: task:3:5704</p>
</blockquote>
<p>最后，我们完成张翠山的个人任务，结束该流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"5804"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的介绍，我们已经大致了解了分配个人任务的方式大致有三种</p>
<ol>
<li>在bpmn文件中直接指定办理人</li>
<li>在bpmn文件中使用流程变量，通过给流程变量设值的方式指定办理人</li>
<li>定义一个实现TaskListener接口的类，并自定义<strong>delegateTask.setAssignee(assignee)</strong>方法，指定个人任务的办理人</li>
</ol>
<p>除此之外，我们还可以使用<strong>taskService() </strong>的<strong>setAssignee(taskId, userId)</strong>方法重新指定办理人，将某个人的任务转给另外一个人。</p>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--工作流相关概念</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html</url>
    <content><![CDATA[<p>职场人都知道，个人因处理公司的事务或受公司指派出差执行公司的某项公务而发生的费用，由经办人或申请人按公司的规定，可以凭业务发生的原始单据(发票)向公司报销费用。因此，对于一个公司来说，对于报销都有专门的规定。</p>
<p>假设有一个这样的公司，其报销制度是这样的</p>
<ol>
<li>首先，由申请人按照规定准备好报销需要的相关材料</li>
<li>然后，由申请人将材料送至部门负责人处复核并签字</li>
<li>负责人签字以后，申请人携带相关材料交给财务部审核</li>
<li>经财务部审核无误后，由财务部交给总经理审核</li>
<li>总经理审核通过之后，批准财务部给与报销费用</li>
</ol>
<p>如果这一连串的事情顺利的话，申请人就可以获得经济补偿。对于该公司的每一个人来说，其申请过程大致可以遵循上面的步骤。可以看到，按照报销制度，员工从申请报销到获得经济补偿这一过程中，出现了多个参与者和多次的相关材料的流转。</p>
<p>其实，在生活工作中，有很多事情都可以像上面的规定一样，制定一定的规定处理事务。将这些过程加以抽象归纳，并自动化，就可以将其称为“工作流”，下面介绍“工作流”的相关概念。</p>
<h3 id="工作流的基本概念"><a href="#工作流的基本概念" class="headerlink" title="工作流的基本概念"></a>工作流的基本概念</h3><h4 id="工作流的定义"><a href="#工作流的定义" class="headerlink" title="工作流的定义"></a>工作流的定义</h4><p>所谓的工作流，其实就是“业务过程的部分或整体在计算机应用环境下的自动化”。</p>
<h4 id="工作流的作用"><a href="#工作流的作用" class="headerlink" title="工作流的作用"></a>工作流的作用</h4><p>对于一个工作流来说，其主要解决的是：</p>
<blockquote>
<p>使在多个参与者之间按照某种预定义的规则传递文档、信息或任务的过程自动进行，从而实现某个预期的业务目标或者促使此目标的实现。</p>
</blockquote>
<h3 id="工作流管理系统"><a href="#工作流管理系统" class="headerlink" title="工作流管理系统"></a>工作流管理系统</h3><p>工作流管理系统(WFMS)是一个软件系统。它完成工作量的定义和管理，并按照在系统中预定好的工作流规则进行工作流实例的执行。<strong>需要注意的是，工作流管理系统不是企业的业务系统，而是为企业的业务系统的运行提供了一个软件支撑环境</strong>。</p>
<p>工作流管理联盟(WFMC)这样定义工作流管理系统</p>
<blockquote>
<p>工作流管理系统是一个软件系统，它通过执行经过计算的流程定义去支持一批专门设定的业务流程。工作流管理系统被用来定义、管理和执行工作流程。</p>
</blockquote>
<p>工作流系统的目标：管理工作的流程以确保工作在正确的时间被期望的人员所执行–在自动化进行的业务过程中插入人工的执行和干预。</p>
<h3 id="工作流框架-Activiti5"><a href="#工作流框架-Activiti5" class="headerlink" title="工作流框架-Activiti5"></a>工作流框架-Activiti5</h3><p>Activiti5是由Alfresco软件在2010年5月17日发布的业务流程管理(BPM)框架，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架。<strong>简单来说，Activiti框架是工作流的具体实现</strong>。</p>
<p>对于Activiti来说，其主要组成有以下几个部分</p>
<ul>
<li><p><strong>ProcessEngine对象</strong>，其作用有两点：一，负责生成流程运行时的各种实例和数据；二，监控和管理流程的运行。</p>
</li>
<li><p><strong>BPMN(业务流程建模与标注)</strong>规范，其定义了流程的基本符号以及这些图元如何组成以生成一个业务流程图，通过IDE插件可以实现实现具体的业务流程图，减轻开发者负担，而这正是Activiti框架的特点之一。</p>
</li>
<li><strong>支撑Activiti完成功能的数据库表</strong>，总共有23张，其所有的表都以ACT_开头，后面用两个字符表示其用途，大体可以分为5大类：资源库流程规则表、运行时数据库表、历史数据库表、组织数据库表、通用表</li>
<li><strong>核心配置文件activiti.cfg.xml</strong>，用来配置流程引擎创建工具的基本参数和数据库连接池参数，在activiti中，默认使用MyBatis连接池。</li>
</ul>
<p>需要注意的是，工作流Activiti的表是用来存放流程数据的，而业务数据所需的表需要用户根据实际情况自行创建和维护，在实际开发中，开发者通过业务数据表和流程表相关联来实现有意义的功能。</p>
<p>小结</p>
<p>综上所述，使用Activiti工作流框架的两个基本步骤是</p>
<ol>
<li>首先，先定义工作流，使用插件画出业务流程图，此时会产生两种文件<ul>
<li>*.bpmn文件:该文件提供给计算机进行流程的执行和信息的传递</li>
<li>*.png文件:提供给用户查看流程</li>
</ul>
</li>
<li>调用Activiti的API执行和管理工作流</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--并行网关</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3.html</url>
    <content><![CDATA[<p>紧接着上一章的排他网关，本章开始介绍并行网关(ParallelGateWay)。</p>
<p>和上一章一样，为了更好地讲解并行网关(ParallelGateWay)，我们定义一个网购流程，该流程定义客户付款，商家发货，客户收货，商家收款四个用户任务。</p>
<p>在学习之前，我们创建新包<strong>cn.demo.parallelgateway</strong>及其对应的类<strong>ParallelGateWay</strong>，并新建流程图文件</p>
<p><strong>parallelGateWay.bpmn</strong></p>
<h3 id="定义网购流程"><a href="#定义网购流程" class="headerlink" title="定义网购流程"></a>定义网购流程</h3><p>现在，我们打开<strong>parallelGateWay.bpmn</strong>，开始定义网购流程</p>
<ol>
<li>创建一个开始节点和一个结束节点</li>
<li>创建四个用户任务节点，从左到右，从上到下，分别为usertask1、usertask2、usertask3、usertask4<ul>
<li>设置usertask1的Name值为付款，Assigee的值为买家</li>
<li>设置usertask3的Name值为收款，Assigee的值为商家</li>
<li>设置usertask2的Name值为发货，Assigee的值为商家</li>
<li>设置usertask4的Name值为收货，Assigee的值为买家</li>
</ul>
</li>
<li>在开始节点和用户任务节点，结束节点和用户任务节点之间分别添加一个并行网关,前者用于分支，后者用于聚合</li>
<li>分别连接各节点，形成两个并行的分支<ul>
<li>开始-并行网关-付款-收款-结束</li>
<li>开始-并行网关-发货-收货-结束</li>
</ul>
</li>
<li>点击空白处，设置Id的值为<strong>parallelGateWay</strong>，其Name值为<strong>parallelGateWayProcess</strong></li>
</ol>
<p>当完成上述步骤以后，整个流程就定义好了，其流程图如下</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3.png" alt="并行网关"></p>
<p>可以看到，该流程存在分支并聚合的现象</p>
<h3 id="并行网关"><a href="#并行网关" class="headerlink" title="并行网关"></a>并行网关</h3><h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><p>和前面一样，我们首先要做的依然是部署流程定义以及启动流程实例。先来部署一下流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	InputStream inputStreamBpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"parallelGateWay.bpmn"</span>);</span><br><span class="line">	InputStream inputStreamPng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"parallelGateWay.png"</span>);</span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">			.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">			.name(<span class="string">"并行网关"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">			.addInputStream(<span class="string">"parallelGateWay.bpmn"</span>, inputStreamBpmn)</span><br><span class="line">			.addInputStream(<span class="string">"parallelGateWay.png"</span>,inputStreamPng)</span><br><span class="line">			.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，部署成功的话，将输出如下结果</p>
<blockquote>
<p>部署ID: 4101<br>部署名称: 并行网关</p>
</blockquote>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><p>紧接着部署流程定义之后，理所当然地，我们要启动流程实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"parallelGateWay"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() </span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，如果启动成功，则会得到如下结果</p>
<blockquote>
<p>流程实例ID: 4201<br>流程定义ID: parallelGateWay:1:4104</p>
</blockquote>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><p>分析并行网关的流程图可以知道，当流程实例启动以后，流程会执行到并行网关节点，但是并行网关没有任何操作，所以流程继续往下执行。</p>
<p>下面，我们来分析并行网关执行过程中的数据库表变化。</p>
<h5 id="正在执行的执行对象表"><a href="#正在执行的执行对象表" class="headerlink" title="正在执行的执行对象表"></a>正在执行的执行对象表</h5><p>首先，执行SQL语句<code>SELECT * FROM act_ru_execution</code>，查询<strong>act_ru_execution(正在执行的执行对象表)</strong>，可以看到，数据库表中存在三条记录</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E5%8F%91%E7%BD%91%E5%85%B3-%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E8%A1%A8.png" alt="并发网关-正在执行的执行对象"></p>
<p>注意字段<strong>PROC_INST_ID_(流程实例ID)</strong>和字段<strong>ID_(执行对象ID)</strong>，可以看到，存在一条<strong>ID_</strong>和<strong>PROC_INST_ID_</strong></p>
<p>相等的记录，表明这是一条流程实例记录，而另外两条记录的<strong>ID_</strong>和<strong>PROC_INST_ID_</strong>则不相等，这些是执行对象的记录。因此，在并行网关中，若计算正在执行的对象记录数，应该在并行分支数的基础上加一条。</p>
<h5 id="正在执行的任务表"><a href="#正在执行的任务表" class="headerlink" title="正在执行的任务表"></a>正在执行的任务表</h5><p>接下来，我们执行SQL语句<code>SELECT * FROM act_ru_task</code>，查询<strong>act_ru_task(正在执行的任务表)</strong>，可以看到，和以往同一时间只有一条记录不同，该表同时存在两条记录，即一个流程实例同一时间存在两个正在执行的任务。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3-%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1.png" alt="正在执行的任务1"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3-%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A12.png" alt="正在执行的任务2"></p>
<h5 id="所有活动节点的历史表"><a href="#所有活动节点的历史表" class="headerlink" title="所有活动节点的历史表"></a>所有活动节点的历史表</h5><p>现在，我们来看看所有活动节点的历史表，执行SQL语句<code>SELECT * FROM　act_hi_actinst</code>，可以看到，包括并行网关在内的所有节点总共有四个，其中开始节点和并行网关节点已经结束，而两个任务节点还没有结束</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E5%8F%91%E7%BD%91%E5%85%B3-%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E8%A1%A8.png" alt="所有历史活动节点"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3-%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B91.png" alt="所有历史活动节点1"></p>
<p>为了进一步了解该表的数据变化，我们通过查询<strong>act_ru_task</strong>依次先完成付款、发货、收货这三个任务</p>
<ol>
<li><p>完成付款任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"4207"</span>;</span><br><span class="line">	<span class="comment">// 完成任务的同时，设置流程变量message的值，来控制下一连线</span></span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成发货任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"4210"</span>;</span><br><span class="line">	<span class="comment">// 完成任务的同时，设置流程变量message的值，来控制下一连线</span></span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成收货任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 完成我的任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"4402"</span>;</span><br><span class="line">		<span class="comment">// 完成任务的同时，设置流程变量message的值，来控制下一连线</span></span><br><span class="line">		processEngine.getTaskService().complete(taskId);</span><br><span class="line">		System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当我们完成这三个任务之后，执行SQL语句<code>SELECT * FROM act_ru_execution</code>，查询正在执行的执行对象表</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3-%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E8%A1%A82.png" alt="正在执行的执行对象表2"></p>
<p>可以看到，执行完收货任务后，我们还是可以在该表中查到该执行对象，只是其<strong>ACT_ID_的值</strong>修改为了<strong>parallegateway2</strong>，这是因为我们所使用的是并行网关，先执行到并行网关出口的分支必须等待其它分支执行完毕再通过网关。</p>
<p>查询所有历史活动节点的记录</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3-%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E5%8E%86%E5%8F%B2%E8%A1%A82.png" alt="所有历史活动节点2"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3-%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E5%8E%86%E5%8F%B23.png" alt="所有活动节点历史3"></p>
<p>可以看到，现在总共有7个活动节点</p>
<p>最后，我们再完成最后一个任务-收款任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 完成我的任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"4302"</span>;</span><br><span class="line">		<span class="comment">// 完成任务的同时，设置流程变量message的值，来控制下一连线</span></span><br><span class="line">		processEngine.getTaskService().complete(taskId);</span><br><span class="line">		System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就完成了所有任务，再次查询所有活动节点的历史表</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3-%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E5%8E%86%E5%8F%B2%E8%A1%A83.png" alt="所有活动节点历史表3"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3-%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E5%8E%86%E5%8F%B2%E8%A1%A84.png" alt="所有活动节点历史表4"></p>
<p>分析历史数据，可以看到，对于不同的执行对象，各有一条关于结束并行网关节点的历史记录，并且这两条记录比较特殊，其结束时间为空。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p>一个流程中流程实例只有1个，执行对象有多个</p>
</li>
<li><p>并行网关的功能是基于进入和外出的顺序流的:</p>
<ul>
<li><strong>分支(fork)</strong>： 并行后的所有外出顺序流，为每个顺序流都创建一个并发分支</li>
<li><strong>汇聚(join)</strong>： 所有到达并行网关的分支，都必须在此等待进入的分支， 直到所有进入顺序流的分支都到达以后， 流程就会通过汇聚网关</li>
</ul>
</li>
<li><p>并行网关的进入和外出都是使用相同节点标识</p>
</li>
<li><p>如果同一个并行网关有多个进入和多个外出顺序流， 它就同时具有分支和汇聚功能。 这时，网关会先汇聚所有进入的顺序流，然后再切分成多个并行分支</p>
</li>
<li><p>并行网关不会解析条件。 即使顺序流中定义了条件，也会被忽略</p>
</li>
<li><p>并行网关不需要是“平衡的”（比如， 对应并行网关的进入和外出节点数目不一定相等）。如图中标示是合法的： </p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BD%91%E5%85%B3.png" alt="不平衡的并行网关"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--开发前的准备</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87.html</url>
    <content><![CDATA[<p>在上一篇文章中已经介绍了Activiti框架相关的基本概念，在这一篇中将学习在STS中安装<em>Activiti Designer</em>插件，方便我们以后绘制流程图，下面详细说明安装步骤</p>
<h4 id="插件安装步骤详解"><a href="#插件安装步骤详解" class="headerlink" title="插件安装步骤详解"></a>插件安装步骤详解</h4><ol>
<li>首先，先下载<em>Activiti Designer</em>插件，并解压缩。此时，将得到如下5个文件<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti%E6%8F%92%E4%BB%B6.png" alt="Activiti插件解压后文件"></li>
<li>将上图中的4个jar包复制到STS的<em>features</em>目录下</li>
<li>打开STS，选择顶部菜单栏<em>help</em>-&gt;<em>Install New Software</em>选项,此时打开如下界面<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Activiti%E6%8F%92%E4%BB%B6.png" alt="插件安装"></li>
<li>点击上图中的<em>Add</em>选项，弹出如下界面，此时填上任意一个插件名称，并单击<em>Archive</em>，选择上面解压缩剩余的<em>activiti-designer-5.18.0.zip</em>压缩文件，点击确定。然后，一路点击next，若遇到错误提示，选择继续安装<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%AE%89%E8%A3%85.png" alt="安装"></li>
<li>安装完成后，<em>重启</em>STS即可生效</li>
<li>最后，选择STS菜单栏<em>Window</em>-&gt;<em>Preferences</em>，搜索Activiti，得到如下界面，勾选下图选项。这样，Activiti插件的安装和配置就完成了<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/Activiti%E8%AE%BE%E7%BD%AE.png" alt="Activiti插件设置"></li>
</ol>
<h4 id="插件安装总结"><a href="#插件安装总结" class="headerlink" title="插件安装总结"></a>插件安装总结</h4><ol>
<li>下载<em>Activiti Designer</em>插件压缩包，并解压缩</li>
<li>将解压缩得到的4个jar包复制到STS的<em>features</em>目录下</li>
<li>选择STS菜单栏上的<em>help</em>-&gt;<em>Install New Software</em> ,此时，弹出一个界面，点击<em>Add</em>,在弹出界面填写Name(插件名)，接着，点击<em>Archive</em>,选择解压缩得到的压缩文件，点击确定，一路点击next，遇到错误提示，选择继续安装，直到安装完成</li>
<li>此时，重启STS即安装好了</li>
<li>最后，选择STS菜单栏上的<em>Window</em>-&gt;<em>Preferences</em>，勾选<em>Activiti</em>-&gt;<em>Save Actions</em>右面第一个选项，这样才能保证生成<em>bpmn</em>类型的文件时再生成对应的图片文件</li>
</ol>
<h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><ul>
<li>下载地址：<a href="https://pan.baidu.com/s/1v--lZstIJk-QGSn_tsrTOw" target="_blank" rel="noopener">Activiti Designer插件</a></li>
<li>密码：phad</li>
</ul>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--流程变量</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F.html</url>
    <content><![CDATA[<p>本章开始，我们来了解一个重要的概念-流程变量。流程变量在整个工作流中发挥着极其重要的作用，它记录了流程中的一些重要信息。例如，在请假流程中，请假天数和请假原因等都是流程变量的范围。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E8%AF%B7%E5%81%87.png" alt="流程变量"></p>
<p>在上图中就涉及到设置和获取流程变量的问题。对于一个流程实例来说，其可以有多个流程变量，各个流程实例的流程变量是互不影响的。流程实例结束以后，流程变量仍然保存在数据库中。</p>
<h3 id="流程变量流程图"><a href="#流程变量流程图" class="headerlink" title="流程变量流程图"></a>流程变量流程图</h3><p>为了更好地讲解流程变量这个概念，我们再画一张流程图，在<strong>src\main\resources\diagrams</strong>下新建<strong>processVariables.bpmn</strong>文件，其包含以下节点</p>
<ol>
<li>开始节点，点击空白处，选择<strong>process</strong>选项卡，设置其<strong>Id</strong>为<strong>processVariables</strong>，其<strong>Name</strong>为<strong>processVariablesProcess</strong></li>
<li>创建第一个用户任务节点，节点<strong>Name</strong>为<strong>提交申请</strong>，其<strong>Assignee</strong>为<strong>张晓晓</strong></li>
<li>创建第二个用户任务节点，节点<strong>Name</strong>为<strong>经理审批</strong>，其<strong>Assignee</strong>为<strong>李大大</strong></li>
<li>结束节点</li>
</ol>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F%E6%B5%81%E7%A8%8B.png" alt="流程变量流程"></p>
<h3 id="流程变量作用"><a href="#流程变量作用" class="headerlink" title="流程变量作用"></a>流程变量作用</h3><p>刚才说到流程变量在流程中发挥着极其重要的作用，归纳起来，其主要有三个作用</p>
<ol>
<li>用来传递业务参数</li>
<li>指定连线完成任务(同意和拒绝)</li>
<li>动态指定任务的办理人</li>
</ol>
<p>接下来，我们就通过实际例子感受流程变量的使用</p>
<h3 id="流程变量使用示例"><a href="#流程变量使用示例" class="headerlink" title="流程变量使用示例"></a>流程变量使用示例</h3><h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><p>不可避免地，我们先要部署流程定义，启动流程实例。当这些准备工作做好后，才可以使用流程变量</p>
<p>首先，我们先创建一个新包<strong>cn.demo.processvariables</strong>，再新建一个类<strong>ProcessVariablesTest </strong>。不同于上一章使用<strong>zip</strong>部署流程定义，现在，我们使用输入流来部署流程定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义(从inputstream)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	InputStream inputstreambpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"/diagrams/processVariables.bpmn"</span>);</span><br><span class="line">	InputStream inputstreampng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"/diagrams/processVariables.png"</span>);</span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() </span><br><span class="line">       <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">	.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">	.name(<span class="string">"流程定义"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">	.addInputStream(<span class="string">"processVariables.bpmn"</span>, inputstreambpmn) </span><br><span class="line">       <span class="comment">// 使用资源文件的名称(要求与资源文件的名称要一致)和输入流完成部署</span></span><br><span class="line">	.addInputStream(<span class="string">"processVariables.png"</span>, inputstreampng) </span><br><span class="line">       <span class="comment">// 使用资源文件的名称(要求与资源文件的名称要一致)和输入流完成部署</span></span><br><span class="line">	.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若部署成功，则输出以下结果</p>
<blockquote>
<p>部署ID: 1401<br>部署名称: 流程定义</p>
</blockquote>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><p>部署好流程定义以后，接下来，就是启动流程实例了。查询流程定义表可知，流程定义的<strong>key</strong>为<strong>processVariables</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"processVariables"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() </span><br><span class="line">       <span class="comment">// 与正在执行的流程实例和执行对象相关的Service</span></span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); <span class="comment">// 流程实例Id</span></span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若启动成功，则输出以下结果</p>
<blockquote>
<p>流程实例ID: 1501<br>流程定义ID: processVariables:1:1404</p>
</blockquote>
<p>这样，准备工作就做好了。</p>
<h3 id="设置和获取流程变量"><a href="#设置和获取流程变量" class="headerlink" title="设置和获取流程变量"></a>设置和获取流程变量</h3><p>在启动流程实例以后，接下来就可以学习如何使用流程变量了。使用流程变量可以分为设置流程变量和获取流程变量两部分。</p>
<p>在<strong>Activiti</strong>中，可以使用两个服务来设置和获取流程变量</p>
<ul>
<li>与流程实例、执行对象相关的<strong>runtimeService</strong></li>
<li>与任务相关的<strong>taskService</strong></li>
</ul>
<p><strong>runtimeService</strong>和<strong>taskService</strong>都可以用来设置流程变量，其方法大致相同，既可以使用基本数据类型，也可以使用自定义对象类型设置流程变量。</p>
<p>这两个服务设置流程变量的方法大致相同，如下表</p>
<ol>
<li><strong>runtimeService</strong></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数（设置）</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setVariable(executionId, variableName, variableValue);或setVariableLocal(executionId, variableName, variableValue);</td>
<td style="text-align:center">表示使用执行对象id和流程变量的名称设置流程变量的值，但是一次只能设置一个值</td>
</tr>
<tr>
<td style="text-align:center">setVariables(executionId, variables);或setVariablesLocal(executionId, variables);</td>
<td style="text-align:center">表示使用执行对象id和map集合设置流程变量，map集合的key就是流程变量的名称，value为流程变量的值</td>
</tr>
<tr>
<td style="text-align:center">startProcessInstanceByKey(processDefinitionKey, variables);</td>
<td style="text-align:center">启动流程实例的同时设置流程变量，使用map集合</td>
</tr>
<tr>
<td style="text-align:center"><strong>函数（获取）</strong></td>
<td style="text-align:center"><strong>作用</strong></td>
</tr>
<tr>
<td style="text-align:center">getVariable(executionId, variableName);</td>
<td style="text-align:center">使用执行对象的Id和流程变量的名称获取流程变量的值</td>
</tr>
<tr>
<td style="text-align:center">getVariables(executionId);</td>
<td style="text-align:center">使用执行对象的Id获取所有的流程变量，将流程变量放置到Map集合中，Map集合中的key为流程变量的名称，value为流程变量的值</td>
</tr>
<tr>
<td style="text-align:center">getVariables(executionId, collection);</td>
<td style="text-align:center">使用执行对象Id获取流程变量的值，通过设置流程变量的名称存放到一个集合中，来获取指定流程变量名称的流程变量</td>
</tr>
</tbody>
</table>
<ol start="2">
<li><strong>taskService</strong></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数（设置）</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setVariable(taskId, variableName, variableValue);或setVariableLocal(taskId, variableName, variableValue);</td>
<td style="text-align:center">表示使用任务id和流程变量的名称设置流程变量的值，但是一次只能设置一个值</td>
</tr>
<tr>
<td style="text-align:center">setVariables(taskId, variables);或setVariablesLocal(taskId, variables);</td>
<td style="text-align:center">表示使用任务id和map集合设置流程变量，map集合的key就是流程变量的名称，value为流程变量的值</td>
</tr>
<tr>
<td style="text-align:center">complete(taskId, variables);</td>
<td style="text-align:center">完成任务的同时设置流程变量</td>
</tr>
<tr>
<td style="text-align:center"><strong>函数（获取）</strong></td>
<td style="text-align:center"><strong>作用</strong></td>
</tr>
<tr>
<td style="text-align:center">getVariable(taskId, variableName);</td>
<td style="text-align:center">使用任务Id和流程变量的名称获取流程变量的值</td>
</tr>
<tr>
<td style="text-align:center">getVariables(taskId);</td>
<td style="text-align:center">使用任务Id获取所有的流程变量，将流程变量放置到Map集合中，Map集合中的key为流程变量的名称，value为流程变量的值</td>
</tr>
<tr>
<td style="text-align:center">getVariables(taskId, collection);</td>
<td style="text-align:center">使用任务Id获取流程变量的值，通过设置流程变量的名称存放到一个集合中，获取指定流程变量名称的流程变量</td>
</tr>
</tbody>
</table>
<h4 id="使用基本数据类型"><a href="#使用基本数据类型" class="headerlink" title="使用基本数据类型"></a>使用基本数据类型</h4><p>由上一节可以知道，当前的任务<strong>Id</strong>为1504，可以使用<strong>taskService</strong>设置流程变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置流程变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"1504"</span>;</span><br><span class="line">	TaskService taskService = processEngine.getTaskService();</span><br><span class="line">	<span class="comment">/*设置流程变量，使用基本类型*/</span></span><br><span class="line">	taskService.setVariableLocal(taskId,  <span class="string">"请假天数"</span>, <span class="number">3</span>);<span class="comment">// 与任务Id绑定</span></span><br><span class="line">	taskService.setVariable(taskId, <span class="string">"请假日期"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">	taskService.setVariable(taskId, <span class="string">"请假原因"</span>, <span class="string">"回家探亲"</span>);</span><br><span class="line">	System.out.println(<span class="string">"设置流程变量成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若执行成功，则控制台输出“设置流程变量成功”。现在，我们来看一下相关表数据</p>
<p><strong>act_ru_variable(正在执行的流程变量表)</strong></p>
<p>执行SQL语句<code>SELECT * FROM act_ru_variable</code>，可以看到有三条记录，分别是“请假原因”、“请假日期”、“请假天数”这三条记录</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E4%BD%BF%E7%94%A8%E4%BB%BB%E5%8A%A1%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F1.png" alt="任务服务设置流程变量1"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E4%BD%BF%E7%94%A8%E4%BB%BB%E5%8A%A1%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F2.png" alt="任务服务设置流程变量2"></p>
<p>分析数据可以看到</p>
<ul>
<li>使用<strong>setVariableLocal</strong>方法设置的“请假天数”，其<strong>TASK_ID_</strong>字段的值不为空，”请假天数”和当前任务绑定，而使用<strong>setVariable</strong>方法设置的“请假日期”和“请假原因”其<strong>TASK_ID_</strong>字段的值为空</li>
<li>注意到<strong>TYPE_</strong>字段，<strong>Activiti</strong>根据设置的流程变量的值自动判断了值所属的类型，并且将值存在了相对应类型的字段中</li>
</ul>
<p><strong>act_hi_varinst(历史的流程变量表)</strong></p>
<p>除了<strong>act_ru_variable(正在执行的流程变量表)</strong>，相对应的，还存在一张历史表<strong>act_hi_varinst(历史的流程变量表)</strong>用于存储历史的流程变量</p>
<p>执行SQL语句<code>SELECT * FROM act_hi_varinst</code>查询该表，同样可以获得三条数据</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E5%8E%86%E5%8F%B2%E7%9A%84%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F%E8%A1%A81.png" alt="历史的流程变量表1"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E5%8E%86%E5%8F%B2%E7%9A%84%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F%E8%A1%A82.png" alt="历史的流程变量表2"></p>
<p>现在我们可以获取这些流程变量的值了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取流程变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"1504"</span>;</span><br><span class="line">	TaskService taskService = processEngine.getTaskService();</span><br><span class="line">	<span class="comment">/*获取流程变量，使用基本类型*/</span></span><br><span class="line">	Integer days = (Integer) taskService.getVariable(taskId, <span class="string">"请假天数"</span>);</span><br><span class="line">	Date date = (Date) taskService.getVariable(taskId, <span class="string">"请假日期"</span>);</span><br><span class="line">	String reason = (String) taskService.getVariable(taskId, <span class="string">"请假原因"</span>);</span><br><span class="line">	System.out.println(<span class="string">"请假天数:"</span>+days);</span><br><span class="line">	System.out.println(<span class="string">"请假日期:"</span>+date);</span><br><span class="line">	System.out.println(<span class="string">"请假原因:"</span>+reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，输出”请假天数”、”请假日期”、”请假原因”的值</p>
<blockquote>
<p>请假天数:3<br>请假日期:Wed Sep 26 21:41:11 CST 2018<br>请假原因:回家探亲</p>
</blockquote>
<p>接下来，我们来完成这个任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"1504"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输入任务<strong>Id</strong></p>
<blockquote>
<p>完成任务：任务Id：1504</p>
</blockquote>
<p>此时，张晓晓的任务已经完成，流程执行到李大大，即经理审批这一阶段，此时查询<strong>act_ru_task(正在执行的任务表)</strong>，得到当前任务的任务<strong>Id</strong>为1702，再次获取流程变量的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取流程变量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"1702"</span>;</span><br><span class="line">		TaskService taskService = processEngine.getTaskService();</span><br><span class="line">		<span class="comment">/*获取流程变量，使用基本类型*/</span></span><br><span class="line">		Integer days = (Integer) taskService.getVariable(taskId, <span class="string">"请假天数"</span>);</span><br><span class="line">		Date date = (Date) taskService.getVariable(taskId, <span class="string">"请假日期"</span>);</span><br><span class="line">		String reason = (String) taskService.getVariable(taskId, <span class="string">"请假原因"</span>);</span><br><span class="line">		System.out.println(<span class="string">"请假天数:"</span>+days);</span><br><span class="line">		System.out.println(<span class="string">"请假日期:"</span>+date);</span><br><span class="line">		System.out.println(<span class="string">"请假原因:"</span>+reason);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，可以得到如下结果</p>
<blockquote>
<p>请假天数:null<br>请假日期:Wed Sep 26 21:41:11 CST 2018<br>请假原因:回家探亲</p>
</blockquote>
<p>对比上一个任务执行结果，可以看到请假天数为空值，其原因正是因为我们在设置”请假天数”的时候使用的是<strong>taskService</strong>的<strong>setVariableLocal</strong>方法，该方法将“请假天数”这个流程变量和特定任务绑定在一起造成的。查询<strong>act_ru_variable(正在执行的流程变量表)</strong>，可以看到”请假天数”记录已经不存在了</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F3.png" alt="正在执行的流程变量3"></p>
<p>但是，查询<strong>act_hi_varinst(历史的流程变量表)</strong>，可以看到该数据还存在</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F3.png" alt="历史流程变量3"></p>
<p>再次执行设置流程变量方法，<strong>taskId</strong>修改为1702，”请假天数”修改为5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置流程变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"1702"</span>;</span><br><span class="line">	TaskService taskService = processEngine.getTaskService();</span><br><span class="line">	<span class="comment">/*设置流程变量，使用基本类型*/</span></span><br><span class="line">	taskService.setVariableLocal(taskId,  <span class="string">"请假天数"</span>, <span class="number">5</span>);<span class="comment">// 与任务Id绑定</span></span><br><span class="line">	taskService.setVariable(taskId, <span class="string">"请假日期"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">	taskService.setVariable(taskId, <span class="string">"请假原因"</span>, <span class="string">"回家探亲,一起吃个饭"</span>);</span><br><span class="line">	System.out.println(<span class="string">"设置流程变量成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，查询<strong>act_ru_variable(正在执行的流程变量表)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F4.png" alt="执行完张晓晓任务后的流程变量表"></p>
<p>此时，数据再次回复为三条，”请假天数”这条记录又出现了，其<strong>TASK_ID_</strong>为1702，而”请假日期”和”请假原因”的<strong>REV_</strong>由前面的1变为了2，上一次的记录被覆盖了。</p>
<p>查询<strong>act_hi_varinst(历史的流程变量表)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F4.png" alt="历史流程变量4"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F5.png" alt="历史流程变量5"></p>
<p>可以看到，对应于绑定了不同的任务<strong>Id</strong>的流程变量”请假天数”，其记录各有一条，而对于没有绑定任务<strong>Id</strong>的</p>
<p>流程变量”请假日期”和”请假原因”则分别只有一条记录，旧记录被新纪录所覆盖。</p>
<p>最后，我们结束李大大的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"1702"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次查询<strong>act_ru_variable(正在执行的流程变量表)</strong>，其记录数为0，没有数据，而<strong>act_hi_varinst(历史的流程变量表)</strong>则和上图一样，仍然是四条数据</p>
<h4 id="使用Java-Bean"><a href="#使用Java-Bean" class="headerlink" title="使用Java Bean"></a>使用Java Bean</h4><p>为了演示使用java Bean设置和获取流程变量功能，在<strong>cn.demo.processvariables</strong>包下创建一个简单的Java Bean类<strong>Person</strong>，其有<strong>id</strong>和<strong>name</strong>两个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.processvariables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id; <span class="comment">//编号</span></span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们重新部署流程定义并启动流程实例，得到其部署<strong>Id</strong>为2001，其流程实例<strong>Id</strong>为2101，其流程定义<strong>Id</strong>为processVariables:2:2004，查询<strong>act_ru_task(正在执行的任务表)</strong>，得到其任务<strong>Id</strong>为2104，和上面类似，将该Java Bean设置给“人员信息这个流程变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置流程变量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"2104"</span>;</span><br><span class="line">		TaskService taskService = processEngine.getTaskService();</span><br><span class="line">		<span class="comment">/*设置流程变量，使用基本类型*/</span></span><br><span class="line"><span class="comment">//		taskService.setVariableLocal(taskId,  "请假天数", 5);// 与任务Id绑定</span></span><br><span class="line"><span class="comment">//		taskService.setVariable(taskId, "请假日期", new Date());</span></span><br><span class="line"><span class="comment">//		taskService.setVariable(taskId, "请假原因", "回家探亲,一起吃个饭");</span></span><br><span class="line">		<span class="comment">/*设置流程变量，使用java bean类型*/</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		p.setId(<span class="number">10</span>);</span><br><span class="line">		p.setName(<span class="string">"翠花"</span>);</span><br><span class="line">		taskService.setVariable(taskId, <span class="string">"人员信息"</span>, p);</span><br><span class="line">		System.out.println(<span class="string">"设置流程变量成功"</span>);	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，发生异常</p>
<blockquote>
<p>org.activiti.engine.ActivitiException: couldn’t find a variable type that is able to serialize cn.demo.processvariables.Person@3232a28a<br>    at org.activiti.engine.impl.variable.DefaultVariableTypes.findVariableType(DefaultVariableTypes.java:62)<br>    at org.activiti.engine.impl.persistence.entity.VariableScopeImpl.createVariableInstance(VariableScopeImpl.java:361)……</p>
</blockquote>
<p>从异常信息得到提示，该Java Bean必须实现序列化，因此，我们修改Java Bean代码实现序列化接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.processvariables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id; <span class="comment">//编号</span></span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次执行设置流程变量代码,输出”设置流程变量成功”。</p>
<p>执行SQL语句<code>SELECT * FROM act_ru_variable</code>，查询<strong>act_ru_variable(正在执行的流程变量表)</strong>，可以看到流程变量的类型为<strong>serializable</strong>，其它存储流程变量具体值的字段为空。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/Java%20Bean%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F1.png" alt="JavaBean正在执行的流程变量1"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/Java%20Bean%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F2.png" alt="JavaBean正在执行的流程变量2"></p>
<p>注意到字段<strong>BYTEARRAY_ID_</strong>，该字段是存储该Java Bean具体字段值的<strong>act_ge_bytearray(资源文件表)</strong>主键<strong>Id</strong>。执行SQL语句<code>SELECT * FROM act_ge_bytearray</code></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%A1%A8.png" alt="存储流程变量的资源文件表"></p>
<p>可以看到，<strong>ID_</strong>为2201的记录的<strong>BYTES_</strong>存储的值即为该Java Bean的各字段的值，不难猜测，<strong>ID_</strong>为2203的记录的<strong>BYTES_</strong>字段存储的值就是<strong>act_hi_varinst(历史的流程变量表)</strong>的该Java Bean的各字段的值。</p>
<p>接下来，我们获取这个Java Bean中的字段值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取流程变量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"2104"</span>;</span><br><span class="line">		TaskService taskService = processEngine.getTaskService();</span><br><span class="line">		<span class="comment">/*获取流程变量，使用基本类型*/</span></span><br><span class="line"><span class="comment">//		Integer days = (Integer) taskService.getVariable(taskId, "请假天数");</span></span><br><span class="line"><span class="comment">//		Date date = (Date) taskService.getVariable(taskId, "请假日期");</span></span><br><span class="line"><span class="comment">//		String reason = (String) taskService.getVariable(taskId, "请假原因");</span></span><br><span class="line"><span class="comment">//		System.out.println("请假天数:"+days);</span></span><br><span class="line"><span class="comment">//		System.out.println("请假日期:"+date);</span></span><br><span class="line"><span class="comment">//		System.out.println("请假原因:"+reason);</span></span><br><span class="line">		<span class="comment">/*获取流程变量，使用javabean*/</span></span><br><span class="line">		Person p = (Person) taskService.getVariable(taskId, <span class="string">"人员信息"</span>);</span><br><span class="line">		System.out.println(p.getId()+<span class="string">","</span>+p.getName());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出如下结果</p>
<blockquote>
<p>10,翠花</p>
</blockquote>
<p><strong>注意，当一个Java Bean(实现序列化)放置到流程变量后，要求Java Bean的属性不能再发生变化，如果发生变化，再次获取的时候，将会抛出异常。</strong></p>
<p>现在，我们将修改<strong>Person</strong>类代码，增加一个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.processvariables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id; <span class="comment">//编号</span></span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">private</span> String education;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEducation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> education;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEducation</span><span class="params">(String education)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.education = education;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次执行获取流程变量方法，发生异常</p>
<blockquote>
<p>org.activiti.engine.ActivitiException: Couldn’t deserialize object in variable ‘人员信息’<br>    at org.activiti.engine.impl.variable.SerializableType.getValue(SerializableType.java:68)<br>    at org.activiti.engine.impl.persistence.entity.VariableInstanceEntity.getValue(VariableInstanceEntity.java:165)……</p>
</blockquote>
<p>为了解决该问题，我们先将<strong>Person</strong>类恢复到原状，为该类指定一个固定的序列号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.processvariables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1934812997221186394L</span>;</span><br><span class="line">	<span class="keyword">private</span> Integer id; <span class="comment">//编号</span></span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，我们再重新设置流程变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置流程变量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"2104"</span>;</span><br><span class="line">		TaskService taskService = processEngine.getTaskService();</span><br><span class="line">		<span class="comment">/*设置流程变量，使用基本类型*/</span></span><br><span class="line"><span class="comment">//		taskService.setVariableLocal(taskId,  "请假天数", 5);// 与任务Id绑定</span></span><br><span class="line"><span class="comment">//		taskService.setVariable(taskId, "请假日期", new Date());</span></span><br><span class="line"><span class="comment">//		taskService.setVariable(taskId, "请假原因", "回家探亲,一起吃个饭");</span></span><br><span class="line">		<span class="comment">/*设置流程变量，使用java bean类型*/</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		p.setId(<span class="number">20</span>);</span><br><span class="line">		p.setName(<span class="string">"翠花"</span>);</span><br><span class="line">		taskService.setVariable(taskId, <span class="string">"人员信息(添加固定版本)"</span>, p);</span><br><span class="line">		System.out.println(<span class="string">"设置流程变量成功"</span>);	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>此时，设置流程变量成功，再次执行获取流程变量，成功获取流程变量的值</p>
<blockquote>
<p>20,翠花</p>
</blockquote>
<p>然后，我们再次恢复字段<strong>education</strong>，并保持版本号不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.processvariables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1934812997221186394L</span>;</span><br><span class="line">	<span class="keyword">private</span> Integer id; <span class="comment">//编号</span></span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">private</span> String education;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEducation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> education;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEducation</span><span class="params">(String education)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.education = education;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次执行获取流程变量方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取流程变量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"2104"</span>;</span><br><span class="line">		TaskService taskService = processEngine.getTaskService();</span><br><span class="line">		<span class="comment">/*获取流程变量，使用基本类型*/</span></span><br><span class="line"><span class="comment">//		Integer days = (Integer) taskService.getVariable(taskId, "请假天数");</span></span><br><span class="line"><span class="comment">//		Date date = (Date) taskService.getVariable(taskId, "请假日期");</span></span><br><span class="line"><span class="comment">//		String reason = (String) taskService.getVariable(taskId, "请假原因");</span></span><br><span class="line"><span class="comment">//		System.out.println("请假天数:"+days);</span></span><br><span class="line"><span class="comment">//		System.out.println("请假日期:"+date);</span></span><br><span class="line"><span class="comment">//		System.out.println("请假原因:"+reason);</span></span><br><span class="line">		<span class="comment">/*获取流程变量，使用javabean*/</span></span><br><span class="line">		Person p = (Person) taskService.getVariable(taskId, <span class="string">"人员信息(添加固定版本)"</span>);</span><br><span class="line">		System.out.println(p.getId()+<span class="string">","</span>+p.getName());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>此时程序不再报异常，能够获取到正确的值。</p>
<blockquote>
<p>因此，我们若希望能够当Java Bean的属性发生变化并再次获取时不发生异常，实现序列化接口的同时，固定Java Bean的序列号</p>
</blockquote>
<p>为了便于查询历史流程变量，我们先完成流程</p>
<p>完成张晓晓的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"2104"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成李大大的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"2402"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询流程变量历史表"><a href="#查询流程变量历史表" class="headerlink" title="查询流程变量历史表"></a>查询流程变量历史表</h4><p>最后，我们查询一下流程变量历史表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询流程变量历史表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryProcessVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;HistoricVariableInstance&gt; list = processEngine.getHistoryService()</span><br><span class="line">				.createHistoricVariableInstanceQuery()</span><br><span class="line">				.variableName(<span class="string">"请假天数"</span>)</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(HistoricVariableInstance hvi:list) &#123;</span><br><span class="line">				System.out.println(hvi.getId()+<span class="string">","</span></span><br><span class="line">						+hvi.getProcessInstanceId()</span><br><span class="line">						+<span class="string">","</span>+hvi.getVariableName()</span><br><span class="line">						+<span class="string">","</span>+hvi.getVariableTypeName()</span><br><span class="line">						+<span class="string">","</span>+hvi.getValue());</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出结果</p>
<blockquote>
<p>1601,1501,请假天数,integer,3</p>
<p>1801,1501,请假天数,integer,5</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="流程变量主要知识点"><a href="#流程变量主要知识点" class="headerlink" title="流程变量主要知识点"></a>流程变量主要知识点</h4><ol>
<li>流程变量的作用<ul>
<li>在流程执行或者任务执行的过程中，用于设置和获取变量</li>
<li>使用流程变量在流程传递的过程中传递业务参数</li>
</ul>
</li>
<li>流程变量对应的表<ul>
<li>act_ru_variable：正在执行的流程变量表</li>
<li>act_hi_varinst：流程变量历史表</li>
</ul>
</li>
<li>设置流程变量的设置<ul>
<li>流程变量的作用域就是流程实例，所以可以在任何阶段设置</li>
<li>使用基本类型设置流程变量，在<strong>taskService</strong>中使用任务<strong>Id</strong>，定义流程变量的名称，设置流程变量的值</li>
<li>使用<strong>Javabean</strong>类型设置流程变量，需要这个<strong>JavaBean</strong>实现了<strong>Serializable</strong>接口</li>
<li>设置流程变量的时候，意味着向<strong>act_ru_variable</strong>这个表添加数据</li>
</ul>
</li>
<li>获取流程变量<ul>
<li>流程变量的获取针对流程实例（即1个流程），每个流程实例获取的流程变量是不同的</li>
<li>使用基本类型获取流程变量，在<strong>taskService</strong>中使用任务ID，流程变量的名称，获取流程变量的值</li>
<li><strong>JavaBean</strong>类型设置和获取流程变量，除了需要这个<strong>JavaBean</strong>实现了<strong>Serializable</strong>接口外，还要求流程变量对象的属性不能发生变化，否则抛出异常。解决方案是固定该<strong>JavaBean</strong>的序列化<strong>Id</strong></li>
</ul>
</li>
<li>获取和设置流程变量的服务和时机以及方式<ul>
<li><strong>RuntimeService</strong>对象可以设置流程变量和获取流程变量 </li>
<li><strong>TaskService</strong>对象可以设置流程变量和获取流程变量</li>
<li>流程实例启动的时候可以设置流程变量</li>
<li>任务办理完成的时候可以设置流程变量</li>
<li>流程变量可以通过名称/值的形式设置单个流程变量</li>
<li>流程变量可以通过Map集合，同时设置多个流程变量，Map集合的key表示流程变量的名称，Map集合的value表示流程变量的值</li>
</ul>
</li>
</ol>
<h4 id="setVariable和setVariableLocal的区别"><a href="#setVariable和setVariableLocal的区别" class="headerlink" title="setVariable和setVariableLocal的区别"></a>setVariable和setVariableLocal的区别</h4><p>setVariable：</p>
<p>设置流程变量的时候，流程变量名称相同的时候，后一次的值替换前一次的值，而且可以看到TASK_ID的字段不会存放任务ID的值</p>
<p>setVariableLocal：</p>
<ol>
<li>设置流程变量的时候，针对当前活动的节点设置流程变量，如果一个流程中存在2个活动节点，对每个活动节点都设置流程变量，即使流程变量的名称相同，后一次的版本的值也不会替换前一次版本的值，它会使用不同的任务ID作为标识，存放2个流程变量值，而且可以看到TASK_ID的字段会存放任务ID的值 </li>
<li>还有，使用setVariableLocal说明流程变量绑定了当前的任务，当流程继续执行时，下个任务获取不到这个流程变量（因为正在执行的流程变量中没有这个数据），所有查询正在执行的任务时不能查询到我们需要的数据，此时需要查询历史的流程变量</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--排他网关</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E6%8E%92%E4%BB%96%E7%BD%91%E5%85%B3.html</url>
    <content><![CDATA[<p>在学习完连线的内容之后，本篇开始学习网关(gateway)的相关内容。在activiti中，网关分为两种，一种是排他网关(ExclusiveGateWay)，另外一种是并行网关(ParallelGateWay)。本篇先介绍排他网关(ExclusiveGateWay)，下一篇再介绍并行网关(ParallelGateWay) 。</p>
<p>在activiti中，排他网关(ExclusiveGateWay)起到了判断的作用。</p>
<p>为了讲解排他网关(ExclusiveGateWay)的相关知识，我们定义一个费用报销的流程。该流程由申请人提出费用报销申请，根据金额大小，可分为以下三种情况：</p>
<ol>
<li>当金额大于1000元时，由总经理审批</li>
<li>当金额介于500元到1000元时，由部门经理审批</li>
<li>若不符合上述两个条件，则直接找财务即可</li>
</ol>
<p>在学习之前，我们创建一个新包<strong>cn.demo.exclusivegateway</strong>，并新建测试类<strong>ExclusiveGateWayTest</strong>和流程图文件<strong>exclusiveGateWay.bpmn</strong></p>
<h3 id="定义费用报销流程"><a href="#定义费用报销流程" class="headerlink" title="定义费用报销流程"></a>定义费用报销流程</h3><p>首先，我们先绘制费用报销流程图。</p>
<ol>
<li><p>首先，创建开始节点，点击空白处，设置全局Id的值为<strong>ExclusiveGateWay</strong>，Name的值为<strong>ExclusiveGateWayProcess</strong></p>
</li>
<li><p>其次，创建一个用户任务，设置其Name的值为<strong>费用报销申请</strong>，Assigee的值为<strong>王小五</strong></p>
</li>
<li><p>接着，创建三个用户任务：</p>
<ul>
<li>第一个任务，其Name的值为<strong>审批【部门经理】</strong>，其Assigee的值为<strong>赵小六</strong></li>
<li>第二个任务，其Name的值为<strong>财务</strong>，其Assigee的值为<strong>胡小八</strong></li>
<li>第三个任务，其Name的值为<strong>审批【总经理】</strong>，其Assigee的值为<strong>田小七</strong></li>
</ul>
</li>
<li><p>然后，在IDE右侧的GateWay组件中选择排他网关(ExclusiveGateWay)，置于<strong>费用报销申请</strong>和这三个任务之间，同时，使用该网关分别连接各用户任务节点。为了实现根据不同条件来选择不同连线，我们定义了一个流程变量money，并在连线Condition(条件)中设置逻辑表达式来控制执行哪条连线。</p>
<ul>
<li><p>将连接排他网关和<strong>审批【部门经理】</strong>任务的连线的Name的值设置为<strong>金额小于等于1000元，大于等于500元</strong>，其Condition的值为<strong>${money&gt;=500 &amp;&amp; money&lt;=1000}</strong></p>
</li>
<li><p>将连接排他网关和<strong>审批【总经理】</strong>任务的连线的Name的值设置为<strong>金额大于1000元</strong>，其Condition的值为<strong>${money&gt;1000}</strong> </p>
</li>
<li><p>将连接排他网关和<strong>财务</strong>任务的连线的Name和Id的值都设置为<strong>默认执行财务</strong>，但不设置Condition</p>
</li>
<li><p>点击排他网关图标，将其Default-Flow的值设置为<strong>默认执行财务</strong>，即可设置默认的连线为连接排他网关和<strong>财务</strong>任务的连线，该连线在上述两个连线条件都不满足时，执行该连线。<br><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%8E%92%E4%BB%96%E7%BD%91%E5%85%B3/%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E8%BF%9E%E7%BA%BF.png" alt="设置默认连线"></p>
</li>
</ul>
</li>
<li>最后，创建结束节点，将三个审批任务分别和其相连<br>当完成上述步骤后，可以看到如下效果<br><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%8E%92%E4%BB%96%E7%BD%91%E5%85%B3/%E6%8E%92%E4%BB%96%E7%BD%91%E5%85%B3%E6%B5%81%E7%A8%8B.png" alt="排他网关流程"></li>
</ol>
<h3 id="排他网关示例1"><a href="#排他网关示例1" class="headerlink" title="排他网关示例1"></a>排他网关示例1</h3><h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><p>现在，我们来重新部署一个新的流程定义，和前面一样，我们使用输入流来部署流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	InputStream inputStreamBpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"exclusiveGateWay.bpmn"</span>);</span><br><span class="line">	InputStream inputStreamPng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"exclusiveGateWay.png"</span>);</span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">			.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">			.name(<span class="string">"排他网关"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">			.addInputStream(<span class="string">"exclusiveGateWay.bpmn"</span>, inputStreamBpmn)</span><br><span class="line">			.addInputStream(<span class="string">"exclusiveGateWay.png"</span>,inputStreamPng)</span><br><span class="line">			.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>部署ID: 3301<br>部署名称: 排他网关</p>
</blockquote>
<p>这样，我们就部署好了新的流程定义</p>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><p>在部署好流程定义以后，我们启动流程实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"exclusiveGateWay"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() </span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程实例启动成功后，输出如下结果</p>
<blockquote>
<p>流程实例ID: 3401<br>流程定义ID: exclusiveGateWay:1:3304</p>
</blockquote>
<h4 id="查询张小五个人任务"><a href="#查询张小五个人任务" class="headerlink" title="查询张小五个人任务"></a>查询张小五个人任务</h4><p>启动完流程实例以后，流程就执行到<strong>费用报销申请</strong>任务节点了，此时的办理人是张小五，我们查询一下办理人的个人任务信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String assignee = <span class="string">"王小五"</span>;</span><br><span class="line">	List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">			.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">			<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">			.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">			.orderByTaskCreateTime().asc()</span><br><span class="line">			.list();</span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">			System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">			System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">			System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">			System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">			System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">			System.out.println(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，得到如下信息</p>
<blockquote>
<p>任务ID: 3404<br>任务名称: 费用报销申请<br>任务的创建时间: Sat Oct 13 18:41:18 CST 2018<br>任务的办理人: 王小五<br>流程实例ID: 3401<br>执行对象ID: 3401<br>流程定义ID: exclusiveGateWay:1:3304</p>
</blockquote>
<h4 id="完成张小五个人任务"><a href="#完成张小五个人任务" class="headerlink" title="完成张小五个人任务"></a>完成张小五个人任务</h4><p>查询到张小五的个人任务信息以后，我们使用其任务Id来完成任务，并在完成任务时设置流程变量money的值为<strong>800</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"3404"</span>;</span><br><span class="line">	<span class="comment">// 完成任务的同时，设置流程变量message的值，来控制下一连线</span></span><br><span class="line">	Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">	map.put(<span class="string">"money"</span>, <span class="number">800</span>);</span><br><span class="line">	processEngine.getTaskService().complete(taskId, map);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询和完成审批任务"><a href="#查询和完成审批任务" class="headerlink" title="查询和完成审批任务"></a>查询和完成审批任务</h4><p>当执行完上面代码后，查看我们在上节中的定义，当流程变量money的值介于500到1000元时，需要部门经理审批。为了验证这一想法，我们查询<strong>act_ru_task(正在执行的任务表)</strong>，可以看到，该流程尚未结束,且确实执行到部门经理审批任务节点<br><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%8E%92%E4%BB%96%E7%BD%91%E5%85%B3/%E9%83%A8%E9%97%A8%E7%BB%8F%E7%90%86%E8%B4%B9%E7%94%A8%E5%AE%A1%E6%89%B9.png" alt="部门经理审批"><br>可以看到，现在任务的办理人是赵小六，即部门经理，我们完成该任务，这样该流程就结束了。</p>
<h3 id="排他网关示例2"><a href="#排他网关示例2" class="headerlink" title="排他网关示例2"></a>排他网关示例2</h3><p>为了更充分地说明排他网关的使用，我们重新部署流程定义和启动流程实例。准备工作启动好以后，流程执行到<strong>费用报销申请</strong>，我们查询<strong>act_ru_task(正在执行的任务表)</strong>，得到当前任务Id为<strong>3804</strong>，于是，我们完成该任务并设置流程变量money的值为<strong>200</strong>。</p>
<p>很显然，该费用不用部门经理和总经理审批。由于我们设置了默认的连线，于是，流程执行到<strong>财务</strong>任务节点，办理人为胡小八。<br><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%8E%92%E4%BB%96%E7%BD%91%E5%85%B3/%E8%B4%A2%E5%8A%A1%E5%AE%A1%E6%89%B9.png" alt="财务审批"><br>我们完成财务的任务，这样该流程就结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过学习前面两个排他网关使用实例，我们可以总结出以下六点</p>
<ol>
<li>一个排他网关对应一个以上的顺序流</li>
<li>由排他网关流出的顺序流都有个condition表达式元素，在内部维护返回boolean类型的决策结果</li>
<li>决策网关只会返回一条结果。当流程执行到排他网关时，流程引擎会自动检索网关出口，从上到下检索，如果发现第一条决策结果为true或者没有设置条件的(默认为成立)，则流出</li>
<li>如果没有任何一个出口符合条件，则抛出异常</li>
<li>使用流程变量，设置连线的条件，并按照连线的条件执行工作流，如果没有条件符合的条件，则以默认的连线离开</li>
<li>设置默认连线时，Default-Flow可选择的值来自各连线的Id</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--流程历史数据查询</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E6%B5%81%E7%A8%8B%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2.html</url>
    <content><![CDATA[<p>学完上一章关于“流程变量”知识的介绍，这一章我们学习查询流程历史数据。查询流程历史数据比较简单。下面我们就来完成四类历史数据的查询。</p>
<p>在学习查询流程历史数据之前，先创建一个包<strong>cn.demo.historyquery</strong>，再新建一个类<strong>HistoryQueryTest</strong>用于示例代码的编写。</p>
<p>无论查询什么历史数据，使用的都是<strong>historyService</strong>及其对应的方法，下面都是按照历史流程实例<strong>Id</strong>来查的。</p>
<h3 id="查询历史流程实例"><a href="#查询历史流程实例" class="headerlink" title="查询历史流程实例"></a>查询历史流程实例</h3><p>就是查询按照某个流程定义的规则一共执行了多少次流程，下面根据特定流程实例<strong>Id</strong>查询单个流程实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询历史流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String processInstanceId =<span class="string">"2101"</span>;</span><br><span class="line">	HistoricProcessInstance hpi = processEngine.getHistoryService().createHistoricProcessInstanceQuery()</span><br><span class="line">	.processInstanceId(processInstanceId)</span><br><span class="line">	.orderByProcessInstanceStartTime().asc()</span><br><span class="line">	.singleResult();</span><br><span class="line">	System.out.println(hpi.getId()+<span class="string">" "</span>+hpi.getProcessDefinitionId()+<span class="string">" "</span>+hpi.getStartTime()+<span class="string">" "</span>+hpi.getEndTime());</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上代码，结果如下</p>
<blockquote>
<p>2101 processVariables:2:2004 Thu Sep 27 20:12:21 CST 2018 Thu Sep 27 21:48:47 CST 2018</p>
</blockquote>
<h3 id="查询历史活动"><a href="#查询历史活动" class="headerlink" title="查询历史活动"></a>查询历史活动</h3><p>查询某一次流程的执行一共经历了多少个活动，即走完一次流程所需的所有节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	查询历史活动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryActiviti</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String processInstanceId =<span class="string">"2101"</span>;</span><br><span class="line">	List&lt;HistoricActivityInstance&gt; list = processEngine.getHistoryService().createHistoricActivityInstanceQuery()</span><br><span class="line">	.processInstanceId(processInstanceId)</span><br><span class="line">	.orderByHistoricActivityInstanceStartTime().asc()</span><br><span class="line">	.list();</span><br><span class="line">	<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(HistoricActivityInstance hai:list) &#123;</span><br><span class="line">			System.out.println(hai.getId()+<span class="string">" "</span>+hai.getProcessInstanceId()+<span class="string">" "</span></span><br><span class="line">					+hai.getActivityType()+<span class="string">" "</span></span><br><span class="line">					+hai.getStartTime()+<span class="string">" "</span></span><br><span class="line">					+hai.getEndTime()+<span class="string">" "</span></span><br><span class="line">					+hai.getDurationInMillis()</span><br><span class="line">					);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，有如下结果</p>
<blockquote>
<p>2102 2101 startEvent Thu Sep 27 20:12:21 CST 2018 Thu Sep 27 20:12:21 CST 2018 38</p>
<p>2103 2101 userTask Thu Sep 27 20:12:21 CST 2018 Thu Sep 27 21:45:27 CST 2018 5586685</p>
<p>2401 2101 userTask Thu Sep 27 21:45:27 CST 2018 Thu Sep 27 21:48:46 CST 2018 199660</p>
<p>2501 2101 endEvent Thu Sep 27 21:48:47 CST 2018 Thu Sep 27 21:48:47 CST 2018 1</p>
</blockquote>
<h3 id="查询历史任务"><a href="#查询历史任务" class="headerlink" title="查询历史任务"></a>查询历史任务</h3><p>某一次流程的执行一共经历了多少个任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询历史任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String processInstanceId = <span class="string">"2101"</span>;</span><br><span class="line">	List&lt;HistoricTaskInstance&gt; list = processEngine.getHistoryService().</span><br><span class="line">			createHistoricTaskInstanceQuery()</span><br><span class="line">			.processInstanceId(processInstanceId)</span><br><span class="line">			.orderByHistoricTaskInstanceStartTime().asc().list();</span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (HistoricTaskInstance hti : list) &#123;</span><br><span class="line">			System.out.println(hti.getId() + <span class="string">" "</span> + hti.getName() + <span class="string">" "</span> + hti.getProcessInstanceId() + <span class="string">" "</span></span><br><span class="line">					+ hti.getStartTime() + <span class="string">" "</span> + hti.getEndTime());</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>2104 提交申请 2101 Thu Sep 27 20:12:21 CST 2018 Thu Sep 27 21:45:27 CST 2018</p>
<p>2402 经理审批 2101 Thu Sep 27 21:45:27 CST 2018 Thu Sep 27 21:48:46 CST 2018</p>
</blockquote>
<h3 id="查询历史流程变量表"><a href="#查询历史流程变量表" class="headerlink" title="查询历史流程变量表"></a>查询历史流程变量表</h3><p>查询某一次流程的执行设置的所有流程变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询流程变量历史表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryProcessVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String processInstanceId = <span class="string">"2101"</span>;</span><br><span class="line">		List&lt;HistoricVariableInstance&gt; list = processEngine.getHistoryService()</span><br><span class="line">				.createHistoricVariableInstanceQuery()</span><br><span class="line">				.processInstanceId(processInstanceId)</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(HistoricVariableInstance hvi:list) &#123;</span><br><span class="line">				System.out.println(hvi.getId()+<span class="string">","</span></span><br><span class="line">						+hvi.getProcessInstanceId()</span><br><span class="line">						+<span class="string">","</span>+hvi.getVariableName()</span><br><span class="line">						+<span class="string">","</span>+hvi.getVariableTypeName()</span><br><span class="line">						+<span class="string">","</span>+hvi.getValue());</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>2202,2101,人员信息,serializable,cn.demo.processvariables.Person@65c7a252</p>
<p>2302,2101,人员信息(添加固定版本),serializable,cn.demo.processvariables.Person@4d154ccd</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于数据库中保存着历史信息以及正在运行的流程实例信息，在实际项目中对已完成任务的查看频率远不及对待办和可接任务的查看，所以在activiti采用分开管理，把正在运行的交给<strong>runtimeService</strong>、<strong>taskService</strong>管理，而历史数据交给<strong>historyService</strong>来管理。</p>
<p>这样做的好处在于，加快流程执行的速度，因为正在执行的流程的表中数据不会很大。</p>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--流程定义的CRUD</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E7%9A%84CRUD.html</url>
    <content><![CDATA[<p>上篇文章中，我们学习了入门示例<strong>HelloWorld</strong>，这一章我们将学习流程定义的CRUD，了解流程定义文档，流程定义的部署、查询和删除以及操作流程定义过程中的数据库表数据变化。</p>
<h3 id="流程定义文档"><a href="#流程定义文档" class="headerlink" title="流程定义文档"></a>流程定义文档</h3><p>流程定义文档由bpmn文件和展示流程图的图片这两部分组成</p>
<h4 id="bpmn文件-流程规则文件"><a href="#bpmn文件-流程规则文件" class="headerlink" title="bpmn文件(流程规则文件)"></a>bpmn文件(流程规则文件)</h4><blockquote>
<p>在BPMN 2.0文件中，其根节点是definitions节点。 在这个元素中，可以定义多个流程定义（不过我们建议每个文件只包含一个流程定义， 可以简化开发过程中的维护难度）。 注意，definitions元素最少也要包含xmlns 和 targetNamespace的声明。 targetNamespace可以是任意值，它用来对流程实例进行分类。</p>
</blockquote>
<p>一个典型的<strong>bpmn</strong>文件如下<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/MODEL"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:activiti</span>=<span class="string">"http://activiti.org/bpmn"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:bpmndi</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/DI"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:omgdc</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DC"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:omgdi</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DI"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">typeLanguage</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">expressionLanguage</span>=<span class="string">"http://www.w3.org/1999/XPath"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">targetNamespace</span>=<span class="string">"http://www.activiti.org/test"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">"helloworld"</span> <span class="attr">name</span>=<span class="string">"helloworldProcess"</span> <span class="attr">isExecutable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">"startevent1"</span> <span class="attr">name</span>=<span class="string">"Start"</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">"endevent1"</span> <span class="attr">name</span>=<span class="string">"End"</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask1"</span> <span class="attr">name</span>=<span class="string">"提交申请"</span> <span class="attr">activiti:assignee</span>=<span class="string">"张三"</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask2"</span> <span class="attr">name</span>=<span class="string">"审批【部门经理】"</span> <span class="attr">activiti:assignee</span>=<span class="string">"李四"</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask3"</span> <span class="attr">name</span>=<span class="string">"审批【总经理】"</span> <span class="attr">activiti:assignee</span>=<span class="string">"王五"</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow1"</span> <span class="attr">sourceRef</span>=<span class="string">"startevent1"</span> <span class="attr">targetRef</span>=<span class="string">"usertask1"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow2"</span> <span class="attr">sourceRef</span>=<span class="string">"usertask1"</span> <span class="attr">targetRef</span>=<span class="string">"usertask2"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow3"</span> <span class="attr">sourceRef</span>=<span class="string">"usertask2"</span> <span class="attr">targetRef</span>=<span class="string">"usertask3"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow4"</span> <span class="attr">sourceRef</span>=<span class="string">"usertask3"</span> <span class="attr">targetRef</span>=<span class="string">"endevent1"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">"BPMNDiagram_helloworld"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">"helloworld"</span> <span class="attr">id</span>=<span class="string">"BPMNPlane_helloworld"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"startevent1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_startevent1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"35.0"</span> <span class="attr">width</span>=<span class="string">"35.0"</span> <span class="attr">x</span>=<span class="string">"390.0"</span> <span class="attr">y</span>=<span class="string">"50.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"endevent1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_endevent1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"35.0"</span> <span class="attr">width</span>=<span class="string">"35.0"</span> <span class="attr">x</span>=<span class="string">"390.0"</span> <span class="attr">y</span>=<span class="string">"380.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"usertask1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_usertask1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"105.0"</span> <span class="attr">x</span>=<span class="string">"355.0"</span> <span class="attr">y</span>=<span class="string">"120.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"usertask2"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_usertask2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"105.0"</span> <span class="attr">x</span>=<span class="string">"355.0"</span> <span class="attr">y</span>=<span class="string">"200.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"usertask3"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_usertask3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"105.0"</span> <span class="attr">x</span>=<span class="string">"355.0"</span> <span class="attr">y</span>=<span class="string">"290.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow1"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"85.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"120.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow2"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"175.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"200.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow3"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"255.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"290.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow4"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow4"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"345.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"407.0"</span> <span class="attr">y</span>=<span class="string">"380.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，该文件的根节点是<strong>definitions</strong>，包含了<strong>targetNamespace</strong>和<strong>xmlns</strong>的声明。<br><strong>在部署后，系统每次启动时都会解析bpmn文件，把内容封装成流程定义放入项目缓存中。Activiti框架结合这个xml文件自动管理流程，流程的执行就是按照bpmn文件定义的规则执行的</strong></p>
<h4 id="流程图文件"><a href="#流程图文件" class="headerlink" title="流程图文件"></a>流程图文件</h4><p>在系统里需要展示流程走向的图片，展示给用户看</p>
<h3 id="管理和分析流程定义运行"><a href="#管理和分析流程定义运行" class="headerlink" title="管理和分析流程定义运行"></a>管理和分析流程定义运行</h3><p>为了更好地讲述流程定义，在<code>src/main/java</code>新建新包<code>cn.processdefinition</code>，并创建类<strong>ProcessDefinitionTest</strong></p>
<h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><p>无论如何，对于一个流程来说，都必须先部署，其代码和上篇中的代码基本一样<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">			.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">			.name(<span class="string">"流程定义"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">			<span class="comment">// 从classpath的资源中加载，一次只能加载一个文件</span></span><br><span class="line">			.addClasspathResource(<span class="string">"diagrams/helloworld.bpmn"</span>) </span><br><span class="line">			.addClasspathResource(<span class="string">"diagrams/helloworld.png"</span>).deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述代码，可以得到如下结果</p>
<blockquote>
<p>部署ID: 501<br>部署名称: 流程定义</p>
</blockquote>
<p>接下来，我们来看一下部署流程定义涉及到的表操作</p>
<h4 id="部署流程定义涉及到的相关表"><a href="#部署流程定义涉及到的相关表" class="headerlink" title="部署流程定义涉及到的相关表"></a>部署流程定义涉及到的相关表</h4><p>我们知道，部署流程定义的主要操作可以分解为以下几个步骤</p>
<ol>
<li>首先获得默认的流程引擎，然后，通过流程引擎获取一个<strong>repositoryService</strong>对象（仓库对象）</li>
<li>由仓库的服务对象产生一个部署对象配置对象，用来封装部署操作的相关配置。 </li>
<li>这是一个链式编程，在部署配置对象中设置显示名，上传流程定义规则文件</li>
<li>向数据库表中存放流程定义的规则信息，在这最后一步中，其操作主要涉及到了三张表:act_re_deployment（部署对象表）,act_re_procdef（流程定义表）,act_ge_bytearray（资源文件表）</li>
</ol>
<p>第一张表<strong>act_re_deployment（部署对象表）</strong>，存放流程定义的显示名和部署时间，每部署一次增加一条记录<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%AF%B9%E8%B1%A1%E8%A1%A8.png" alt="流程对象"><br>第二张表<strong>act_re_procdef（流程定义表）</strong>，存放流程定义的属性信息，部署每个新的流程定义都会在这张表中增加一条记录。当流程定义的key相同的情况下，使用的是版本升级，<br>从图中可以看到，两条记录的<strong>KEY</strong>值是一样的，<strong>VERSION</strong>不一样，存在两个不同的版本，且版本为2的记录是后生成的。观察字段<strong>ID_</strong>，其组成为<strong>KEY:VERSION_:随机数</strong>格式<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%891.png" alt="流程定义1"><br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%892.png" alt="流程定义2"><br>第三张表<strong>act_ge_bytearray（资源文件表）</strong>存储流程定义相关的部署信息。即流程定义文档的存放地址。每部署一次就会增加两条记录，一条是关于bpmn规则文件的，一条是图片的（如果部署时只指定了bpmn一个文件，activiti会在部署时解析bpmn文件内容自动生成流程图）。两个文件不是很大，都是以二进制形式存储在数据库中，存储字段为 BYTES_<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%A1%A8.png" alt="资源文件"><br>当然，还有比较一张特殊的表<strong>act_ge_property(主键生成策略表)</strong>，该表生成了下一次部署流程时使用的部署对象主键ID<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E8%A1%A8.png" alt="主键生成策略表"></p>
<h4 id="部署流程定义-zip格式文件"><a href="#部署流程定义-zip格式文件" class="headerlink" title="部署流程定义(zip格式文件)"></a>部署流程定义(zip格式文件)</h4><p>除了直接使用<strong>helloworld.bpmn</strong>和<strong>helloworld.png</strong>文件部署流程之外，还可以使用zip来部署流程。可以将上述项目中的这两个文件压缩为一个<strong>helloworld.zip</strong>文件放到<code>src/main/resources/diagrams</code>目录下，通过代码实现部署流程定义，实现代码如下所示<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义(zip文件格式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinitionZip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	InputStream in = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"diagrams/helloworld.zip"</span>);</span><br><span class="line">	ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(in);</span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() </span><br><span class="line">       <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">	.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">	.name(<span class="string">"流程定义"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">	.addZipInputStream(zipInputStream)</span><br><span class="line">	.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上述代码通过<code>addZipInputStream(zipInputStream)</code>加载一个压缩文件流实现了使用zip文件部署流程定义。此时，输出如下结果</p>
<blockquote>
<p>部署ID: 601<br>部署名称: 流程定义</p>
</blockquote>
<p>当部署完成之后，部署对象表增加一条记录，流程定义表会增加一条记录，资源文件表增加两条记录，主键生成策略表生成下一次部署流程定义时使用到的部署对象ID<br>部署对象表<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/zip%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%891.png" alt="部署流程对象"><br>可以看到，该新增记录的<strong>ID_</strong>值正好为上一节中主键生成策略表中的<strong>VALUE_</strong> 值<br>流程定义表<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/zip%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%891.png" alt="流程定义表1"><br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/zip%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%892.png" alt="流程定义表2"><br>从图中可知，该表增加了一条记录，版本字段值较上一个版本增加1<br>资源文件表<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/zip%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%A1%A8.png" alt="资源文件表"><br>主键生成策略表<br><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/zip%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E8%A1%A8.png" alt="主键生成策略表"><br>从上面例子很容易预见，该<strong>VALUE_</strong>值为下一次部署流程定义时使用的流程ID</p>
<h4 id="查看流程定义"><a href="#查看流程定义" class="headerlink" title="查看流程定义"></a>查看流程定义</h4><p>有些时候，我们需要查询流程定义，其代码可以这样写<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;ProcessDefinition&gt;  list = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">		.createProcessDefinitionQuery() <span class="comment">// 创建一个流程定义查询</span></span><br><span class="line">		<span class="comment">/*指定查询条件,where*/</span></span><br><span class="line"><span class="comment">//		.deploymentId(deploymentId) // 使用部署对象ID查询</span></span><br><span class="line"><span class="comment">//		.processDefinitionId(processDefinitionId) // 使用流程定义ID查询</span></span><br><span class="line"><span class="comment">//		.processDefinitionKey(processDefinitionKey) //使用流程定义的key查询</span></span><br><span class="line"><span class="comment">//		.processDefinitionNameLike(processDefinitionName) // 使用流程定义的名称模糊查询</span></span><br><span class="line">		<span class="comment">/*排序*/</span></span><br><span class="line">		<span class="comment">/*返回结果集*/</span></span><br><span class="line">		.orderByProcessDefinitionVersion().asc() <span class="comment">// 按照版本的升序排列</span></span><br><span class="line"><span class="comment">//		.orderByProcessDefinitionName().desc() // 按照流程定义的名称降序排列</span></span><br><span class="line">		.list();<span class="comment">// 返回集合列表，封装流程定义</span></span><br><span class="line"><span class="comment">//		.singleResult() // 返回唯一结果集</span></span><br><span class="line"><span class="comment">//		.count() // 返回结果集数量</span></span><br><span class="line"><span class="comment">//		.listPage(firstResult,maxResult);</span></span><br><span class="line">		<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ProcessDefinition pd:list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID:"</span>+pd.getId()); <span class="comment">// 流程定义的key版本+:+随机生成数</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的名称:"</span>+pd.getName()); <span class="comment">// 对应helloworld.bpmn文件中的name属性值</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的key:"</span>+pd.getKey());  <span class="comment">// 对应helloworld.bpmn文件中的id属性值</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的版本:"</span>+pd.getVersion()); <span class="comment">// 当流程定义中的key相同，版本升级，默认版本为1</span></span><br><span class="line">				System.out.println(<span class="string">"资源名称bpmn文件:"</span>+pd.getResourceName()); </span><br><span class="line">				System.out.println(<span class="string">"资源名称png文件:"</span>+pd.getDiagramResourceName());</span><br><span class="line">				System.out.println(<span class="string">"部署对象的ID:"</span>+pd.getDeploymentId());</span><br><span class="line">				System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该段代码，从结果中得出以下结论</p>
<ol>
<li>流程定义和部署对象的<strong>service</strong>都是<strong>repositoryService</strong></li>
<li>创建流程定义查询对象，可以在<strong>ProcessDefinitionQuery</strong>上设置查询的相关参数</li>
<li>调用<strong>ProcessDefinitionQuery</strong>对象的<strong>list()</strong>方法，执行查询，获得符合条件的流程定义列表</li>
<li>比较bpmn文件，可以看出，流程定义中的key和name的值分别为bpmn文件process节点的id和name的属性值，其中，key被用来区分不同的流程定义</li>
<li>带有特定key的流程定义第一次部署时，version为1。之后每次部署都会在当前最高版本号上加1</li>
<li>流程定义表id的生成规则为：{流程定义key}:{流程定义版本}:{按一定规则生成的数字}</li>
<li>重复部署一次，deploymentId的值以一定的形式变化</li>
</ol>
<h4 id="删除流程定义"><a href="#删除流程定义" class="headerlink" title="删除流程定义"></a>删除流程定义</h4><p>有些时候，我们希望删除流程，就可以调用<strong>repositoryService</strong>的删除流程方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除流程定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteProcessDefintion</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用部署ID，完成删除</span></span><br><span class="line">	String deploymentId = <span class="string">"601"</span>;</span><br><span class="line">	<span class="comment">/* 不带级联删除</span></span><br><span class="line"><span class="comment">	 * 只能删除没有启动的流程，如果流程启动就会抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//processEngine.getRepositoryService().deleteDeployment(deploymentId);</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 级联删除，不管流程是否启动，都可以删除</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	processEngine.getRepositoryService().deleteDeployment(deploymentId,<span class="keyword">true</span>);</span><br><span class="line">	System.out.println(<span class="string">"删除成功！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为删除的是流程定义，而流程定义的部署是属于仓库服务的，所以应该先得到<strong>repositoryService</strong>。<br>在删除流程代码中，罗列了使用了两种删除方法。</p>
<ul>
<li>不带级联的删除：该方法只能删除没有启动的流程，如果删除已经启动的流程就会抛出异常，否则用级联删除</li>
<li>级联删除：项目开发中使用级联删除的情况比较多，删除操作一般只开放给超级管理员使用</li>
</ul>
<h4 id="获取流程定义文档的资源（查看流程图附件）"><a href="#获取流程定义文档的资源（查看流程图附件）" class="headerlink" title="获取流程定义文档的资源（查看流程图附件）"></a>获取流程定义文档的资源（查看流程图附件）</h4><p>流程定义文档主要是指<strong>bpmn</strong>文件以及<strong>png</strong>文件，这里主要查看的是<strong>png</strong>格式的图片<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看流程图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">viewPic</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">/*将生成的图片放到文件夹下*/</span></span><br><span class="line">	String deploymentId = <span class="string">"801"</span>;</span><br><span class="line">	<span class="comment">// 获取图片资源名称</span></span><br><span class="line">	List&lt;String&gt; list = processEngine.getRepositoryService().getDeploymentResourceNames(deploymentId);</span><br><span class="line">	String resourceName = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(String name:list) &#123;</span><br><span class="line">			<span class="keyword">if</span>(name.indexOf(<span class="string">".png"</span>)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				resourceName = name;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	InputStream in = processEngine.getRepositoryService()</span><br><span class="line">	.getResourceAsStream(deploymentId, resourceName);</span><br><span class="line">	<span class="comment">//将图片生成到D盘的目录</span></span><br><span class="line">	File file = <span class="keyword">new</span> File(<span class="string">"D:/"</span>+resourceName);</span><br><span class="line">	<span class="comment">//将输入流的图片图片写到D盘下</span></span><br><span class="line">	FileUtils.copyInputStreamToFile(in, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，获取流程文档时，我们需要注意以下几点</p>
<ol>
<li>我们使用了流程部署对象ID(<strong>deploymentId</strong>)</li>
<li>资源名称<strong>resourceName</strong>则为<strong>act_ge_bytearray</strong>表中<strong>NAME_</strong>列的值</li>
<li>使用<strong>repositoryService</strong>下的<strong>getDeploymentResourceNames</strong>方法可以获取指定部署下的所有文件的资源名称</li>
<li>使用<strong>repositoryService</strong>下的<strong>getResourceAsStream</strong>方法可以获得指定部署下指定资源名称的文件的输入流</li>
<li>使用<strong>FileUtils</strong>工具的<strong>copyInputStreamToFile</strong>方法，将资源文件以流的形式输出到指定文件夹下</li>
</ol>
<h4 id="查询最新版本的流程定义"><a href="#查询最新版本的流程定义" class="headerlink" title="查询最新版本的流程定义"></a>查询最新版本的流程定义</h4><p>对于流程定义来说，可能存在多个版本，如果想要获取最新版本的流程定义，可以先按照版本号升序排序获取流程定义列表，再遍历列表，获取最新的流程定义<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 附加功能:查询最新版本的流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLastVersionProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;ProcessDefinition&gt; list = processEngine.getRepositoryService()</span><br><span class="line">		.createProcessDefinitionQuery()</span><br><span class="line">		.orderByProcessDefinitionVersion().asc() <span class="comment">// 按照流程定义的版本升序排列</span></span><br><span class="line">		.list();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * map 集合的key为流程定义的key</span></span><br><span class="line"><span class="comment">		 * map 集合的value为流程定义的对象</span></span><br><span class="line"><span class="comment">		 * 当map集合的key相同时，后一次的值将代替前一次的值</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		Map&lt;String,ProcessDefinition&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String,ProcessDefinition&gt;();</span><br><span class="line">		<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ProcessDefinition pd:list) &#123;</span><br><span class="line">				map.put(pd.getKey(), pd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;ProcessDefinition&gt; pdList = <span class="keyword">new</span> ArrayList&lt;ProcessDefinition&gt;(map.values());</span><br><span class="line">		<span class="keyword">if</span>(pdList!=<span class="keyword">null</span> &amp;&amp; pdList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ProcessDefinition pd:pdList) &#123;</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID:"</span>+pd.getId()); <span class="comment">// 流程定义的key版本+:+随机生成数</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的名称:"</span>+pd.getName()); <span class="comment">// 对应helloworld.bpmn文件中的name属性值</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的key:"</span>+pd.getKey());  <span class="comment">// 对应helloworld.bpmn文件中的id属性值</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的版本:"</span>+pd.getVersion()); <span class="comment">// 当流程定义中的key相同，版本升级，默认版本为1</span></span><br><span class="line">				System.out.println(<span class="string">"资源名称bpmn文件:"</span>+pd.getResourceName()); </span><br><span class="line">				System.out.println(<span class="string">"资源名称png文件:"</span>+pd.getDiagramResourceName());</span><br><span class="line">				System.out.println(<span class="string">"部署对象的ID:"</span>+pd.getDeploymentId());</span><br><span class="line">				System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除流程定义-删除key相同的所有不同版本的流程定义"><a href="#删除流程定义-删除key相同的所有不同版本的流程定义" class="headerlink" title="删除流程定义(删除key相同的所有不同版本的流程定义)"></a>删除流程定义(删除key相同的所有不同版本的流程定义)</h4><p>前面我们讲过通过部署对象ID删除流程定义，现在，我们需要根据<strong>key</strong>删除所有版本的流程定义。<br>首先，先通过<strong>key</strong>获取不同版本的流程定义对象列表。接着，循环遍历该对象，通过对象的部署对象ID值逐个删除流程定义，最终，达到删除key值相同的所有不同版本的流程定义的目的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 附加功能: 删除流程定义(删除key相同的所有不同版本的流程定义)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteProcessDefinitionByKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String processDefinitionKey = <span class="string">"helloworld"</span>;</span><br><span class="line">		<span class="comment">// 先使用流程定义的key查询流程定义，查询出所有的版本</span></span><br><span class="line">		 List&lt;ProcessDefinition&gt; list = processEngine.getRepositoryService().createProcessDefinitionQuery()</span><br><span class="line">		.processDefinitionKey(processDefinitionKey) <span class="comment">//使用流程定义的key查询</span></span><br><span class="line">		.list(); </span><br><span class="line">		 <span class="comment">// 遍历，获取每个流程定义的部署ID	 </span></span><br><span class="line">		 <span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			 <span class="keyword">for</span>(ProcessDefinition pd:list) &#123;</span><br><span class="line">				 String deploymentId = pd.getDeploymentId();</span><br><span class="line">				 processEngine.getRepositoryService().deleteDeployment(deploymentId, <span class="keyword">true</span>);</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.processdefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngines;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.repository.Deployment;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.repository.ProcessDefinition;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.repository.ProcessDefinitionQuery;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessDefinitionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 部署流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">				.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">				.name(<span class="string">"流程定义"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">				<span class="comment">// 从classpath的资源中加载，一次只能加载一个文件</span></span><br><span class="line">				.addClasspathResource(<span class="string">"diagrams/helloworld.bpmn"</span>) </span><br><span class="line">				.addClasspathResource(<span class="string">"diagrams/helloworld.png"</span>).deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">		System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">		System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 部署流程定义(zip文件格式)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinitionZip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		InputStream in = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"diagrams/helloworld.zip"</span>);</span><br><span class="line">		ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(in);</span><br><span class="line">		Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">				.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">				.name(<span class="string">"流程定义"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">				.addZipInputStream(zipInputStream)</span><br><span class="line">				.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">		System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">		System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;ProcessDefinition&gt;  list = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">		.createProcessDefinitionQuery() <span class="comment">// 创建一个流程定义查询</span></span><br><span class="line">		<span class="comment">/*指定查询条件,where*/</span></span><br><span class="line"><span class="comment">//		.deploymentId(deploymentId) // 使用部署对象ID查询</span></span><br><span class="line"><span class="comment">//		.processDefinitionId(processDefinitionId) // 使用流程定义ID查询</span></span><br><span class="line"><span class="comment">//		.processDefinitionKey(processDefinitionKey) //使用流程定义的key查询</span></span><br><span class="line"><span class="comment">//		.processDefinitionNameLike(processDefinitionName) // 使用流程定义的名称模糊查询</span></span><br><span class="line">		<span class="comment">/*排序*/</span></span><br><span class="line">		<span class="comment">/*返回结果集*/</span></span><br><span class="line">		.orderByProcessDefinitionVersion().asc() <span class="comment">// 按照版本的升序排列</span></span><br><span class="line"><span class="comment">//		.orderByProcessDefinitionName().desc() // 按照流程定义的名称降序排列</span></span><br><span class="line">		.list();<span class="comment">// 返回集合列表，封装流程定义</span></span><br><span class="line"><span class="comment">//		.singleResult() // 返回唯一结果集</span></span><br><span class="line"><span class="comment">//		.count() // 返回结果集数量</span></span><br><span class="line"><span class="comment">//		.listPage(firstResult,maxResult);</span></span><br><span class="line">		<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ProcessDefinition pd:list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID:"</span>+pd.getId()); <span class="comment">// 流程定义的key版本+:+随机生成数</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的名称:"</span>+pd.getName()); <span class="comment">// 对应helloworld.bpmn文件中的name属性值</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的key:"</span>+pd.getKey());  <span class="comment">// 对应helloworld.bpmn文件中的id属性值</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的版本:"</span>+pd.getVersion()); <span class="comment">// 当流程定义中的key相同，版本升级，默认版本为1</span></span><br><span class="line">				System.out.println(<span class="string">"资源名称bpmn文件:"</span>+pd.getResourceName()); </span><br><span class="line">				System.out.println(<span class="string">"资源名称png文件:"</span>+pd.getDiagramResourceName());</span><br><span class="line">				System.out.println(<span class="string">"部署对象的ID:"</span>+pd.getDeploymentId());</span><br><span class="line">				System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteProcessDefintion</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用部署ID，完成删除</span></span><br><span class="line">		String deploymentId = <span class="string">"601"</span>;</span><br><span class="line">		<span class="comment">/* 不带级联删除</span></span><br><span class="line"><span class="comment">		 * 只能删除没有启动的流程，如果流程启动就会抛出异常</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//processEngine.getRepositoryService().deleteDeployment(deploymentId);</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 级联删除，不管流程是否启动，都可以删除</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		processEngine.getRepositoryService().deleteDeployment(deploymentId,<span class="keyword">true</span>);</span><br><span class="line">		System.out.println(<span class="string">"删除成功！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查看流程图</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">viewPic</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">/*将生成的图片放到文件夹下*/</span></span><br><span class="line">		String deploymentId = <span class="string">"801"</span>;</span><br><span class="line">		<span class="comment">// 获取图片资源名称</span></span><br><span class="line">		List&lt;String&gt; list = processEngine.getRepositoryService().getDeploymentResourceNames(deploymentId);</span><br><span class="line">		String resourceName = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(String name:list) &#123;</span><br><span class="line">				<span class="keyword">if</span>(name.indexOf(<span class="string">".png"</span>)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">					resourceName = name;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		InputStream in = processEngine.getRepositoryService()</span><br><span class="line">		.getResourceAsStream(deploymentId, resourceName);</span><br><span class="line">		<span class="comment">//将图片生成到D盘的目录</span></span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:/"</span>+resourceName);</span><br><span class="line">		<span class="comment">//将输入流的图片图片写到D盘下</span></span><br><span class="line">		FileUtils.copyInputStreamToFile(in, file);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 附加功能:查询最新版本的流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLastVersionProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;ProcessDefinition&gt; list = processEngine.getRepositoryService()</span><br><span class="line">		.createProcessDefinitionQuery()</span><br><span class="line">		.orderByProcessDefinitionVersion().asc() <span class="comment">// 按照流程定义的版本升序排列</span></span><br><span class="line">		.list();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * map 集合的key为流程定义的key</span></span><br><span class="line"><span class="comment">		 * map 集合的value为流程定义的对象</span></span><br><span class="line"><span class="comment">		 * 当map集合的key相同时，后一次的值将代替前一次的值</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		Map&lt;String,ProcessDefinition&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String,ProcessDefinition&gt;();</span><br><span class="line">		<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ProcessDefinition pd:list) &#123;</span><br><span class="line">				map.put(pd.getKey(), pd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;ProcessDefinition&gt; pdList = <span class="keyword">new</span> ArrayList&lt;ProcessDefinition&gt;(map.values());</span><br><span class="line">		<span class="keyword">if</span>(pdList!=<span class="keyword">null</span> &amp;&amp; pdList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ProcessDefinition pd:pdList) &#123;</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID:"</span>+pd.getId()); <span class="comment">// 流程定义的key版本+:+随机生成数</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的名称:"</span>+pd.getName()); <span class="comment">// 对应helloworld.bpmn文件中的name属性值</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的key:"</span>+pd.getKey());  <span class="comment">// 对应helloworld.bpmn文件中的id属性值</span></span><br><span class="line">				System.out.println(<span class="string">"流程定义的版本:"</span>+pd.getVersion()); <span class="comment">// 当流程定义中的key相同，版本升级，默认版本为1</span></span><br><span class="line">				System.out.println(<span class="string">"资源名称bpmn文件:"</span>+pd.getResourceName()); </span><br><span class="line">				System.out.println(<span class="string">"资源名称png文件:"</span>+pd.getDiagramResourceName());</span><br><span class="line">				System.out.println(<span class="string">"部署对象的ID:"</span>+pd.getDeploymentId());</span><br><span class="line">				System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 附加功能: 删除流程定义(删除key相同的所有不同版本的流程定义)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteProcessDefinitionByKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String processDefinitionKey = <span class="string">"helloworld"</span>;</span><br><span class="line">		<span class="comment">// 先使用流程定义的key查询流程定义，查询出所有的版本</span></span><br><span class="line">		 List&lt;ProcessDefinition&gt; list = processEngine.getRepositoryService().createProcessDefinitionQuery()</span><br><span class="line">		.processDefinitionKey(processDefinitionKey) <span class="comment">//使用流程定义的key查询</span></span><br><span class="line">		.list(); </span><br><span class="line">		 <span class="comment">// 遍历，获取每个流程定义的部署ID	 </span></span><br><span class="line">		 <span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			 <span class="keyword">for</span>(ProcessDefinition pd:list) &#123;</span><br><span class="line">				 String deploymentId = pd.getDeploymentId();</span><br><span class="line">				 processEngine.getRepositoryService().deleteDeployment(deploymentId, <span class="keyword">true</span>);</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--接收活动</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E6%8E%A5%E6%94%B6%E6%B4%BB%E5%8A%A8.html</url>
    <content><![CDATA[<p>学习完排他网关和并行网关后，本章我们来学习接收任务活动(receiveTask)。</p>
<blockquote>
<p>接收任务是一个简单任务，它会等待对应消息的到达。 当前，官方只实现了这个任务的java语义。 当流程到达接收任务，流程状态会保存到数据库中，但是数据不会保存在任务相关的表中。</p>
<p>在任务创建后，意味着<strong>流程会进入等待状态</strong>， 直到引擎接收了一个<strong>特定的消息</strong>， 这会触发流程穿过接收任务继续执行。</p>
</blockquote>
<p>从上面的定义可知，在任务创建后，流程会进入等待状态，直到引擎接收了一个<strong>特定的消息</strong>， 触发流程继续执行。</p>
<p>下面，我们还是先创建一个新包<strong>cn.demo.receivetask</strong>，并创建新类<strong>ReceiveTaskTest</strong>以及流程文件<strong>receiveTask.bpmn</strong>，然后，我们来定义一个新流程。</p>
<h3 id="定义流程"><a href="#定义流程" class="headerlink" title="定义流程"></a>定义流程</h3><p>接下来，我们来定义一个新流程。该流程每天汇总当日的销售额，并给老总发短信。</p>
<ol>
<li>先创建一个开始节点</li>
<li>从Task工具箱中找到<strong>Receive Task</strong>，创建一个新的接收任务，设置其Name的值为<strong>汇总当日销售额</strong></li>
<li>再次从Task工具箱中找到<strong>Receive Task</strong>，创建新的接收任务，设置其Name的值为<strong>给老总发短信</strong></li>
<li>点击空白处，设置流程的Id值为<strong>receiveTask</strong>，设置流程的Name值为<strong>receiveTaskProcess</strong></li>
<li>创建一个结束节点</li>
</ol>
<p>在定义流程时，注意到，<strong>Receive Task</strong>没有办理人，即Assigee字段，我们不能调用<strong>taskService</strong>来完成任务，补习调用<strong>runTimeService</strong>的方法推动流程执行。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E6%8E%A5%E6%94%B6%E6%B4%BB%E5%8A%A8/%E6%8E%A5%E6%94%B6%E4%BB%BB%E5%8A%A1.png" alt="接收活动"></p>
<h3 id="部署启动运行流程"><a href="#部署启动运行流程" class="headerlink" title="部署启动运行流程"></a>部署启动运行流程</h3><h4 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h4><p>和前面一样，我们先部署流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 部署流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		InputStream inputStreamBpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"receiveTask.bpmn"</span>);</span><br><span class="line">		InputStream inputStreamPng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"receiveTask.png"</span>);</span><br><span class="line">		Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">				.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">				.name(<span class="string">"开始活动"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">				.addInputStream(<span class="string">"receiveTask.bpmn"</span>, inputStreamBpmn)</span><br><span class="line">				.addInputStream(<span class="string">"receiveTask.png"</span>,inputStreamPng)</span><br><span class="line">				.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">		System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">		System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出结果</p>
<blockquote>
<p>部署ID: 4901<br>部署名称: 开始活动</p>
</blockquote>
<h4 id="启动运行流程"><a href="#启动运行流程" class="headerlink" title="启动运行流程"></a>启动运行流程</h4><p>部署流程成功之后，我们可以分三步走</p>
<ol>
<li>启动流程实例</li>
<li>由于当流程执行到接收任务后，该流程会进入等待状态，所以，可以使用流程变量设置当日销售额，然后向后执行一步，使得流程继续执行</li>
<li>当流程执行完汇总当日销售额后，我们可以获取该值，再次向后执行一步，结束流程</li>
</ol>
<p>现在，我们来看一下各步骤的代码</p>
<ol>
<li><p>启动流程实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">// 流程定义的key</span></span><br><span class="line">String processDefinitionKey = <span class="string">"receiveTask"</span>;</span><br><span class="line">ProcessInstance processInstance = processEngine.getRuntimeService() </span><br><span class="line">		.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId());</span><br></pre></td></tr></table></figure>
<p>可以看到，该处代码和前面的代码基本是一样的</p>
</li>
<li><p>设置流程变量，向后执行流程</p>
<p>由于接受活动不属于任务的一种，其数据不会出现在任务相关表中，因此，我们使用<strong>runTimeService</strong>执行相关数据的查询、流程变量设置以及向后执行流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用流程变量设置当日销售额，用来传递业务参数*/</span></span><br><span class="line">		<span class="comment">/*查询执行对象id*/</span></span><br><span class="line">		Execution execution1 = processEngine.getRuntimeService()</span><br><span class="line">			.createExecutionQuery() <span class="comment">// 使用流程实例Id查询</span></span><br><span class="line">			.processInstanceId(processInstance.getId())</span><br><span class="line">			<span class="comment">// 当前活动的Id，对应receiveTask.bpmn文件中的活动节点id的属性值</span></span><br><span class="line">			.activityId(<span class="string">"receivetask1"</span>)</span><br><span class="line">			.singleResult();</span><br><span class="line">		processEngine.getRuntimeService()</span><br><span class="line">		.setVariable(execution1.getId(), <span class="string">"汇总当日销售额"</span>, <span class="number">21000</span>);</span><br><span class="line">		<span class="comment">/*向后执行一步，使得流程继续执行*/</span></span><br><span class="line">		processEngine.getRuntimeService()</span><br><span class="line">		.signal(execution1.getId());</span><br></pre></td></tr></table></figure>
<p>在该代码中，我们使用了<strong>runTimeService</strong>的signal方法来向后执行流程，在下一步中，也是如此。</p>
</li>
<li><p>获取流程变量，向后执行流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*从流程变量中获取汇总当日销售额的值*/</span></span><br><span class="line">		<span class="comment">/*查询执行对象id*/</span></span><br><span class="line">		Execution execution2 = processEngine.getRuntimeService()</span><br><span class="line">			.createExecutionQuery() <span class="comment">// 使用流程实例Id查询</span></span><br><span class="line">			.processInstanceId(processInstance.getId())</span><br><span class="line">			<span class="comment">// 当前活动的Id，对应receiveTask.bpmn文件中的活动节点id的属性值</span></span><br><span class="line">			.activityId(<span class="string">"receivetask2"</span>)</span><br><span class="line">			.singleResult();</span><br><span class="line">		Integer value = (Integer)processEngine.getRuntimeService()</span><br><span class="line">				.getVariable(execution2.getId(), <span class="string">"汇总当日销售额"</span>);</span><br><span class="line">		System.out.println(<span class="string">"给老总发送短信，金额是:"</span>+value);</span><br><span class="line">		processEngine.getRuntimeService()</span><br><span class="line">		.signal(execution2.getId());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在，我们来看完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 启动流程实例+设置流程变量+向后执行一步</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 流程定义的key</span></span><br><span class="line">		String processDefinitionKey = <span class="string">"receiveTask"</span>;</span><br><span class="line">		ProcessInstance processInstance = processEngine.getRuntimeService() </span><br><span class="line">				.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">		System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">		System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 	</span><br><span class="line">		<span class="comment">/*使用流程变量设置当日销售额，用来传递业务参数*/</span></span><br><span class="line">		<span class="comment">/*查询执行对象id*/</span></span><br><span class="line">		Execution execution1 = processEngine.getRuntimeService()</span><br><span class="line">			.createExecutionQuery() <span class="comment">// 使用流程实例Id查询</span></span><br><span class="line">			.processInstanceId(processInstance.getId())</span><br><span class="line">			<span class="comment">// 当前活动的Id，对应receiveTask.bpmn文件中的活动节点id的属性值</span></span><br><span class="line">			.activityId(<span class="string">"receivetask1"</span>)</span><br><span class="line">			.singleResult();</span><br><span class="line">		processEngine.getRuntimeService()</span><br><span class="line">		.setVariable(execution1.getId(), <span class="string">"汇总当日销售额"</span>, <span class="number">21000</span>);</span><br><span class="line">		<span class="comment">/*向后执行一步，使得流程继续执行*/</span></span><br><span class="line">		processEngine.getRuntimeService()</span><br><span class="line">		.signal(execution1.getId());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*从流程变量中获取汇总当日销售额的值*/</span></span><br><span class="line">		<span class="comment">/*查询执行对象id*/</span></span><br><span class="line">		Execution execution2 = processEngine.getRuntimeService()</span><br><span class="line">			.createExecutionQuery() <span class="comment">// 使用流程实例Id查询</span></span><br><span class="line">			.processInstanceId(processInstance.getId())</span><br><span class="line">			<span class="comment">// 当前活动的Id，对应receiveTask.bpmn文件中的活动节点id的属性值</span></span><br><span class="line">			.activityId(<span class="string">"receivetask2"</span>)</span><br><span class="line">			.singleResult();</span><br><span class="line">		Integer value = (Integer)processEngine.getRuntimeService()</span><br><span class="line">				.getVariable(execution2.getId(), <span class="string">"汇总当日销售额"</span>);</span><br><span class="line">		System.out.println(<span class="string">"给老总发送短信，金额是:"</span>+value);</span><br><span class="line">		processEngine.getRuntimeService()</span><br><span class="line">		.signal(execution2.getId());		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，得到如下结果</p>
<blockquote>
<p>流程实例ID: 5001<br>流程定义ID: receiveTask:1:4904<br>给老总发送短信，金额是:21000</p>
</blockquote>
<p>这样，这个汇总当日销售额，给老总发短信的流程就结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，我们总结一下：</p>
<ol>
<li>在接收任务创建后，意味着<strong>流程会进入等待状态</strong>， 直到引擎接收了一个<strong>特定的消息</strong>， 再触发流程穿过接收任务继续执行。</li>
<li>接收任务一般适合机器自动完成，但需要耗费一定时间的工作，向后推移流程，可以调用<strong>runtimeService.signal(executionId)</strong>，传递接收执行对象的id</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--流程实例、任务的执行</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C.html</url>
    <content><![CDATA[<p>通过前面几篇文章的学习，我们已经了解了流程定义的部署、查询、删除操作。本篇，我们将学习如何启动流程实例、执行任务。</p>
<p>首先，我们先在项目的<code>src/main/java</code>下新建包<code>cn.demo.processinstance</code>，并创建一个新类<code>ProcessInstanceTest</code>，以便我们学习。在学习新内容之前，我们先部署一个新的流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义(zip文件格式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinitionZip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	InputStream in = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"diagrams/helloworld.zip"</span>);</span><br><span class="line">	ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(in);</span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">			.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">			.name(<span class="string">"流程定义"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">			.addZipInputStream(zipInputStream)</span><br><span class="line">			.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行该代码，输出如下结果</p>
<blockquote>
<p>部署ID: 901<br>部署名称: 流程定义</p>
</blockquote>
<p>这样我们流程定义就部署好了</p>
<h3 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h3><p>通过前面的<strong>HelloWorld</strong>例子，我们知道可以通过调用流程引擎的<strong>runTimeService</strong>的相关方法启动流程实例，现在我们就开始启动流程实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"helloworld"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() <span class="comment">// 与正在执行		   的流程实例和执行对象相关的Service</span></span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); <span class="comment">// 使用流程定义的key启动			实例，key对应helloworld.bpmn文件中Id的属性值,默认是按照最新版本的流程定义启动</span></span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); <span class="comment">// 流程实例Id</span></span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 			<span class="comment">// 流程定义Id																	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，若一切正常，则输出流程实例ID和流程定义ID</p>
<blockquote>
<p>流程实例ID: 1001<br>流程定义ID: helloworld:4:904</p>
</blockquote>
<h4 id="正在执行的执行对象表"><a href="#正在执行的执行对象表" class="headerlink" title="正在执行的执行对象表"></a>正在执行的执行对象表</h4><p>若上一段代码成功执行，则表示流程实例已经启动好了。此时，<strong>act_ru_execution(正在执行的执行对象表)</strong>会新增一条记录。</p>
<p>执行SQL语句<code>select * from act_ru_execution</code>，可以看到已经新增了一条记录</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B1.png" alt="流程实例1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%B5%81%E7%A8%8B2.png" alt="流程实例2"></p>
<p>其中，<strong>ID_</strong>被称为执行对象ID，<strong>PROC_INST_ID_</strong>被称为流程实例ID，由<strong>ACT_ID_</strong>字段的值可知，该流程执行到第一个用户节点-提交申请。显而易见，在该条记录当中，<strong>ID_</strong>和<strong>PROC_INST_ID_</strong>的值是相等的。<strong>但是，需要注意的是，这两个字段的值并不总是相等，相等有条件的</strong>。</p>
<blockquote>
<p> 如果是单例流程(没有分支和聚合)，那么流程实例ID和执行对象ID是相同的。</p>
</blockquote>
<h4 id="流程实例的历史表"><a href="#流程实例的历史表" class="headerlink" title="流程实例的历史表"></a>流程实例的历史表</h4><p>在<strong>activiti</strong>中存在一张流程实例的历史表<strong>act_hi_procinst(流程实例的历史表)</strong></p>
<p>执行SQL语句<code>select * from act_hi_procinst</code>，可以看到一条<strong>PROC_INST_ID_</strong> 为1001的记录，该记录即为与上一张表记录相对应的记录，其<strong>END_TIME_</strong>为空，表明该流程实例尚未结束。</p>
<blockquote>
<p>对于一个流程来说，流程实例只有一个。执行对象可以存在多个(如果存在分支和聚合)</p>
</blockquote>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E8%A1%A81.png" alt="流程实例历史表1"><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E8%A1%A82.png" alt="流程实例的历史表2"></p>
<h4 id="正在执行的任务表"><a href="#正在执行的任务表" class="headerlink" title="正在执行的任务表"></a>正在执行的任务表</h4><p>除了流程实例表，activiti还存在一张<strong>act_ru_task(正在执行的任务表)</strong>，该表用来记录该流程实例正在执行的任务。</p>
<p>执行SQL语句<code>select * from act_ru_task</code>，可以看到，该表存在一条记录，其任务所属人是张三。我们查询任个人任务时所依赖的就是这张表。<strong>需要注意的是，只有当节点为任务节点类型的时候，该表中才会存在数据</strong></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%A1%A81.png" alt="正在执行的任务表1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%A1%A82.png" alt="正在执行的任务表2"></p>
<h4 id="历史任务表"><a href="#历史任务表" class="headerlink" title="历史任务表"></a>历史任务表</h4><p>相对地，对应于<strong>act_hi_taskinst(历史任务表)</strong>，<strong>activiti</strong>存在一张历史任务表<strong>act_hi_taskinst(历史任务表)</strong></p>
<p>执行SQL语句<code>select * from act_hi_taskinst</code>，结果如下，和<strong>act_hi_taskinst(历史任务表)</strong>一样，该表也只有当节点为任务节点类型的时候，才会存在数据。</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%A1%A81.png" alt="历史任务表1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%A1%A82.png" alt="历史任务2"></p>
<p>可以看到，<strong>ID_</strong>为1004的记录，其字段<strong>END_TIME_</strong>为空，表明该任务尚未结束，正在执行。</p>
<h4 id="所有活动节点的历史表"><a href="#所有活动节点的历史表" class="headerlink" title="所有活动节点的历史表"></a>所有活动节点的历史表</h4><p>显而易见，无论是<strong>act_ru_task(正在执行的任务表)</strong>还是<strong>act_hi_taskinst(历史任务表)</strong>，其存储的都是任务节点的数据，这时，我们可能需要一张存储所有活动节点历史数据的表。<strong>activiti</strong>为我们提供了这样一张表-<strong>act_hi_actinst(所有活动节点的历史表)</strong>来满足我们的要求。</p>
<p>执行SQL语句<code>select * from act_hi_actinst</code>，可以看到表中存在着该流程实例的<strong>startEvent1(开始节点)</strong>和<strong>usertask1(任务节点1)</strong>的数据。其中，开始节点的<strong>END_TIME_</strong>字段值不为空，表示其已经结束，此时执行到<strong>userTask1</strong>，该任务没有结束，其<strong>END_TIME_</strong>字段是空值。</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%86%E5%8F%B2%E8%A1%A81.png" alt="所有节点的历史表1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%86%E5%8F%B2%E8%A1%A82.png" alt="所有节点的历史表2"></p>
<h3 id="查询和完成个人任务"><a href="#查询和完成个人任务" class="headerlink" title="查询和完成个人任务"></a>查询和完成个人任务</h3><p>查看流程图，我们可以看到存在三个用户任务，现在，我们依次查询并完成它，并观察各表数据变化。</p>
<h4 id="查询和完成张三的任务"><a href="#查询和完成张三的任务" class="headerlink" title="查询和完成张三的任务"></a>查询和完成张三的任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String assignee = <span class="string">"张三"</span>;</span><br><span class="line">	List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">			.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">			<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">			.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">			<span class="comment">// .taskCandidateUser(arg0) 组任务的办理人</span></span><br><span class="line">			<span class="comment">// .processDefinitionId(arg0)  流程定义id</span></span><br><span class="line">			<span class="comment">// .processInstanceId(arg0) // 流程实例id</span></span><br><span class="line">			<span class="comment">// .executionId(arg0) // 执行对象id</span></span><br><span class="line">			<span class="comment">/*排序*/</span></span><br><span class="line">			.orderByTaskCreateTime().asc()</span><br><span class="line">			<span class="comment">/*返回结果集*/</span></span><br><span class="line">			<span class="comment">// .singleResult() // 返回唯一结果集</span></span><br><span class="line">			<span class="comment">// .count() // 返回结果集数量</span></span><br><span class="line">			<span class="comment">// .listPage(arg0, arg1) // 分页查询结果集</span></span><br><span class="line">			.list();</span><br><span class="line">	<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">			System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">			System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">			System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">			System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">			System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">			System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于现在是在<strong>usertask1</strong>，我们查询张三的个人任务，其结果如下</p>
<blockquote>
<p>任务ID: 1004<br>任务名称: 提交申请<br>任务的创建时间: Tue Sep 04 22:49:25 CST 2018<br>任务的办理人: 张三<br>流程实例ID: 1001<br>执行对象ID: 1001<br>流程定义ID: helloworld:4:904</p>
</blockquote>
<p>在查询到任务之后，我们可以通过任务ID完成个人任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"1004"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<blockquote>
<p>完成任务：任务Id：1004</p>
</blockquote>
<p>完成张三的个人任务后，我们来查询各表数据。</p>
<p>首先，我们执行<code>select * from act_ru_execution</code>，查询<strong>正在执行的执行对象表</strong></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E8%A1%A83.png" alt="正在执行的执行对象表3"></p>
<p>对比上文，该记录的ACT_ID发生了改变，由<strong>usertask1</strong>变为了<strong>usertask2</strong>，此时，流程走到了下一个用户任务。</p>
<p>其次，我们执行<code>select * from act_hi_procinst</code>，查询<strong>流程实例的历史表</strong></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E5%8E%86%E5%8F%B2%E8%A1%A83.png" alt="流程实例的历史表3"></p>
<p>由于一个流程只有一个流程实例，其始终只有一条记录，该流程实例还在执行，因此<strong>END_TIME_</strong>字段值仍然为空</p>
<p>接着，我们执行<code>select * from act_ru_task</code>，查询<strong>正在执行的任务表</strong></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A13.png" alt="正在执行的任务3"></p>
<p>此时，该记录的<strong>ID_</strong>发生变化，其<strong>NAME_</strong>字段也发生变化，<strong>ASSIGNEE</strong>也从<strong>张三</strong>变成了<strong>李四</strong> ，<strong>TASK_DEF_KEY_</strong>的值为<strong>usertask2</strong>。所以，此时我们可以查询到李四的个人任务，却查询不到张三的个人任务。</p>
<p>然后，我们执行<code>select * from act_hi_taskinst</code>，查询<strong>历史任务表</strong></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%A1%A83.png" alt="历史任务表3"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%A1%A84.png" alt="历史任务表4"></p>
<p>可以看到<strong>ID_</strong>为1004的记录其<strong>END_TIME_</strong>不为空，已经完成了任务，而<strong>ID_</strong>为1102，<strong>TASK_DEF_KEY_</strong>的值为<strong>usertask2</strong>的李四任务还没有完成，其<strong>END_TIME_</strong>为空</p>
<p>最后，我们执行<code>select * from act_hi_actinst</code>，查询<strong>所有活动节点的历史表</strong></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%86%E5%8F%B2%E8%A1%A83.png" alt="所有节点的历史表3"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%86%E5%8F%B2%E8%A1%A84.png" alt="所有活动节点的历史表4"></p>
<p>可以看到，<strong>TASK_ID_</strong>为1102的记录其<strong>END_TIME_</strong>字段值为空，表示任务还未完成，而这正是李四的个人任务</p>
<h4 id="查询和完成李四的任务"><a href="#查询和完成李四的任务" class="headerlink" title="查询和完成李四的任务"></a>查询和完成李四的任务</h4><p>通过查询<strong>act_ru_task(正在执行的任务表)</strong>，我们知道，流程已经进行走到李四这了，我们先执行查询个人任务代码，将<strong>张三</strong>换成<strong>李四</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String assignee = <span class="string">"李四"</span>;</span><br><span class="line">	List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">			.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">			<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">			.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">			<span class="comment">// .taskCandidateUser(arg0) 组任务的办理人</span></span><br><span class="line">			<span class="comment">// .processDefinitionId(arg0)  流程定义id</span></span><br><span class="line">			<span class="comment">// .processInstanceId(arg0) // 流程实例id</span></span><br><span class="line">			<span class="comment">// .executionId(arg0) // 执行对象id</span></span><br><span class="line">			<span class="comment">/*排序*/</span></span><br><span class="line">			.orderByTaskCreateTime().asc()</span><br><span class="line">			<span class="comment">/*返回结果集*/</span></span><br><span class="line">			<span class="comment">// .singleResult() // 返回唯一结果集</span></span><br><span class="line">			<span class="comment">// .count() // 返回结果集数量</span></span><br><span class="line">			<span class="comment">// .listPage(arg0, arg1) // 分页查询结果集</span></span><br><span class="line">			.list();</span><br><span class="line">	<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">			System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">			System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">			System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">			System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">			System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">			System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，可以看到如下结果</p>
<blockquote>
<p>任务ID: 1102<br>任务名称: 审批【部门经理】<br>任务的创建时间: Wed Sep 05 23:48:17 CST 2018<br>任务的办理人: 李四<br>流程实例ID: 1001<br>执行对象ID: 1001<br>流程定义ID: helloworld:4:904</p>
</blockquote>
<p>接下来，我们使用任务ID完成李四的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"1102"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<blockquote>
<p>完成任务：任务Id：1102</p>
</blockquote>
<p>现在，我们再次看看上面提到的那几张表的表数据</p>
<p>首先是<strong>act_ru_execution(正在执行的执行对象表)</strong>，此时其<strong>ACT_ID_</strong>的值为<strong>usertask3</strong>，流程已经进行到王五这了</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E6%9D%8E%E5%9B%9B%E4%BB%BB%E5%8A%A1%E5%90%8E%E7%9A%84%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E8%A1%A8.png" alt="执行完李四任务的正在执行的执行对象表"></p>
<p>其次，我们看看<strong>act_hi_procinst(流程实例的历史表)</strong>，其没有任何变化</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E5%8E%86%E5%8F%B2%E8%A1%A83.png" alt="执行完李四任务的流程实例的历史表"></p>
<p>接着是<strong>act_ru_task(正在执行的任务表)</strong>，其<strong>TASK_DEF_KEY_</strong>的值为<strong>usertask3</strong>，这也表明了流程已经进行到王五这了</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%9D%8E%E5%9B%9B%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%A1%A81.png" alt="执行完李四任务的正在执行的任务表1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%9D%8E%E5%9B%9B%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%A1%A82.png" alt="执行完李四任务的正在执行的任务表2"></p>
<p>然后，我们再看<strong>act_hi_taskinst(历史任务表)</strong>，王五的这条记录</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%9D%8E%E5%9B%9B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%A1%A81.png" alt="执行完李四任务的历史任务表1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%9D%8E%E5%9B%9B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%A1%A82.png" alt="执行完李四任务的历史任务表2"></p>
<p>最后，我们看<strong>act_hi_actinst(所有活动节点的历史表)</strong>，王五的这条<strong>END_TIME_</strong>这条记录的字段值为空，表明王五的任务还未完成。</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%9D%8E%E5%9B%9B%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%86%E5%8F%B2%E8%A1%A81.png" alt="执行完李四任务的所有活动节点的历史表"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%9D%8E%E5%9B%9B%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%86%E5%8F%B2%E8%A1%A82.png" alt="执行完李四任务的所有活动节点的历史表2"></p>
<p>为此，我们查询并完成王五的任务，走完这个流程</p>
<h4 id="查询和完成王五的任务"><a href="#查询和完成王五的任务" class="headerlink" title="查询和完成王五的任务"></a>查询和完成王五的任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String assignee = <span class="string">"王五"</span>;</span><br><span class="line">	List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">			.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">			<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">			.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">			<span class="comment">// .taskCandidateUser(arg0) 组任务的办理人</span></span><br><span class="line">			<span class="comment">// .processDefinitionId(arg0)  流程定义id</span></span><br><span class="line">			<span class="comment">// .processInstanceId(arg0) // 流程实例id</span></span><br><span class="line">			<span class="comment">// .executionId(arg0) // 执行对象id</span></span><br><span class="line">			<span class="comment">/*排序*/</span></span><br><span class="line">			.orderByTaskCreateTime().asc()</span><br><span class="line">			<span class="comment">/*返回结果集*/</span></span><br><span class="line">			<span class="comment">// .singleResult() // 返回唯一结果集</span></span><br><span class="line">			<span class="comment">// .count() // 返回结果集数量</span></span><br><span class="line">			<span class="comment">// .listPage(arg0, arg1) // 分页查询结果集</span></span><br><span class="line">			.list();</span><br><span class="line">	<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">			System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">			System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">			System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">			System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">			System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">			System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，得到如下结果</p>
<blockquote>
<p>任务ID: 1202<br>任务名称: 审批【总经理】<br>任务的创建时间: Thu Sep 06 19:59:40 CST 2018<br>任务的办理人: 王五<br>流程实例ID: 1001<br>执行对象ID: 1001<br>流程定义ID: helloworld:4:904</p>
</blockquote>
<p>接下来，完成王五的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"1202"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，结果如下</p>
<blockquote>
<p>完成任务：任务Id：1202</p>
</blockquote>
<p>现在，我们再查询一下这些表的数据</p>
<p>首先，先看<strong>act_ru_execution(正在执行的执行对象表)</strong> </p>
<p>显而易见，由于执行完王五的任务之后，流程已经结束了，因此该表数据为空</p>
<p>再看，<strong>act_hi_procinst(流程实例的历史表)</strong> ，<strong>ID_</strong>为<strong>1001</strong>的这条记录的<strong>END_TIME_</strong>值不为空,表明该流程实例已经结束。</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E5%AE%8C%E7%8E%8B%E4%BA%94%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E8%A1%A81.png" alt="执行完王五任务的流程实例历史表1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E6%89%A7%E8%A1%8C%E5%AE%8C%E7%8E%8B%E4%BA%94%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E8%A1%A82.png" alt="执行完王五任务的流程实例历史表2"></p>
<p>接着看<strong>act_ru_task(正在执行的任务表)</strong> </p>
<p>由于流程实例已经结束，已经没有任务在执行，所以该表数据为空</p>
<p>然后，我们看一下<strong>act_hi_taskinst(历史任务表)</strong>，属于王五的记录其<strong>END_TIME_</strong>不为空，表明王五完成了任务</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%AE%8C%E6%88%90%E7%8E%8B%E4%BA%94%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%A1%A81.png" alt="执行完王五任务的历史任务表1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%AE%8C%E6%88%90%E7%8E%8B%E4%BA%94%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%A1%A82.png" alt="执行完王五任务的历史任务表2"></p>
<p>最后看一下<strong>act_hi_actinst(所有活动节点的历史表)</strong>，所有属于该流程实例的<strong>END_TIME_</strong>值不为空，所有活动节点都已经结束了。<img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%AE%8C%E6%88%90%E7%8E%8B%E4%BA%94%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E8%A1%A81.png" alt="完成王五任务的所有历史活动节点表1"></p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%AE%8C%E6%88%90%E7%8E%8B%E4%BA%94%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E6%B4%BB%E5%8A%A8%E8%8A%82%E7%82%B9%E8%A1%A82.png" alt="完成王五任务的所有历史活动节点表2"></p>
<p>至此，该流程已经完全结束了。</p>
<h3 id="查询流程状态"><a href="#查询流程状态" class="headerlink" title="查询流程状态"></a>查询流程状态</h3><p>有些时候，我们需要判断流程正在执行还是已经结束，则可以通过流程实例ID，调用<strong>runTimeService</strong>服务方法创建流程实例查询来完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询流程状态(判断流程正在执行还是结束)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isProcessEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String processInstanceId = <span class="string">"1001"</span>;</span><br><span class="line">	ProcessInstance singleResult = processEngine.getRuntimeService() <span class="comment">// 表示正在执行的流程实例和执行对象</span></span><br><span class="line">	.createProcessInstanceQuery() <span class="comment">// 创建流程实例查询</span></span><br><span class="line">	.processInstanceId(processInstanceId) <span class="comment">// 使用流程实例ID查询</span></span><br><span class="line">	.singleResult();</span><br><span class="line">	<span class="keyword">if</span>(singleResult==<span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"流程实例已经结束"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"流程没有结束"</span>);</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，结果如下</p>
<blockquote>
<p>流程实例已经结束</p>
</blockquote>
<h3 id="查询历史任务"><a href="#查询历史任务" class="headerlink" title="查询历史任务"></a>查询历史任务</h3><p>当流程结束以后，我们可以查询历史任务，查询历史任务需要用到<strong>historyService</strong>服务创建历史任务实例查询实现，其代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询历史任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskAssignee = <span class="string">"张三"</span>;</span><br><span class="line">		List&lt;HistoricTaskInstance&gt; list = processEngine.getHistoryService() </span><br><span class="line">				<span class="comment">// 与历史数据(历史表相关的数据)</span></span><br><span class="line">				.createHistoricTaskInstanceQuery() <span class="comment">// 创建历史的任务实例查询</span></span><br><span class="line">				.taskAssignee(taskAssignee) <span class="comment">// 指定历史任务的办理人</span></span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (HistoricTaskInstance his : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"历史任务id:"</span> + his.getId());</span><br><span class="line">				System.out.println(<span class="string">"历史任务名称:"</span> + his.getName());</span><br><span class="line">				System.out.println(<span class="string">"流程实例id:"</span> + his.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"开始时间:"</span> + his.getStartTime());</span><br><span class="line">				System.out.println(<span class="string">"结束时间:"</span> + his.getEndTime());</span><br><span class="line">				System.out.println(<span class="string">"持续时间:"</span> + his.getDurationInMillis());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<blockquote>
<p>历史任务id:1004<br>历史任务名称:提交申请<br>流程实例id:1001<br>开始时间:Tue Sep 04 22:49:25 CST 2018<br>结束时间:Wed Sep 05 23:48:17 CST 2018<br>持续时间:89932060</p>
<p>历史任务id:104<br>历史任务名称:提交申请<br>流程实例id:101<br>开始时间:Mon Jul 02 23:21:44 CST 2018<br>结束时间:Mon Jul 09 20:05:57 CST 2018<br>持续时间:593053592</p>
</blockquote>
<h3 id="查询历史流程实例"><a href="#查询历史流程实例" class="headerlink" title="查询历史流程实例"></a>查询历史流程实例</h3><p>使用<strong>historyService</strong>不仅可以查询历史任务，还可以查询历史流程实例,并且对于一个流程来说，这个结果是惟一的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询历史流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String processInstanceId = <span class="string">"1001"</span>;</span><br><span class="line">	HistoricProcessInstance singleResult = processEngine.getHistoryService() </span><br><span class="line">	<span class="comment">// 与历史数据(历史表相关的数据)</span></span><br><span class="line">	.createHistoricProcessInstanceQuery() <span class="comment">// 创建历史流程实例查询</span></span><br><span class="line">	.processInstanceId(processInstanceId) <span class="comment">// 使用流程实例id</span></span><br><span class="line">	.singleResult();	</span><br><span class="line">	System.out.println(<span class="string">"流程实例id:"</span>+singleResult.getId());</span><br><span class="line">	System.out.println(<span class="string">"流程定义id:"</span>+singleResult.getProcessDefinitionId());</span><br><span class="line">	System.out.println(<span class="string">"开始时间:"</span>+singleResult.getStartTime());</span><br><span class="line">	System.out.println(<span class="string">"结束时间:"</span>+singleResult.getEndTime());</span><br><span class="line">	System.out.println(<span class="string">"持续时间:"</span>+singleResult.getDurationInMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，结果如下</p>
<blockquote>
<p>流程实例id:1001<br>流程定义id:helloworld:4:904<br>开始时间:Tue Sep 04 22:49:25 CST 2018<br>结束时间:Thu Sep 06 21:06:56 CST 2018<br>持续时间:166651989</p>
</blockquote>
<h3 id="主要内容总结"><a href="#主要内容总结" class="headerlink" title="主要内容总结"></a>主要内容总结</h3><h4 id="执行对象和流程实例基本概念归纳"><a href="#执行对象和流程实例基本概念归纳" class="headerlink" title="执行对象和流程实例基本概念归纳"></a>执行对象和流程实例基本概念归纳</h4><p><strong>ProcessInstance(流程实例)</strong></p>
<p>代表流程定义的执行实例 ,一个流程实例包括了所有的运行节点。我们可以利用这个对象来了解当前流程实例的进度等信息。</p>
<blockquote>
<p> <strong>流程实例表示一个流程从开始到结束的最大的流程分支</strong>，即一个流程中流程实例只有一个。 </p>
</blockquote>
<p><strong>Execution(执行对象)</strong></p>
<p><strong>Activiti</strong>用这个对象去描述流程执行的每一个节点。在没有并发的情况下，<strong>Execution</strong>就是<strong>ProcessInstance</strong>。</p>
<blockquote>
<p> <strong>流程按照流程定义的规则执行一次的过程</strong>，就可以表示执行对象Execution。</p>
</blockquote>
<h4 id="流程实例源码分析"><a href="#流程实例源码分析" class="headerlink" title="流程实例源码分析"></a>流程实例源码分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">package org.activiti.engine.runtime;</span></span><br><span class="line"><span class="comment">import java.util.Map;</span></span><br><span class="line"><span class="comment">import org.activiti.engine.repository.ProcessDefinition;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/** Represents one execution of a  &#123;@link ProcessDefinition&#125;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author Tom Baeyens</span></span><br><span class="line"><span class="comment"> * @author Joram Barrez</span></span><br><span class="line"><span class="comment"> * @author Daniel Meyer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessInstance</span> <span class="keyword">extends</span> <span class="title">Execution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The id of the process definition of the process instance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getProcessDefinitionId</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The business key of this process instance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getBusinessKey</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * returns true if the process instance is suspended</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isSuspended</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Returns the process variables if requested in the process instance query */</span></span><br><span class="line">  <span class="function">Map&lt;String, Object&gt; <span class="title">getProcessVariables</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源代码中可以看出<strong>ProcessInstance</strong>就是<strong>Execution</strong>。但在现实意义上有所区别</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%8D%95%E7%BA%BF%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1.png" alt="单线流程中的流程实例和执行对象"></p>
<p>在单线流程中，如上图的贷款流程，<strong>ProcessInstance</strong>与<strong>Execution</strong>是一致的。 </p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E4%BE%8B/%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1.png" alt="多线流程中的流程实例和执行对象"></p>
<p>这个例子有一个特点:wire-money(汇钱)和archive(存档)是并发执行的。这个时候，总线路代表<strong>ProcessInstance</strong>，而分线路中每个活动代表<strong>Execution</strong>。 </p>
<p>因此，</p>
<ol>
<li><strong>一个流程中，执行对象可以存在多个，但是流程实例只能有一个。</strong> </li>
<li><strong>当流程按照规则只执行一次的时候，那么流程实例就是执行对象。</strong></li>
</ol>
<h4 id="流程实例和执行对象相关表"><a href="#流程实例和执行对象相关表" class="headerlink" title="流程实例和执行对象相关表"></a>流程实例和执行对象相关表</h4><p><strong>Execution(执行对象)</strong></p>
<p>对应的表：<br>act_ru_execution： 正在执行的信息<br>act_hi_procinst：已经执行完的历史流程实例信息<br>act_hi_actinst：存放历史所有完成的活动</p>
<p><strong>ProcessInstance(流程实例)</strong> </p>
<ol>
<li>如果是单例流程，执行对象ID就是流程实例ID 。</li>
<li>如果一个流程有分支和聚合，那么执行对象ID和流程实例ID就不相同。</li>
<li>一个流程中，流程实例只有1个，执行对象可以存在多个。</li>
</ol>
<p><strong>Task(任务)</strong></p>
<p>对应的表：<br>act_ru_task：正在执行的任务信息<br>act_hi_taskinst：已经执行完的历史任务信息</p>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--流程实例开始结束</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E7%BB%93%E6%9D%9F.html</url>
    <content><![CDATA[<p>本章学习流程实例的开始和结束节点，通过学习该内容，了解如何判断流程是否结束。</p>
<p>为了了解如何判断流程是否结束，我们新建包<strong>cn.demo.start</strong>，创建新类<strong>StartTest</strong>，并新建<strong>start.bpmn</strong>流程图文件定义新的流程。</p>
<p>此次，流程比较简单，只有两个节点：开始节点和结束节点</p>
<ol>
<li>创建开始节点</li>
<li>创建结束节点</li>
<li>使用连线连接开始和结束节点，并设置其Name的值为<strong>开始活动</strong></li>
<li>点击空白处，设置Id的值为<strong>start</strong>，Name的值为<strong>startProcess</strong></li>
</ol>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F/%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F.png" alt="开始和结束"></p>
<p>接下来，我们就来部署流程定义以及启动流程实例</p>
<h3 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	InputStream inputStreamBpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"start.bpmn"</span>);</span><br><span class="line">	InputStream inputStreamPng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"start.png"</span>);</span><br><span class="line">	Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">			.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">			.name(<span class="string">"开始活动"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">			.addInputStream(<span class="string">"start.bpmn"</span>, inputStreamBpmn)</span><br><span class="line">			.addInputStream(<span class="string">"start.png"</span>,inputStreamPng)</span><br><span class="line">			.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">	System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">	System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，部署流程定义成功，得到如下结果</p>
<blockquote>
<p>部署ID: 4701<br>部署名称: 开始活动</p>
</blockquote>
<h3 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h3><p>可以预见，因为该流程只有开始和结束节点，一旦启动流程实例，很快地，流程就会结束。</p>
<p>若我们需要判断流程实例是否结束，可以通过<strong>runtimeService</strong>查询流程实例对象，如果对象为<strong>null</strong>，则表示流程已经结束。</p>
<p>若我们想要获取流程实例的信息，则需要从历史表中查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 启动流程实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 流程定义的key</span></span><br><span class="line">		String processDefinitionKey = <span class="string">"start"</span>;</span><br><span class="line">		ProcessInstance processInstance = processEngine.getRuntimeService() </span><br><span class="line">				.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">		System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">		System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 	</span><br><span class="line">		<span class="comment">// 判断流程是否结束</span></span><br><span class="line">		ProcessInstance pi = processEngine.getRuntimeService()</span><br><span class="line">		.createProcessInstanceQuery()</span><br><span class="line">		.processInstanceId(processInstance.getId()).singleResult();</span><br><span class="line">		<span class="comment">// 说明流程实例结束</span></span><br><span class="line">		<span class="keyword">if</span>(pi==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">/*查询历史，获取流程实例相关信息*/</span></span><br><span class="line">			HistoricProcessInstance historicProcessInstance = processEngine.getHistoryService().createHistoricProcessInstanceQuery()</span><br><span class="line">			<span class="comment">// 使用流程实例Id查询</span></span><br><span class="line">			.processInstanceId(processInstance.getId())</span><br><span class="line">			.singleResult();</span><br><span class="line">			System.out.println(historicProcessInstance.getId()+ <span class="string">" "</span></span><br><span class="line">					+historicProcessInstance.getStartTime()+<span class="string">" "</span></span><br><span class="line">					+historicProcessInstance.getEndTime()+<span class="string">" "</span></span><br><span class="line">					+historicProcessInstance.getDurationInMillis());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>若启动流程实例成功，输出如下结果</p>
<blockquote>
<p>流程实例ID: 4801<br>流程定义ID: start:1:4704<br>4801 Mon Oct 15 23:33:37 CST 2018 Mon Oct 15 23:33:37 CST 2018 55</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在，我们可以总结一下了</p>
<ol>
<li>结束节点没有出口</li>
<li>其他节点有一个或多个出口：<ul>
<li>如果有一个出口，则代表是一个<strong>单线流程</strong></li>
<li>如果有多个出口，则代表是开启<strong>并发流程</strong></li>
</ul>
</li>
<li>可以通过<strong>runTimeService</strong>查询流程实例对象，若流程实例对象为空，则表示该流程实例已经结束</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--用户角色组</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E7%BB%84.html</url>
    <content><![CDATA[<p>本章是Activiti的最后一章，我们开始学习Activiti提供的用户角色组。通过它，流程能够根据用户角色选择办理人完成用户任务。为了便于学习，我们新建包<strong>cn.demo.groupuser</strong>，类<strong>TaskTest</strong>，流程图文件<strong>task.bpmn</strong>。</p>
<h3 id="定义审批流程"><a href="#定义审批流程" class="headerlink" title="定义审批流程"></a>定义审批流程</h3><p>和前面一样，我们定义一个<strong>审批</strong>流程，该<strong>审批</strong>用户任务节点设置Candidate-groups的值为<strong>部门经理</strong>，当流程执行到此用户任务节点时，只有角色为部门经理的人才能查询和完成该任务。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E7%BB%84/%E7%94%A8%E6%88%B7%E7%BB%84%E8%A7%92%E8%89%B2%E8%AE%BE%E7%BD%AE.png" alt="用户角色组"></p>
<p>查看<strong>task.bpmn文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/MODEL"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:activiti</span>=<span class="string">"http://activiti.org/bpmn"</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/DI"</span> <span class="attr">xmlns:omgdc</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DC"</span> <span class="attr">xmlns:omgdi</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DI"</span> <span class="attr">typeLanguage</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">expressionLanguage</span>=<span class="string">"http://www.w3.org/1999/XPath"</span> <span class="attr">targetNamespace</span>=<span class="string">"http://www.activiti.org/test"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">"task"</span> <span class="attr">name</span>=<span class="string">"taskProcess"</span> <span class="attr">isExecutable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">"startevent1"</span> <span class="attr">name</span>=<span class="string">"Start"</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask1"</span> <span class="attr">name</span>=<span class="string">"审批"</span> <span class="attr">activiti:candidateGroups</span>=<span class="string">"部门经理"</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">"endevent1"</span> <span class="attr">name</span>=<span class="string">"End"</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow1"</span> <span class="attr">sourceRef</span>=<span class="string">"startevent1"</span> <span class="attr">targetRef</span>=<span class="string">"usertask1"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow2"</span> <span class="attr">sourceRef</span>=<span class="string">"usertask1"</span> <span class="attr">targetRef</span>=<span class="string">"endevent1"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">"BPMNDiagram_task"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">"task"</span> <span class="attr">id</span>=<span class="string">"BPMNPlane_task"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"startevent1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_startevent1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"35.0"</span> <span class="attr">width</span>=<span class="string">"35.0"</span> <span class="attr">x</span>=<span class="string">"360.0"</span> <span class="attr">y</span>=<span class="string">"20.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"usertask1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_usertask1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"55.0"</span> <span class="attr">width</span>=<span class="string">"105.0"</span> <span class="attr">x</span>=<span class="string">"325.0"</span> <span class="attr">y</span>=<span class="string">"120.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">"endevent1"</span> <span class="attr">id</span>=<span class="string">"BPMNShape_endevent1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">"35.0"</span> <span class="attr">width</span>=<span class="string">"35.0"</span> <span class="attr">x</span>=<span class="string">"360.0"</span> <span class="attr">y</span>=<span class="string">"240.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow1"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"377.0"</span> <span class="attr">y</span>=<span class="string">"55.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"377.0"</span> <span class="attr">y</span>=<span class="string">"120.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">"flow2"</span> <span class="attr">id</span>=<span class="string">"BPMNEdge_flow2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"377.0"</span> <span class="attr">y</span>=<span class="string">"175.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">"377.0"</span> <span class="attr">y</span>=<span class="string">"240.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到下面一段，我们成功设置了该用户任务所允许的办理人角色</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">"startevent1"</span> <span class="attr">name</span>=<span class="string">"Start"</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"usertask1"</span> <span class="attr">name</span>=<span class="string">"审批"</span> <span class="attr">activiti:candidateGroups</span>=<span class="string">"部门经理"</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">"endevent1"</span> <span class="attr">name</span>=<span class="string">"End"</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow1"</span> <span class="attr">sourceRef</span>=<span class="string">"startevent1"</span> <span class="attr">targetRef</span>=<span class="string">"usertask1"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用用户任务组"><a href="#使用用户任务组" class="headerlink" title="使用用户任务组"></a>使用用户任务组</h3><h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><p>现在，我们需要部署一个新的流程定义，和以往不同的是，在部署流程定义时，我们还需要创建用户、角色，并建立用户角色之间的关联关系。</p>
<p>假设这样一个情景，存在张三、李四、王五这三个人，张三、李四是部门经理，而王五是总经理。若我们在部署流程定义时，同时建立这三人和角色之间一一对应的关系，当我们启动流程实例后，根据上面定义的流程，可以预见张三、李四两人可以查询并完成任务，而王五由于是总经理，则无法查询并完成任务。</p>
<p>下面，我们就来部署一下流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 部署流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		InputStream inputStreamBpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"task.bpmn"</span>);</span><br><span class="line">		InputStream inputStreamPng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"task.png"</span>);</span><br><span class="line">		Deployment deploy = processEngine.getRepositoryService()</span><br><span class="line">				.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">				.name(<span class="string">"任务"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">				.addInputStream(<span class="string">"task.bpmn"</span>, inputStreamBpmn)</span><br><span class="line">				.addInputStream(<span class="string">"task.png"</span>,inputStreamPng)</span><br><span class="line">				.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">		System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">		System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">		<span class="comment">/*添加用户角色*/</span></span><br><span class="line">		IdentityService identityService = processEngine.getIdentityService();</span><br><span class="line">		<span class="comment">// 创建角色</span></span><br><span class="line">		identityService.saveGroup(<span class="keyword">new</span> GroupEntity(<span class="string">"总经理"</span>));</span><br><span class="line">		identityService.saveGroup(<span class="keyword">new</span> GroupEntity(<span class="string">"部门经理"</span>));</span><br><span class="line">		<span class="comment">// 创建用户</span></span><br><span class="line">		identityService.saveUser(<span class="keyword">new</span> UserEntity(<span class="string">"张三"</span>));</span><br><span class="line">		identityService.saveUser(<span class="keyword">new</span> UserEntity(<span class="string">"李四"</span>));</span><br><span class="line">		identityService.saveUser(<span class="keyword">new</span> UserEntity(<span class="string">"王五"</span>));</span><br><span class="line">		<span class="comment">// 建立角色和用户关联关系</span></span><br><span class="line">		identityService.createMembership(<span class="string">"张三"</span>, <span class="string">"部门经理"</span>);</span><br><span class="line">		identityService.createMembership(<span class="string">"李四"</span>, <span class="string">"部门经理"</span>);</span><br><span class="line">		identityService.createMembership(<span class="string">"王五"</span>, <span class="string">"总经理"</span>);</span><br><span class="line">		System.out.println(<span class="string">"添加组织机构成功"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在上面的代码中，我们使用了一个新的service-<strong>identityService</strong>，通过<strong>saveGroup</strong>方法，我们创建了多个角色，通过<strong>saveUser</strong>方法创建了多个用户，通过<strong>createMembership</strong>方法我们建立了角色和用户之间的关联关系。如果没有异常，我们将成功建立用户角色之间的关系。</p>
<p> 运行代码，我们得到如下结果</p>
<blockquote>
<p>部署ID: 7401<br>部署名称: 任务<br>添加组织机构成功</p>
</blockquote>
<p>为了证明我们确实建立了用户角色之间的关联关系，我们查询下面三张表</p>
<p>查询<strong>act_id_group(角色表)</strong>，可以看到，该表存储了两个角色：部门经理和总经理</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E7%BB%84/%E8%A7%92%E8%89%B2%E8%A1%A8.png" alt="角色表"></p>
<p>查询<strong>act_id_user</strong>，可以看到存在三条记录，正是我们添加的三个人：张三、李四和王五</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E7%BB%84/%E7%94%A8%E6%88%B7%E8%A1%A8.png" alt="用户表"></p>
<p>查询<strong>act_id_membership(用户角色关系表)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E7%BB%84/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E8%A1%A8.png" alt="用户角色关系表"></p>
<p>由此，我们知道，用户角色之间的关联关系成功创建了。</p>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><p>成功部署流程定义和建立用户角色关系后，我们开始启动流程实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"task"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() 	</span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>流程实例ID: 7501<br>流程定义ID: task:7:7404</p>
</blockquote>
<p>我们查询一下<strong>act_ru_task(正在执行的任务表)</strong>，发现<strong>ASSIGNEE_</strong>的值为空。于是，我们查询<strong>act_ru_identitylink(任务办理人表)</strong>和<strong>act_hi_identitylink(历史任务办理人表)</strong></p>
<p>查询<strong>act_ru_identitylink(任务办理人表)</strong>，<strong>GROUP_ID</strong>字段不为空，为部门经理</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E7%BB%84/%E4%BB%BB%E5%8A%A1%E5%8A%9E%E7%90%86%E4%BA%BA%E8%A1%A8.png" alt="任务办理人表"></p>
<p>查询<strong>act_hi_identitylink(历史任务办理人表)</strong>，我们看到了和上面一样的结果</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E7%BB%84/%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E5%8A%9E%E7%90%86%E4%BA%BA%E8%A1%A8.png" alt="历史任务办理人表"></p>
<p>由前面可知，部门经理包括两个人：张三和李四。由于<strong>ASSIGNEE_</strong>字段的值为空结合这两张表，我们知道该用户任务属于组任务的一种。因此，我们来查询两人的组任务。</p>
<h4 id="查询组任务"><a href="#查询组任务" class="headerlink" title="查询组任务"></a>查询组任务</h4><p>我们先查询张三的组任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的组任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyGroupTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"张三"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskCandidateUser(assignee)</span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到张三的详细信息</p>
<blockquote>
<p>任务ID: 7504<br>任务名称: 审批<br>任务的创建时间: Wed Oct 31 21:26:17 CST 2018<br>任务的办理人: null<br>流程实例ID: 7501<br>执行对象ID: 7501<br>流程定义ID: task:7:7404</p>
</blockquote>
<p>接下来，我们查询李四的组任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的组任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyGroupTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"李四"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskCandidateUser(assignee)</span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到李四组任务的详细信息</p>
<blockquote>
<p>任务ID: 7504<br>任务名称: 审批<br>任务的创建时间: Wed Oct 31 21:26:17 CST 2018<br>任务的办理人: null<br>流程实例ID: 7501<br>执行对象ID: 7501<br>流程定义ID: task:7:7404</p>
</blockquote>
<p>我们再查询王五的组任务，显然，我们查询不出数据，因为他是总经理，不是部门经理。</p>
<h4 id="拾取任务"><a href="#拾取任务" class="headerlink" title="拾取任务"></a>拾取任务</h4><p>既然是组任务，我们将其分配给张三，由张三去完成该任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拾取任务，将组任务分配给个人任务，指定任务办理人Assignee字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"7504"</span>;</span><br><span class="line">	<span class="comment">// 分配个人任务（可以是组任务的成员，也可以是非组任务的成员）</span></span><br><span class="line">	String userId = <span class="string">"张三"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.claim(taskId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，查询<strong>act_ru_task(正在执行的任务表)</strong>，<strong>ASSIGNEE_</strong>字段的值为<strong>张三</strong>，我们成功将组任务分配给张三了。</p>
<h4 id="完成任务"><a href="#完成任务" class="headerlink" title="完成任务"></a>完成任务</h4><p>最后，我们让张三完成任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"7504"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，该流程就结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的例子，我们对用户角色组有所了解了。现在，我们来总结一下，本章用户角色组涉及到了一个新的service-<strong>identityService</strong>，我们可以通过其相关方法完成添加用户，角色，以及用户角色等相关操作。另外在我们还了解了与此有关的三张表及其作用。</p>
<p><strong>act_id_group(角色表)</strong>：用于存储工作流定义的角色</p>
<p><strong>act_id_user(用户表)</strong>：用于存储用户</p>
<p><strong>act_id_membership(用户角色表)</strong>：用于存储用户角色对应关系</p>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--组任务分配</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E7%BB%84%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D.html</url>
    <content><![CDATA[<p>在上一章中，我们学习了个人任务分配的相关知识，本章，我们将学习组任务分配的相关知识。</p>
<p>和前面一样，我们新建包<strong>cn.demo.grouptask</strong>，新建类<strong>TaskTest.java</strong>以及流程图文件<strong>task.bpmn</strong>。</p>
<h2 id="定义审批流程"><a href="#定义审批流程" class="headerlink" title="定义审批流程"></a>定义审批流程</h2><p>为了方便学习，我们同样定义一个审批流程。不同于个人任务的是，该审批流程的办理人不是一个人，而是好几个人，除此以外，其它方面和个人任务审批流程是一样的。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E4%B8%AA%E4%BA%BA%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/%E4%B8%AA%E4%BA%BA%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D.png" alt="组任务审批流程"></p>
<h2 id="三种方式指定用户任务"><a href="#三种方式指定用户任务" class="headerlink" title="三种方式指定用户任务"></a>三种方式指定用户任务</h2><p>和个人任务一样，组任务也有三种分配方式</p>
<ol>
<li>直接指定办理人，即直接设置用户任务Assignee字段的值</li>
<li>使用流程变量，通过流程变量动态指定办理人的值</li>
<li>使用实现<strong>org.activiti.engine.delegate.TaskListener</strong>接口的类方法来动态指定办理人</li>
</ol>
<p>下面，我们一一讲解。</p>
<h3 id="直接指定办理人"><a href="#直接指定办理人" class="headerlink" title="直接指定办理人"></a>直接指定办理人</h3><p>现在，我们先来直接指定办理人，在个人任务中，我们直接指定办理人时，设置的是字段Assignee的值，而现在，若要设置组任务的办理人，则需要设置字段Candidate-user的值，并且办理人之间使用英文逗号分隔。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E7%BB%84%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE%E5%8F%82%E4%B8%8E%E8%80%85.png" alt="组任务直接指定办理人"></p>
<p>一切准备好之后，我们开始部署流程定义以及启动流程实例。</p>
<h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><p>和前面一样，我们按如下部署流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 部署流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		InputStream inputStreamBpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"task.bpmn"</span>);</span><br><span class="line">		InputStream inputStreamPng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"task.png"</span>);</span><br><span class="line">		Deployment deploy = processEngine.getRepositoryService() </span><br><span class="line">				.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">				.name(<span class="string">"任务"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">				.addInputStream(<span class="string">"task.bpmn"</span>, inputStreamBpmn)</span><br><span class="line">				.addInputStream(<span class="string">"task.png"</span>,inputStreamPng)</span><br><span class="line">				.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">		System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">		System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出如下结果</p>
<blockquote>
<p>部署ID: 6101<br>部署名称: 任务</p>
</blockquote>
<p>此时，流程定义已经部署好了，接下来就是启动流程实例了。</p>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"task"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() 	</span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出如下结果</p>
<blockquote>
<p>流程实例ID: 6201<br>流程定义ID: task:4:6104</p>
</blockquote>
<p>此时，我们查询一下<strong>act_ru_task(正在执行的任务表)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E7%BB%84%E4%BB%BB%E5%8A%A1%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A11.png" alt="正在执行的任务1"></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E7%BB%84%E4%BB%BB%E5%8A%A1%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A12.png" alt="组任务正在执行的任务2"></p>
<p>可以看到，和个人记录不一样的是，该记录的<strong>Assignee</strong>字段的内容为空</p>
<p>我们查询另外一张表<strong>act_ru_identitylink(任务办理人表，个人任务，组任务)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E7%BB%84%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%A1%A8.png" alt="组任务的任务表"></p>
<p>可以看到，该表<strong>USER_ID</strong>字段的小A，小B，小C和小D就是我们在组任务审批流程中指定的任务办理人，只是，对于他们每一个人，该表中都存在两条数据</p>
<ol>
<li>当字段TYPE_的值为<strong>candidate</strong> 时，<strong>TASK_ID</strong>的值不为空</li>
<li>当字段TYPE_的值为<strong>participant</strong>是，<strong>PROC_INST_ID</strong>的值不为空</li>
</ol>
<p>我们查询<strong>act_hi_identitylink(历史任务办理人表，个人任务，组任务)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E7%BB%84%E4%BB%BB%E5%8A%A1%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E5%8A%9E%E7%90%86%E4%BA%BA.png" alt="历史任务办理人表"></p>
<p>在这张表的数据包括了以往的所有历史办理人，对于个人任务办理人来说，其字段TYPE_的值都为<strong>participant</strong>，而对于组任务办理人来说，其TYPE_值为<strong>participant</strong>和<strong>candidate</strong>的记录都存在。</p>
<h4 id="查询任务"><a href="#查询任务" class="headerlink" title="查询任务"></a>查询任务</h4><p>现在，我们暂时把目光转移到查询任务上来。我们查询一下小A的任务，查询方法还是使用<strong>taskAssignee(assignee)</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String assignee = <span class="string">"小A"</span>;</span><br><span class="line">	List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">			.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">			<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">			.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">			<span class="comment">/*排序*/</span></span><br><span class="line">			.orderByTaskCreateTime().asc()</span><br><span class="line">			.list();</span><br><span class="line">	<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">			System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">			System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">			System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">			System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">			System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">			System.out.println(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，毫无疑问地，由于查询个人任务本质上是查询<strong>act_ru_task(正在执行的任务表)</strong>，而该表中表示任务办理人<strong>ASSIGNEE_</strong>字段的值为空，因此，我们无法查询到任何数据。</p>
<p>此时，我们应该查询某个人的组任务，而不是个人任务。为了查询某个人的组任务，我们使用<strong>taskCandidateUser(assignee)</strong>方法替换<strong>taskAssignee(assignee)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的组任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyGroupTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"小A"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskCandidateUser(assignee)</span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				.list();</span><br><span class="line">		<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，我们就得到了小A的组任务详细信息了</p>
<blockquote>
<p>任务ID: 6204<br>任务名称: 审批<br>任务的创建时间: Mon Oct 29 21:30:55 CST 2018<br>任务的办理人: null<br>流程实例ID: 6201<br>执行对象ID: 6201<br>流程定义ID: task:4:6104</p>
</blockquote>
<p>接着上一节，我们来查询任务办理人，包括历史的还是正在执行的办理人。先查正在执行的任务办理人表</p>
<h4 id="查询正在执行的任务办理人"><a href="#查询正在执行的任务办理人" class="headerlink" title="查询正在执行的任务办理人"></a>查询正在执行的任务办理人</h4><p>对于查询正在执行的任务办理人来说，我们自然而然地想到使用<strong>taskService</strong>的方法来查询，通过<strong>getIdentityLinksForTask(taskId)</strong>方法，传入<strong>taskId</strong>，我们可以查询到正在执行的任务办理人信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询正在执行的任务办理人表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findRunPersonTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6204"</span>;</span><br><span class="line">	List&lt;IdentityLink&gt; list = processEngine.getTaskService().getIdentityLinksForTask(taskId);</span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (IdentityLink identityLink : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务Id:"</span> + identityLink.getTaskId());</span><br><span class="line">			System.out.println(<span class="string">"办理人类型:"</span> + identityLink.getType());</span><br><span class="line">			System.out.println(<span class="string">"流程实例Id:"</span> + identityLink.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"用户Id:"</span> + identityLink.getUserId());</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，可以得到如下结果</p>
<blockquote>
<p>任务Id:6204<br>办理人类型:candidate<br>流程实例Id:null<br>用户Id:小A</p>
<p>任务Id:6204<br>办理人类型:candidate<br>流程实例Id:null<br>用户Id:小C</p>
<p>任务Id:6204<br>办理人类型:candidate<br>流程实例Id:null<br>用户Id:小B</p>
<p>任务Id:6204<br>办理人类型:candidate<br>流程实例Id:null<br>用户Id:小D</p>
</blockquote>
<p>可以看到，查询到的是TYPE_值为<strong>candidate</strong>的记录信息</p>
<h4 id="查询历史任务办理人"><a href="#查询历史任务办理人" class="headerlink" title="查询历史任务办理人"></a>查询历史任务办理人</h4><p>与查询正在执行的任务办理人不同，对于查询历史任务办理人，我们使用的是<strong>historyService</strong>服务，我们既可以通过任务Id来查询，也可以通过流程实例Id来查询，这里我们使用流程实例Id来完成查询操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryPersonTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程实例Id</span></span><br><span class="line">	String processInstanceId = <span class="string">"6201"</span>;</span><br><span class="line">	List&lt;HistoricIdentityLink&gt; list = processEngine.getHistoryService()</span><br><span class="line">	.getHistoricIdentityLinksForProcessInstance(processInstanceId);</span><br><span class="line">	<span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (HistoricIdentityLink historicIdentityLink : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务Id:"</span> + historicIdentityLink.getTaskId());</span><br><span class="line">			System.out.println(<span class="string">"办理人类型:"</span> + historicIdentityLink.getType());</span><br><span class="line">			System.out.println(<span class="string">"流程实例Id:"</span> + historicIdentityLink.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"用户Id:"</span> + historicIdentityLink.getUserId());</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>任务Id:null<br>办理人类型:participant<br>流程实例Id:6201<br>用户Id:小A</p>
<p>任务Id:null<br>办理人类型:participant<br>流程实例Id:6201<br>用户Id:小C</p>
<p>任务Id:null<br>办理人类型:participant<br>流程实例Id:6201<br>用户Id:小B</p>
<p>任务Id:null<br>办理人类型:participant<br>流程实例Id:6201<br>用户Id:小D</p>
</blockquote>
<p>可以预料到，若我们使用任务Id来查询历史任务办理人，则办理人类型为<strong>candidate</strong>，同时任务Id将不为空，流程实例Id则相反，其值将为空。</p>
<h4 id="拾取任务"><a href="#拾取任务" class="headerlink" title="拾取任务"></a>拾取任务</h4><p>虽然我们定义的是组任务，但是，我们还是需要将任务分配给某个人处理，因此，我们需要使用<strong>taskService</strong>的<strong>claim(taskId,userId)</strong>方法来拾取任务（认领任务），即将任务分配给个人。在分配任务时，可以分配组任务给非组任务的成员。在这里，我们指定给<strong>大F</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拾取任务，将组任务分配给个人任务，指定任务办理人Assignee字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6204"</span>;</span><br><span class="line">	<span class="comment">// 分配个人任务（可以是组任务的成员，也可以是非组任务的成员）</span></span><br><span class="line">	String userId = <span class="string">"大F"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.claim(taskId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若没有异常，我们查询<strong>act_ru_task(正在执行的任务表)</strong>，可以看到ASSIGNEE_字段的值不为空，其值为<strong>大F</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E6%8B%BE%E5%8F%96%E4%BB%BB%E5%8A%A1.png" alt="拾取任务"></p>
<p>此时，我们若查询大F的个人任务，将能够获取到大F个人任务的详细信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的组任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"大F"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskAssignee(assignee)</span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>任务ID: 6204<br>任务名称: 审批<br>任务的创建时间: Mon Oct 29 21:30:55 CST 2018<br>任务的办理人: 大F<br>流程实例ID: 6201<br>执行对象ID: 6201<br>流程定义ID: task:4:6104</p>
</blockquote>
<p>可以看到，我们确实能够查询到大F的个人任务信息，但是，使用其他人去查询是获取不到的。</p>
<p>查询一下<strong>act_ru_identitylink(正在执行任务办理人表)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%8A%9E%E7%90%86%E4%BA%BA-%E6%8B%BE%E5%8F%96%E4%BB%BB%E5%8A%A1.png" alt="正在执行任务-拾取任务"></p>
<p>再查询一下<strong>act_hi_identitylink(历史任务办理人表)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E5%8A%9E%E7%90%86%E4%BA%BA-%E6%8B%BE%E5%8F%96%E4%BB%BB%E5%8A%A1.png" alt="历史任务办理人-拾取任务"></p>
<p>可以看到，两张表中的关于大F的记录都只有一条，且其TYPE_的值为<strong>participant</strong>，这说明该任务已经成为大F的个人任务。</p>
<h4 id="回退任务"><a href="#回退任务" class="headerlink" title="回退任务"></a>回退任务</h4><p>若大F不愿意处理该任务，我们可以通过设置办理人的值为空值回退任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将个人任务回退到组任务，前提，之前一定是组任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAssigneeTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6204"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.setAssignee(taskId, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若我们此时查询<strong>act_ru_task(正在执行的任务表)</strong>，则可以发现ASSIGNEE_字段的值为空，此时我们无法查询到大F的个人任务了，个人任务重新成为组任务，当然，可以这样操作是建立在该任务之前是组任务的基础之上的。</p>
<h4 id="添加组任务成员"><a href="#添加组任务成员" class="headerlink" title="添加组任务成员"></a>添加组任务成员</h4><p>除了上述拾取任务外，我们还可以添加和删除组任务成员，下面我们先添加组任务成员大H</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向组任务中添加成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addGroupUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6204"</span>;</span><br><span class="line">	String userId = <span class="string">"大H"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.addCandidateUser(taskId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询<strong>act_ru_identitylink(正在执行的任务办理人表)</strong>，我们看到数据表添加了两条关于大H的记录</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E6%88%90%E5%91%98.png" alt="添加任务成员"></p>
<h4 id="删除组任务成员"><a href="#删除组任务成员" class="headerlink" title="删除组任务成员"></a>删除组任务成员</h4><p>现在，我们删除组任务成员小B</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从组任务删除成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteGroupUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6204"</span>;</span><br><span class="line">	String userId = <span class="string">"小B"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.deleteCandidateUser(taskId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询<strong>act_ru_identitylink(正在执行的任务办理人表)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E5%88%A0%E9%99%A4%E7%BB%84%E4%BB%BB%E5%8A%A1%E6%88%90%E5%91%98.png" alt="删除组任务成员"></p>
<p>数据表数据显示，小B还保留了一条TYPE字段值为<strong>participant</strong>类型的记录。此时，我们查询小B的组任务，无法查到该记录，说明在<strong>act_ru_identitylink(正在执行的任务办理人表)</strong>中，TYPE_字段的值为<strong>candidate</strong>的记录将用于查询组任务。</p>
<p>现在，我们让小A来拾取任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6204"</span>;</span><br><span class="line">	<span class="comment">// 分配个人任务（可以是组任务的成员，也可以是非组任务的成员）</span></span><br><span class="line">	String userId = <span class="string">"小A"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.claim(taskId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，组任务就被重新分配给了个人，于是，我们可以查询到小A的个人任务了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的组任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"小A"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskAssignee(assignee)</span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，我们获得小A个人任务的详细信息</p>
<blockquote>
<p>任务ID: 6204<br>任务名称: 审批<br>任务的创建时间: Mon Oct 29 21:30:55 CST 2018<br>任务的办理人: 小A<br>流程实例ID: 6201<br>执行对象ID: 6201<br>流程定义ID: task:4:6104</p>
</blockquote>
<p>然后，我们完成小A任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6204"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若无异常，控制台输出</p>
<blockquote>
<p>完成任务：任务Id：6204</p>
</blockquote>
<p>通过以上操作步骤，证明直接指定组任务办理人是可行的。</p>
<h3 id="使用流程变量指定办理人"><a href="#使用流程变量指定办理人" class="headerlink" title="使用流程变量指定办理人"></a>使用流程变量指定办理人</h3><p>和个人任务直接指定办理人的缺点一样，直接指定组任务办理人也是不够灵活的。因此，我们可以考虑使用流程变量指定组任务办理人。</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%BB%E5%8A%A1%E5%8A%9E%E7%90%86%E4%BA%BA.png" alt="流程变量指定办理人"></p>
<h4 id="部署流程定义和启动流程实例"><a href="#部署流程定义和启动流程实例" class="headerlink" title="部署流程定义和启动流程实例"></a>部署流程定义和启动流程实例</h4><p>和前面一样，我们重新部署流程定义</p>
<blockquote>
<p>部署ID: 6801<br>部署名称: 任务</p>
</blockquote>
<p>部署流程定义以后，我们启动流程实例，并在启动流程实例的同时，设置组任务的办理人，和前一节一样，各个办理人之间使用逗号分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 启动流程实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 流程定义的key</span></span><br><span class="line">		String processDefinitionKey = <span class="string">"task"</span>;</span><br><span class="line">		Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">		map.put(<span class="string">"userIDs"</span>, <span class="string">"大大,中中,小小"</span>);</span><br><span class="line">		ProcessInstance processInstance = processEngine.getRuntimeService() 	</span><br><span class="line">				.startProcessInstanceByKey(processDefinitionKey,map); </span><br><span class="line">		System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">		System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 																	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出如下结果</p>
<blockquote>
<p>流程实例ID: 6901<br>流程定义ID: task:5:6804</p>
</blockquote>
<h4 id="查询任务-1"><a href="#查询任务-1" class="headerlink" title="查询任务"></a>查询任务</h4><p>可以预见，查询<strong>act_ru_identitylink(正在执行的任务办理人表)</strong>，大大，中中，小小分别有两条记录，只是两条记录办理人类型不一样而已。现在，我们来查询大大的组任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的组任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyGroupTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"大大"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskCandidateUser(assignee)</span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>任务ID: 6905<br>任务名称: 审批<br>任务的创建时间: Tue Oct 30 21:15:04 CST 2018<br>任务的办理人: null<br>流程实例ID: 6901<br>执行对象ID: 6901<br>流程定义ID: task:5:6804</p>
</blockquote>
<h4 id="拾取任务-1"><a href="#拾取任务-1" class="headerlink" title="拾取任务"></a>拾取任务</h4><p>从上面的信息中，我们得到了任务Id，接下来，我们让大大来拾取任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拾取任务，将组任务分配给个人任务，指定任务办理人Assignee字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6905"</span>;</span><br><span class="line">	<span class="comment">// 分配个人任务（可以是组任务的成员，也可以是非组任务的成员）</span></span><br><span class="line">	String userId = <span class="string">"大大"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.claim(taskId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完成任务"><a href="#完成任务" class="headerlink" title="完成任务"></a>完成任务</h4><p>当大大完成拾取任务后，我们就可以完成该任务了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"6905"</span>;</span><br><span class="line">	processEngine.getTaskService().complete(taskId);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，没有异常。这样，我们就完成该<strong>审批</strong>流程，实践证明使用流程变量指定组任务办理人也是可以的。</p>
<h3 id="使用类指定办理人"><a href="#使用类指定办理人" class="headerlink" title="使用类指定办理人"></a>使用类指定办理人</h3><p>前面已经介绍了两种方式，现在，我们就介绍最后一种，使用类指定办理人。</p>
<p>为了更好地说明如何使用类指定办理人，我们新建包<strong>cn.demo.groupbyclass</strong>，并新建类<strong>TaskTest</strong>，流程图文件<strong>task.bpmn</strong></p>
<p>既然是使用类指定办理人，那么我们就不再指定<strong>Candidate user</strong>，因此，该字段值为空，不需要任何值，只是需要一个实现<strong>org.activiti.engine.delegate.TaskListener</strong>的类，该类添加了郭靖、黄蓉这两个成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.demo.groupbyclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.delegate.DelegateTask;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.delegate.TaskListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskListenerImpl</span> <span class="keyword">implements</span> <span class="title">TaskListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(DelegateTask arg0)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 设置组任务办理人</span></span><br><span class="line">		arg0.addCandidateUser(<span class="string">"郭靖"</span>);</span><br><span class="line">		arg0.addCandidateUser(<span class="string">"黄蓉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和个人任务使用类指定办理人一样，我们同样需要设置<strong>审批</strong>用户任务的监听类</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%BB%84%E4%BB%BB%E5%8A%A1/%E7%BB%84%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%B1%BB%E8%AE%BE%E7%BD%AE%E5%8A%9E%E7%90%86%E4%BA%BA.png" alt="使用类指定组任务办理人"></p>
<h4 id="部署流程定义和启动流程实例-1"><a href="#部署流程定义和启动流程实例-1" class="headerlink" title="部署流程定义和启动流程实例"></a>部署流程定义和启动流程实例</h4><p>一切准备好之后，同样地，我们部署一个新流程定义</p>
<blockquote>
<p>部署ID: 7101<br>部署名称: 任务</p>
</blockquote>
<p>然后，我们启动流程实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"task"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() 	</span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>流程实例ID: 7201<br>流程定义ID: task:6:7104</p>
</blockquote>
<p>这样，我们的组任务成员就包含了郭靖，黄蓉两人了。接下来，我们将组任务分配给郭靖，并由其去完成任务。</p>
<h4 id="查询任务-2"><a href="#查询任务-2" class="headerlink" title="查询任务"></a>查询任务</h4><p>我们来查询一下郭靖的组任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的组任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyGroupTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"郭靖"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskCandidateUser(assignee)</span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，得到如下结果</p>
<blockquote>
<p>任务ID: 7204<br>任务名称: 审批<br>任务的创建时间: Tue Oct 30 21:57:28 CST 2018<br>任务的办理人: null<br>流程实例ID: 7201<br>执行对象ID: 7201<br>流程定义ID: task:6:7104</p>
</blockquote>
<h4 id="拾取任务-2"><a href="#拾取任务-2" class="headerlink" title="拾取任务"></a>拾取任务</h4><p>通过上面的信息，我们使用任务Id让郭靖拾取任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拾取任务，将组任务分配给个人任务，指定任务办理人Assignee字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"7204"</span>;</span><br><span class="line">	<span class="comment">// 分配个人任务（可以是组任务的成员，也可以是非组任务的成员）</span></span><br><span class="line">	String userId = <span class="string">"郭靖"</span>;</span><br><span class="line">	processEngine.getTaskService()</span><br><span class="line">	.claim(taskId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若无异常，则表示任务拾取成功，组任务分配给了郭靖，为保险起见，我们查询一下郭靖的个人任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String assignee = <span class="string">"郭靖"</span>;</span><br><span class="line">		List&lt;Task&gt; list = processEngine.getTaskService() </span><br><span class="line">				.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">				<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">				.taskAssignee(assignee)</span><br><span class="line">				<span class="comment">/*排序*/</span></span><br><span class="line">				.orderByTaskCreateTime().asc()</span><br><span class="line">				.list();</span><br><span class="line">		<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">				System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">				System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">				System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">				System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">				System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">				System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">				System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，输出如下信息</p>
<blockquote>
<p>任务ID: 7204<br>任务名称: 审批<br>任务的创建时间: Tue Oct 30 21:57:28 CST 2018<br>任务的办理人: 郭靖<br>流程实例ID: 7201<br>执行对象ID: 7201<br>流程定义ID: task:6:7104</p>
</blockquote>
<p>输出不为空，证明郭靖确实拾取了任务。</p>
<h4 id="完成任务-1"><a href="#完成任务-1" class="headerlink" title="完成任务"></a>完成任务</h4><p>最后，我们来完成任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 完成我的任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String taskId = <span class="string">"7204"</span>;</span><br><span class="line">		processEngine.getTaskService().complete(taskId);</span><br><span class="line">		System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="组任务三种指定办理人的方式"><a href="#组任务三种指定办理人的方式" class="headerlink" title="组任务三种指定办理人的方式"></a>组任务三种指定办理人的方式</h3><ol>
<li>直接指定办理人，即直接设置用户任务Assignee字段的值</li>
<li>使用流程变量，通过流程变量动态指定办理人的值</li>
<li>使用实现<strong>org.activiti.engine.delegate.TaskListener</strong>接口的类方法来动态指定办理人的值 ,即使用delegateTask.addCandidateUser(userId)添加组任务办理人</li>
</ol>
<h3 id="认领-拾取-和回退组任务"><a href="#认领-拾取-和回退组任务" class="headerlink" title="认领(拾取)和回退组任务"></a>认领(拾取)和回退组任务</h3><p>组任务要进行处理，必须分配给特定的办理人（认领任务），此时，可以使用<strong>processEngine.getTaskService().claim(taskId, userId)</strong>方法分配任务给特定办理人。</p>
<p><strong>注意：该特定办理人既可以是组任务成员中的人，也可以不是组任务成员的人</strong></p>
<p>当然，我们也可以使用<strong>processEngine.getTaskService(). setAssignee(taskId, null)</strong>方法回退组任务，前提是该任务之前是组任务。</p>
<h3 id="添加或删除组任务成员"><a href="#添加或删除组任务成员" class="headerlink" title="添加或删除组任务成员"></a>添加或删除组任务成员</h3><p>在组任务中，我们既可以使用<strong>processEngine.getTaskService().addCandidateUser(taskId, userId)</strong>方法向组任务添加人员，也可以使用<strong>processEngine.getTaskService().addCandidateUser(taskId, userId)</strong>从组任务中删除人员。</p>
<h3 id="任务办理人相关的表"><a href="#任务办理人相关的表" class="headerlink" title="任务办理人相关的表"></a>任务办理人相关的表</h3><p><strong>act_ru_identitylink(正在执行的任务办理人表)</strong>表存放任务的办理人，包括个人任务和组任务，表示正在执行的任务</p>
<p><strong>act_hi_identitylink(历史任务办理人表)</strong>表存放任务的办理人，包括个人任务和组任务，表示历史任务</p>
<p>区别在于：</p>
<ol>
<li><p>如果是个人任务，TYPE_的类型为participant（参与者）</p>
</li>
<li><p>如果是组任务，TYPE_的类型包括candidate（候选者）和participant（参与者）两种</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Activiti5入门--连线</title>
    <url>/Activiti5%E5%85%A5%E9%97%A8-%E8%BF%9E%E7%BA%BF.html</url>
    <content><![CDATA[<p>连线(SequenceFlow)是工作流中极其重要的一部分，是用于连接各个节点的有向线段。在上面的章节中，工作流流程定义都是不存在分支选择的情况的，在本章，我们将学习连线的相关知识，定义一个带有分支的工作流流程。</p>
<h3 id="定义分支流程"><a href="#定义分支流程" class="headerlink" title="定义分支流程"></a>定义分支流程</h3><p>为了定义一个新的工作流，在<strong>src/main/java</strong>下新建包<strong>cn.demo.sequencefloe</strong>，并在该包下创建<strong>sequenceFlow.bpmn</strong>文件，定义如下流程</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E8%BF%9E%E7%BA%BF/%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B.png" alt="分支流程"></p>
<ol>
<li>首先，创建一个开始节点，作为流程定义的开头</li>
<li>其次，创建一个用户任务节点，设置其Nam值为<strong>审批【部门经理】</strong>，其Assignee为<strong>赵六</strong></li>
<li>然后，再创建一个用户任务节点，设置其Name值为<strong>审批【总经理】</strong>，其Assignee为<strong>田七</strong></li>
<li>接着，再创建一个结束节点，作为流程定义的结尾</li>
<li>点击空白处，设置其Id为<strong>sequenceFlow</strong>，其Name为<strong>sequenceFlowProcess</strong></li>
</ol>
<p>通过上述的步骤，我们就完成了一个流程定义的基本雏形，下面，我们开始学习如何控制选择分支。</p>
<ol>
<li>选中<strong>审批【部门经理】</strong>到结束节点这条连线，选择Propertis对话框中的General选项卡，设置其Name为<strong>不重要</strong>，用于显示提示信息。然后，选择Main-config选项卡，填写Condition，用于设置条件变量，当变量满足一定条件时，切换到流程分支上。在该连线上，定义流程变量message，其值为<strong>不重要</strong>，${}内的内容为一个逻辑表达式。该流程变量会在后面的代码实践中设置，这里先定义一下。<br><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E8%BF%9E%E7%BA%BF/%E8%AE%BE%E7%BD%AE%E9%83%A8%E9%97%A8%E7%BB%8F%E7%90%86%E5%AE%A1%E6%89%B9%E8%BF%9E%E7%BA%BF.png" alt="设置部门经理审批连线"></li>
<li>相似地，选中<strong>审批【部门经理】</strong>到<strong>审批【总经理】</strong>之间的连线，设置其Name的值为<strong>重要</strong>，设置流程变量message的值为<strong>重要</strong>。</li>
</ol>
<p>当完成这两步以后，这个流程就彻底定义好了，当流程变量message的值为<strong>不重要</strong>时，部门经理直接审批通过，否则还需要总经理审批。<br><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E8%BF%9E%E7%BA%BF/%E6%9C%80%E7%BB%88%E7%89%88%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E5%9B%BE.png" alt="最终版流程定义图"></p>
<h3 id="连线示例"><a href="#连线示例" class="headerlink" title="连线示例"></a>连线示例</h3><p>在该包下创建一个测试类<strong>SequenceFlowTest</strong>，接下来，我们就来部署该流程定义、启动流程实例，并试着设置流程变量message的值，通过设置不同的值来控制执行哪一条流程分支。</p>
<h4 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h4><p>不可避免地，我们先要部署一个流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 部署流程定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploymentProcessDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		InputStream inputStreamBpmn = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"sequenceFlow.bpmn"</span>);</span><br><span class="line">		InputStream inputStreamPng = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"sequenceFlow.png"</span>);</span><br><span class="line">		Deployment deploy = processEngine.getRepositoryService() <span class="comment">// 与流程定义和部署对象相关的Service</span></span><br><span class="line">				.createDeployment() <span class="comment">// 创建一个部署对象</span></span><br><span class="line">				.name(<span class="string">"连线"</span>) <span class="comment">// 添加部署的名称</span></span><br><span class="line">				.addInputStream(<span class="string">"sequenceFlow.bpmn"</span>, inputStreamBpmn)</span><br><span class="line">				.addInputStream(<span class="string">"sequenceFlow.png"</span>,inputStreamPng)</span><br><span class="line">				.deploy(); <span class="comment">// 完成部署</span></span><br><span class="line">		System.out.println(<span class="string">"部署ID: "</span> + deploy.getId());</span><br><span class="line">		System.out.println(<span class="string">"部署名称: "</span> + deploy.getName());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意，此时直接执行代码，会报错，无法成功部署流程定义。</p>
<blockquote>
<p> 若将流程图放置在和java类相同的路径下，需要进行配置</p>
</blockquote>
<p>为了使程序能够正常运行，成功部署流程定义，需要右击项目，选择Build-Path来配置Java Build Path</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E8%BF%9E%E7%BA%BF/JavaBuildPath.png" alt="JavaBuildPath"></p>
<p>选中到<strong>src/main/java</strong>下的Included那一行，选择<strong>Remove</strong>，将其改为<strong>Included:(All)</strong></p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E8%BF%9E%E7%BA%BF/%E4%BF%AE%E6%94%B9buildPath.png" alt="修改BuildPath"></p>
<p>这样，我们再执行代码，就能成功部署流程定义了。执行结果如下</p>
<blockquote>
<p>部署ID: 2601<br>部署名称: 连线</p>
</blockquote>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><p>部署流程定义成功以后，我们开始启动流程实例，在这里，我们使用流程定义的key来启动流程实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动流程实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 流程定义的key</span></span><br><span class="line">	String processDefinitionKey = <span class="string">"sequenceFlow"</span>;</span><br><span class="line">	ProcessInstance processInstance = processEngine.getRuntimeService() </span><br><span class="line">			.startProcessInstanceByKey(processDefinitionKey); </span><br><span class="line">	System.out.println(<span class="string">"流程实例ID: "</span> + processInstance.getId()); </span><br><span class="line">	System.out.println(<span class="string">"流程定义ID: "</span> + processInstance.getProcessDefinitionId()); 		&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，得到如下结果</p>
<blockquote>
<p>流程实例ID: 2701<br>流程定义ID: sequenceFlow:1:2604</p>
</blockquote>
<p>此时，流程执行到<strong>审批【部门经理】</strong>任务，联系上下文可知，当前任务的执行人是赵六，可以通过执行人得到当前任务的详细信息。</p>
<h4 id="查询个人任务"><a href="#查询个人任务" class="headerlink" title="查询个人任务"></a>查询个人任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询当前人的个人任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String assignee = <span class="string">"赵六"</span>;</span><br><span class="line">	List&lt;Task&gt; list = processEngine.getTaskService() <span class="comment">// 与正在执行的任务管理相关的Service</span></span><br><span class="line">			.createTaskQuery() <span class="comment">// 创建任务对象</span></span><br><span class="line">			<span class="comment">/*查询条件（部分）*/</span></span><br><span class="line">			.taskAssignee(assignee) <span class="comment">// 指定个人任务,指定办理人</span></span><br><span class="line">			<span class="comment">// .taskCandidateUser(arg0) 组任务的办理人</span></span><br><span class="line">			<span class="comment">// .processDefinitionId(arg0)  流程定义id</span></span><br><span class="line">			<span class="comment">// .processInstanceId(arg0) // 流程实例id</span></span><br><span class="line">			<span class="comment">// .executionId(arg0) // 执行对象id</span></span><br><span class="line">			<span class="comment">/*排序*/</span></span><br><span class="line">			.orderByTaskCreateTime().asc()</span><br><span class="line">			<span class="comment">/*返回结果集*/</span></span><br><span class="line">			<span class="comment">// .singleResult() // 返回唯一结果集</span></span><br><span class="line">			<span class="comment">// .count() // 返回结果集数量</span></span><br><span class="line">			<span class="comment">// .listPage(arg0, arg1) // 分页查询结果集</span></span><br><span class="line">			.list();</span><br><span class="line">	<span class="comment">// 存储在act_ru_task表</span></span><br><span class="line">	<span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">			System.out.println(<span class="string">"任务ID: "</span> + task.getId());</span><br><span class="line">			System.out.println(<span class="string">"任务名称: "</span> + task.getName());</span><br><span class="line">			System.out.println(<span class="string">"任务的创建时间: "</span> + task.getCreateTime());</span><br><span class="line">			System.out.println(<span class="string">"任务的办理人: "</span> + task.getAssignee());</span><br><span class="line">			System.out.println(<span class="string">"流程实例ID: "</span> + task.getProcessInstanceId());</span><br><span class="line">			System.out.println(<span class="string">"执行对象ID: "</span> + task.getExecutionId());</span><br><span class="line">			System.out.println(<span class="string">"流程定义ID: "</span> + task.getProcessDefinitionId());</span><br><span class="line">			System.out.println(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，我们得到如下结果</p>
<blockquote>
<p>任务ID: 2704<br>任务名称: 审批【部门经理】<br>任务的创建时间: Wed Oct 10 21:07:20 CST 2018<br>任务的办理人: 赵六<br>流程实例ID: 2701<br>执行对象ID: 2701<br>流程定义ID: sequenceFlow:1:2604</p>
</blockquote>
<h4 id="完成任务-重点"><a href="#完成任务-重点" class="headerlink" title="完成任务(重点)"></a>完成任务(重点)</h4><p>现在，我们可以完成任务了，这里涉及到一个问题，执行完<strong>审批【部门经理】</strong>任务后，是直接结束还是需要执行<strong>审批【总经理】</strong>任务呢？由流程图可知，若是事情不重要，则直接结束，若事情重要，则还需要经过总经理审批。</p>
<p>在前面定义流程的时候，我们设置了一个流程变量message，当该变量的值为<strong>不重要</strong>时，部门经理审批后可以直接结束流程，当该变量的值为<strong>重要</strong>时，需要总经理审批之后才能结束流程。<em>因此，我们可以通过在完成任务时设置流程变量message的值来控制是直接结束还是需要继续审批。</em></p>
<p>在前面的流程变量文章中，提到过activiti提供了该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成我的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeMyPersonalTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String taskId = <span class="string">"2704"</span>;</span><br><span class="line">	<span class="comment">// 完成任务的同时，设置流程变量message的值，来控制下一连线</span></span><br><span class="line">	Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">	map.put(<span class="string">"message"</span>, <span class="string">"不重要"</span>);</span><br><span class="line">	processEngine.getTaskService().complete(taskId, map);</span><br><span class="line">	System.out.println(<span class="string">"完成任务：任务Id："</span> + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行完上述代码后，输出下面的结果，并且由流程图可知，该流程已经结束了。</p>
<blockquote>
<p>完成任务：任务Id：2704</p>
</blockquote>
<p>查询<strong>act_hi_procinst(流程实例的历史表)</strong>，可以看到该流程实例记录的结束时间不为空，该流程实例确实结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>一个活动中可以指定一个或多个SequenceFlow（Start中有一个，End中没有）。</p>
<p>开始活动中有一个SequenceFlow </p>
<p>结束活动中没有SequenceFlow </p>
<p>其他活动中有1条或多条SequenceFlow</p>
</li>
<li><p>如果只有一个SequenceFlow ，即只有唯一一条分支。则可以不使用流程变量设置codition的名称，如果有多个，则需要使用流程变量设置codition的名称。前面使用的message为流程变量的名称，${}中间的内容要使用boolean类型的表达式，用来判断应该执行的连线，即走哪一条分支。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Activiti5</category>
      </categories>
      <tags>
        <tag>Activiti5入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java File类</title>
    <url>/Java-File%E7%B1%BB.html</url>
    <content><![CDATA[<h3 id="File类概述"><a href="#File类概述" class="headerlink" title="File类概述"></a>File类概述</h3><p><code>java.io.File</code>类是文件和目录路径名的抽象表示形式。java把电脑中的文件和目录封装成了一个<code>File</code>类，我们可以使用<code>File</code>类对文件和文件夹进行操作：</p>
<ul>
<li>创建一个文件或文件夹</li>
<li>删除一个文件或文件夹</li>
<li>获取一个文件或文件夹</li>
<li>判断一个文件或文件夹</li>
<li>对文件夹进行遍历</li>
<li>获取文件的大小</li>
</ul>
<p><code>File</code>类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法。在<code>File</code>类中，有三个重要概念：</p>
<ul>
<li><code>file</code>：文件</li>
<li><code>directory</code>：文件夹/目录</li>
<li><code>path</code>：路径</li>
</ul>
<h3 id="File类的静态成员变量"><a href="#File类的静态成员变量" class="headerlink" title="File类的静态成员变量"></a>File类的静态成员变量</h3><table>
<thead>
<tr>
<th>静态成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>File.pathSeparator</code></td>
<td>与系统有关的路径分隔符，为了方便表示为字符串</td>
</tr>
<tr>
<td><code>File.pathSeparatorChar</code></td>
<td>与系统有关的路径分隔符</td>
</tr>
<tr>
<td><code>File.separator</code></td>
<td>与系统有关的默认名称分隔符，为了方便表示为字符串</td>
</tr>
<tr>
<td><code>File.separatorChar</code></td>
<td>与路径有关的路径分隔符</td>
</tr>
</tbody></table>
<ul>
<li>默认情况下，windows系统的默认路径分隔符为<code>;</code>，linux系统默认路径分隔符为<code>:</code>。</li>
<li>默认情况下，windows系统的默认名称分隔符为<code>\</code>，linux系统默认名称分隔符为<code>/</code>。</li>
</ul>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><p>路径不区分大小写，可以分为两种路径：绝对路径和相对路径</p>
<ul>
<li>绝对路径：是一个完整的路径，以盘符开始的路径。</li>
<li>相对路径：是一个简化的路径，相对于当前项目的根目录，如果使用当前项目的根目录，则路径可以简化。</li>
</ul>
<h3 id="File类的构造方法"><a href="#File类的构造方法" class="headerlink" title="File类的构造方法"></a>File类的构造方法</h3><ul>
<li><p><code>File(String pathname)</code>：通过将给定路径名字符串转换为抽象路径名来创建一个新File实例。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String pathname</code></td>
<td><code>String pathname</code>：字符串的路径名称<br/> 路径可以是以文件结尾或文件夹结尾<br/> 路径可以是相对路径或绝对路径<br/>路径可以是存在或不存在<br/> 创建File对象，只是把字符串路径封装为<code>File</code>对象，不考虑路径的真假情况</td>
</tr>
</tbody></table>
</li>
<li><p><code>File(String parent, String child)</code>：根据parent路径名字字符串和child路径名字字符串创建了一个新File实例。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String parent, String child</code></td>
<td>把路径分成了两部分 <br/> <code>String parent</code>：父路径<br/> <code>String child</code>：子路径<br/>好处：<br/>    父路径和子路径，可以单独书写，使用起来灵活；父子路径都可以变化</td>
</tr>
</tbody></table>
</li>
<li><p><code>File(File parent, String child)</code>：根据parent抽象路径和child路径名字字符串创建一个新File实例。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>File parent, String child</code></td>
<td>把路径分成了两部分<br/> <code>File parent</code>：父路径<br/> <code>String child</code>：子路径<br/> 好处：<br/>  父路径和子路径，可以单独书写，使用起来灵活；父路径和子路径都可以变化<br/>  父路径是<code>File</code>类型，可以使用<code>File</code>的方法对路径进行一些操作再使用路径创建对象</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="File类获取功能"><a href="#File类获取功能" class="headerlink" title="File类获取功能"></a>File类获取功能</h3><ul>
<li><code>public String getAbsolutePath()</code>：返回此File的绝对路径名字符串，获取构造方法中传递的路径，无论是绝对路径还是相对路径，返回的都是绝对路径。</li>
<li><code>public String getPath()</code>：将此File转换为路径名字符串，即获取构造方法中传递的路径，传递的路径是什么样就返回什么样的路径。<br><code>public String getName()</code>：返回由此File表示的文件或文件夹(目录)的名称，获取的就是构造方法传递路径的结尾部分（文件，文件夹）<br><code>public long length()</code>：返回由此File表示的文件的长度(大小)，获取的构造方法指定的文件的大小，以字节为单位。<strong>注意，文件夹是没有大小概念的，不能获取文件夹大小。如果构造方法中给出的路径不存在，那么length方法返回零</strong>。</li>
</ul>
<h3 id="File判断功能"><a href="#File判断功能" class="headerlink" title="File判断功能"></a>File判断功能</h3><ul>
<li><p><code>public boolean exists()</code>：此File表示的文件或目录是否实际存在。用于判断构造方法中的路径是否存在，存在则为true，不存在则为false。</p>
</li>
<li><p><code>public boolean isDirectory()</code>：用于判断构造方法中给定的路径是否以文件夹结尾。如果是返回true，否则返回false</p>
</li>
<li><p><code>public  boolean isFile()</code>：此<code>File</code>表示的是否为文件，用于判断构造方法中给定的路径是否以文件结尾。如果是返回true，否则返回false。</p>
</li>
</ul>
<p><code>isDirectory()</code>和<code>isFile()</code>使用的前提是路径必须存在，否则都返回false。由于电脑中只有文件或文件夹，因此，这两个方法是互斥的。</p>
<h3 id="File类创建删除功能"><a href="#File类创建删除功能" class="headerlink" title="File类创建删除功能"></a>File类创建删除功能</h3><ul>
<li><p><code>public boolean createNewFile()</code>：当且仅当具有该名称的文件不存在时，创建一个新的空文件。</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>当且仅当具有该名称的文件不存在时，创建一个新的空文件。<br/>创建文件的路径和名称在构造方法中给出，<br/>返回值：    true，文件不存在，创建文件返回true；<br/>        false,文件存在，不会创建</td>
<td>此方法只能创建文件，不能创建文件夹，<br/>创建文件的路径必须存在，否则会抛出异常。</td>
</tr>
</tbody></table>
</li>
<li><p><code>public boolean delete()</code>：删除由此<code>File</code>表示的文件或目录。</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>当且仅当具有该名称的文件不存在时，创建一个新的空文件。<br/>创建文件的路径和名称在构造方法中给出，<br/>返回值：<br/>        true，文件不存在，创建文件返回true；<br/>        false,文件存在，不会创建</td>
<td>此方法只能创建文件，不能创建文件夹，<br/>创建文件的路径必须存在，否则会抛出异常。</td>
</tr>
</tbody></table>
</li>
<li><p><code>public boolean mkdir()</code>：创建由此<code>File</code>表示的目录。</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>创建文件夹的路径和名称在构造方法中给出，<br/>返回值：<br/>      true，文件夹不存在，创建文件夹返回true；<br/>      false,文件夹存在，不会创建；构造方法中给出的路径不存在返回false</td>
<td>此方法只能创建文件夹，不能创建文件</td>
</tr>
</tbody></table>
</li>
<li><p><code>public boolean mkdirs()</code>：创建由此<code>File</code>表示的目录，包括任何必须但不存在的父目录</p>
</li>
</ul>
<h3 id="File类目录的遍历功能"><a href="#File类目录的遍历功能" class="headerlink" title="File类目录的遍历功能"></a>File类目录的遍历功能</h3><p><code>File</code>类遍历目录（文件夹）的方法有两个：</p>
<ul>
<li><p><code>public String[] list() </code>：返回一个<code>String</code>数组，表示该<code>File</code>目录中的所有子文件或目录。</p>
</li>
<li><p><code>public File[] listFiles()</code>：返回一个<code>File</code>数组，表示该<code>File</code>目录中的所有子文件或目录。</p>
<table>
<thead>
<tr>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>list()</code>和<code>listFiles()</code>遍历的是构造方法中给出的目录，<br/>如果构造方法给出的目录的路径不存在，会抛出空指针异常。<br/>如果构造方法给出的路径不是一个目录，也会抛出空指针异常。</td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>Java输入输出</category>
      </categories>
      <tags>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术36讲--String、StringBuffer、StringBuilder比较</title>
    <url>/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%AF%94%E8%BE%83.html</url>
    <content><![CDATA[<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是Java语言非常基础和重要的类，该类提供了构造和管理字符串的各种基本逻辑，是一个典型的不可变类，其被声明为final class,所有属性都是final的。正是由于其不可变性，类似拼接，裁剪字符串都会产生新的String对象。由于字符串操作在编程中的广泛使用，相关操作的效率往往对性能有明显的影响。</p>
<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>StringBuffer是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，它是 Java 1.5 中新增的，我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。 StringBuffer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以<strong>除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder</strong>。 </p>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>StringBuilder在能力上和StringBuffer没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，<strong>是绝大部分情况下进行字符串拼接的首选</strong>。 </p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="String、StringBuffer、StringBuilder比较"><a href="#String、StringBuffer、StringBuilder比较" class="headerlink" title="String、StringBuffer、StringBuilder比较"></a>String、StringBuffer、StringBuilder比较</h5><ul>
<li><p><strong>String的特点</strong>: String是一个不可变类，所谓不可变就是一经创建则不能再对其进行改变，对于拼接，裁剪等操作，都会产生新的String对象。</p>
</li>
<li><p><strong>StringBuffer的特点</strong>: 是一个可变类，对于该类型的字符串进行拼接，裁剪操作，不会产生新的对象，同时它也是线程安全的。</p>
</li>
<li><p><strong>StringBuilder的特点</strong>: 和StringBuffer类似，对于该类型的字符串进行拼接，裁剪操作，不会产生新的对象，但其不是线程安全的。若是没有线程安全的需要，推荐使用StringBuilder，而不是StringBuffer或者String类。</p>
</li>
</ul>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>  若字符串内容不会经常发生变化，则推荐使用String</p>
<p>  若要对字符串频繁进行操作，且要求多线程，则推荐使用线程安全的StringBuffer，例如XML解析、HTTP参数解析与封装；否则使用StringBuilder，例如SQL语句拼装、JSON封装等</p>
<h4 id="字符串设计和实现考量"><a href="#字符串设计和实现考量" class="headerlink" title="字符串设计和实现考量"></a>字符串设计和实现考量</h4><ul>
<li><p>String是不可变类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改 </p>
</li>
<li><p>StringBuffer的线程安全是通过把各种修改数据的方法都加上synchronized关键字实现的，这种方法适合常见的线程安全类实现，线程安全会带来一定的性能开销</p>
</li>
</ul>
<h5 id="StringBuffer和StringBuilder实现异同"><a href="#StringBuffer和StringBuilder实现异同" class="headerlink" title="StringBuffer和StringBuilder实现异同"></a>StringBuffer和StringBuilder实现异同</h5><p>  StringBuffer和StringBuilder底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了synchronized 。</p>
<h5 id="创建StringBuffer和StringBuilder的大小初始化问题"><a href="#创建StringBuffer和StringBuilder的大小初始化问题" class="headerlink" title="创建StringBuffer和StringBuilder的大小初始化问题"></a>创建StringBuffer和StringBuilder的大小初始化问题</h5><p>对于这两者来说，内部数组如果初始化的长度太小，则拼接的时候可能需要重新创建足够大的数组，如果初始化时太大，则会造成空间的浪费。</p>
<p>现有的实现可以是，构建时可以使内部数组大小为在初始字符串长度基础上加上16（这意味着，如果在构建对象时没有输入最初的字符串，那么初始值就是16）。如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行arraycopy</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术36讲--开篇</title>
    <url>/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2-%E5%BC%80%E7%AF%87.html</url>
    <content><![CDATA[<p>最近在看杨晓峰的《Java核心技术36讲》专栏，借此机会，刚好能够巩固一下Java基础知识，梳理一下Java知识体系,在该专栏中，其讲解内容主要分成以下几个模块</p>
<ul>
<li><p><code>Java基础</code> : 主要介绍的是Java语言基本特性和机制</p>
</li>
<li><p><code>Java进阶</code> : 并发编程、Java虚拟机等领域</p>
</li>
<li><p><code>Java应用开发扩展</code> : 该模块包括数据库编程、主流开源框架、分布式开发等</p>
</li>
<li><p><code>Java安全基础</code> : 这一模块主要帮助理解常见的应用安全问题和处理方法</p>
</li>
<li><p><code>Java性能基础</code> : 掌握相关工具、方法论与基础实践 </p>
</li>
</ul>
<p>在学习该专栏期间，我也会按照专栏中Java知识的讲解顺序，将36讲的核心内容发布到博客中。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术36讲--Exception和Error的区别</title>
    <url>/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2-Exception%E5%92%8CError%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<h4 id="Java异常处理机制中的Exception和Error"><a href="#Java异常处理机制中的Exception和Error" class="headerlink" title="Java异常处理机制中的Exception和Error"></a>Java异常处理机制中的Exception和Error</h4><p>Exception和Error都继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出(throw)或者捕获(catch)，它是异常处理机制的基本组成类型，Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类 </p>
<h4 id="Exception的含义"><a href="#Exception的含义" class="headerlink" title="Exception的含义"></a>Exception的含义</h4><p>Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应的处理。</p>
<p>Exception又可分为<strong>可检查异常</strong>和<strong>不检查异常</strong></p>
<ul>
<li><p><em>可检查异常</em>在源代码里必须显式地进行捕获处理，这是编译器检查的一部分</p>
</li>
<li><p><em>不检查异常</em>就是所谓的运行时异常，例如NullPointerException、ArrayIndexOutOfBoundException，通常是可以通过编码避免的逻辑错误，具体需要根据实际情况来判断是否需要捕获，并不会在编译期强制要求 </p>
</li>
</ul>
<h4 id="Error的含义"><a href="#Error的含义" class="headerlink" title="Error的含义"></a>Error的含义</h4><p>Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会使应用程序处于非正常的、不可恢复的状态。既然是非正常情况，所以不便于也不用捕获。</p>
<h4 id="Java异常处理的常见考点"><a href="#Java异常处理的常见考点" class="headerlink" title="Java异常处理的常见考点"></a>Java异常处理的常见考点</h4><ul>
<li><p>需要理解Throwable、Exception、Error的设计和分类，掌握应用最为广泛的子类，以及学会如何自定义异常。</p>
<p><img src="https://east-hexo.oss-cn-hangzhou.aliyuncs.com/Java%E6%A0%B8%E5%BF%8336%E8%AE%B2/Exception%E5%92%8CError.png" alt="Throwable及其子类图"></p>
</li>
<li><p>需要理解Java语言中操作Throwable的元素和实践。掌握最基本的语法是必须的，如try-catch-finally块，throw、throws关键字等。与此同时，还要学会懂得如何处理典型场景</p>
<p>例如先看一下下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 业务代码</span></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">// Ignore it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码虽然很短，但是已经违反了异常处理的两个基本原则 </p>
<ul>
<li><p><strong>尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常</strong>。在这里是 Thread.sleep() 抛出的应该是InterruptedException。 应该让自己的代码能够直观地体现出尽量多的信息，而泛泛的Exception之类，恰恰隐藏了我们的目的 。另外，我们也要保证程序不会捕获到我们不希望捕获的异常，例如运行时异常。进一步讲，除非深思熟虑了，否则不要捕获 Throwable或者Error，这样很难保证我们能够正确程序处理 OutOfMemoryError 。</p>
</li>
<li><p><strong>不要生吞（swallow）异常。</strong>这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设！</p>
<p>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束。没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p>
<p>再来看看第二段代码 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 业务代码</span></span><br><span class="line">   <span class="comment">// …</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这段代码作为一段实验代码，它是没有任何问题的，但是在产品代码中，通常都不允许这样处理</strong>。在稍微复杂一点的生产系统中，标准出错（STERR）不是个合适的输出选项，因为你很难判断出到底输出到哪里去了 ，所以，最好使用产品日志，详细地输出到日志系统里。</p>
<p> 最后看下下面两段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readPreferences</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">     <span class="comment">//...perform operations... </span></span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">     <span class="comment">//...read the preferences file...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一段代码中，如果fileName是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。 因此，可以将上述代码改为如下形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readPreferences</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">    Objects. requireNonNull(filename);</span><br><span class="line">    <span class="comment">//...perform other operations... </span></span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">     <span class="comment">//...read the preferences file...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>应该遵循”Throw early, catch late “原则</strong></p>
<p>“Throw early”，在发现问题的时候，第一时间抛出，这样才能够更加清晰地反映问题。</p>
<p>“catch late”，在捕获异常后的处理上，最差的处理方式，就是前面提到的“生吞异常”，本质上其实是掩盖问题。<strong>如果实在不知道如何处理，可以选择保留原有异常的 cause 信息，直接再抛出或者构建新的异常抛出去</strong>。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。 </p>
</li>
</ul>
</li>
</ul>
<h4 id="自定义异常的注意事项"><a href="#自定义异常的注意事项" class="headerlink" title="自定义异常的注意事项"></a>自定义异常的注意事项</h4><ul>
<li><strong>考虑是否需要定义成Checked Exception</strong>，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类</li>
<li><strong>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。</strong>如果我们看 Java 的标准类库，你可能注意到类似 java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的</li>
</ul>
<h4 id="Java-的异常处理机制对性能的影响"><a href="#Java-的异常处理机制对性能的影响" class="headerlink" title="Java 的异常处理机制对性能的影响"></a>Java 的异常处理机制对性能的影响</h4><ul>
<li><p>try-catch代码段会产生额外的性能开销，或者换个角度说，它往往会影响JVM对代码进行优化</p>
<ul>
<li><p>建议仅捕获有必要的代码段，尽量不要一个大的try包住整段的代码。</p>
</li>
<li><p>不要利用异常控制代码流程,应该使用if,else,switch等。</p>
</li>
</ul>
</li>
<li><p>Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了</p>
<p>当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的Exception也是一种思路 。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>Exception和Error的异同</p>
<p><strong>相同点</strong>：Exception和Error都继承了Throwable类。</p>
<p><strong>不同点</strong>：<em>Exception</em>是程序正常运行中，可以预料的意外情况，可以也应该被捕获并进行相应的处理；<em>Error</em>是指在正常情况下，不大可能出现的情况，绝大部分的Error都会使应用程序处于非正常的、不可恢复的状态，不用也不能捕获。</p>
</li>
<li><p>异常处理应当遵循的以下几个原则</p>
<p>尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常。</p>
<p> 不要生吞（swallow）异常，不要简单使用printStackTrace()。</p>
<p>应该遵循”Throw early, catch late”原则。</p>
</li>
<li><p>自定义异常需要注意的事项</p>
<p>是否需要定义成Checked Exception。</p>
<p>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。</p>
</li>
<li><p>Java 的异常处理机制对性能的影响</p>
<p>try-catch代码段会产生额外的性能开销，建议仅捕获有必要的代码段，尽量不要一个大的try包住整段的代码，也不要利用异常控制代码流程,应该使用if,else,switch等。</p>
<p>Java异常处理机制每实例化一个Exception实例，会产生当前快照，产生一定的开销，当达到一定程度时，开销产生的影响不可忽略。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术36讲--final、finally、finalize比较</title>
    <url>/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2-final%E3%80%81finally%E3%80%81finalize%E6%AF%94%E8%BE%83.html</url>
    <content><![CDATA[<p>在Java语言中，有很多关键字非常类似，但是用途却相差很大，因此，有必要对其进行识别，理清其用法</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final可以用来修饰类、方法、变量，对于被final修饰的class来说，其代表该类不可以被继承扩展，而final修饰的变量则是不可以修改的， 对于被final修饰的方法来说，意味着该方法将是不可以被重写的（override） 。可以将方法或者类声明为final，这样就可以明确告知别人，这些行为是不许修改的。 </p>
<p>在Java核心类库及一些框架的源码中，可以发现相当一部分的类都被声明为final class，这样做可以有效避免API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。 其主要好处有以下两点</p>
<ul>
<li><p>使用final修饰参数或者变量，可以有效地避免意外赋值导致的编程错误</p>
</li>
<li><p>final变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要 </p>
<p>需要注意的是，<strong>final并不等同于immutable</strong> </p>
<p>来看下面一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">strList.add(<span class="string">"Hello"</span>);</span><br><span class="line">strList.add(<span class="string">"world"</span>);  </span><br><span class="line">List&lt;String&gt; unmodifiableStrList = List.of(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">unmodifiableStrList.add(<span class="string">"again"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>final只能约束strList这个引用不可以被赋值，但是strList对象行为不被final影响，添加元素等操作是完全正常的。</strong>如果希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面这个例子中，JDK 9提供的<code>List.of</code>方法创建的是不可变List，最后那句add会在运行时抛出异常。 </p>
</li>
</ul>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>finally是Java保证重点代码一定要被执行的一种机制。可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接等释放资源的操作</p>
<h4 id="fnalize"><a href="#fnalize" class="headerlink" title="fnalize"></a>fnalize</h4><p>finalize是基础类java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated。如果没有特别的原因，不要实现finalize方法，也不要指望利用它来进行资源回收。其原因有</p>
<ul>
<li>因为，finalize被设计成在对象<strong>被垃圾收集前</strong>调用，这就意味着实现了finalize方法的对象是个“特殊公民”，JVM要对它进行额外处理。finalize本质上成为了快速回收的阻碍者，可能导致你的对象经过多个垃圾收集周期才能被回收。正是由于finalize的执行是和垃圾收集关联在一起的，一旦实现了非空的finalize方法，就会导致相应对象回收呈现数量级上的变慢</li>
<li>要确保回收资源就是因为资源都是有限的，垃圾收集时间的不可预测，可能会极大加剧资源占用。这意味着对于消耗非常高频的资源，千万不要指望finalize去承担资源释放的主要职责</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven环境隔离应用场景及配置</title>
    <url>/Maven%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<p>在实际的项目中，我们经常会遇到各种各样的环境，大致可以分为以下四种：</p>
<ul>
<li>本地开发环境(Local)</li>
<li>开发环境(Dev)</li>
<li>测试环境(Beta)</li>
<li>线上环境(Prod)</li>
</ul>
<p>在这些环境中，其配置参数往往会有比较大的差异。例如：数据库地址、FTP服务器地址，这些可能都不一样。因此，我们有必要寻找一种合适的手段来解决它。Maven环境隔离就是一种隔离不同环境配置差异的可行方案。</p>
<h3 id="Mavan环境隔离的好处"><a href="#Mavan环境隔离的好处" class="headerlink" title="Mavan环境隔离的好处"></a>Mavan环境隔离的好处</h3><p>首先，一个比较重要的好处就是，通过Maven环境隔离，我们可以避免人工修改的弊端，减少重复劳动和出错概率。其次，通过Maven环境隔离，我们可以轻松分环境编译、打包以及部署代码。<br>鉴于以上最重要的两点，我们有必要尝试一下使用Maven环境隔离。</p>
<h3 id="Maven环境隔离配置"><a href="#Maven环境隔离配置" class="headerlink" title="Maven环境隔离配置"></a>Maven环境隔离配置</h3><p>为了使用Maven环境隔离，我们需要在Maven项目的<strong>pom.xml</strong>文件中进行一些必要的配置。</p>
<h4 id="配置resources节点"><a href="#配置resources节点" class="headerlink" title="配置resources节点"></a>配置resources节点</h4><p>在<strong>pom.xml</strong>文件的project节点下的build节点中增加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources.$&#123;deploy.type&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述的配置中，主要有以下两点需要注意：</p>
<ol>
<li><p>第一个resource节点配置的是各个环境中特有的，区别于其它环境的配置文件目录，其exclude节点声明排除了jsp这种文件类型，<code>${deploy.type}</code>则是一个变量，代表了不同的环境，在下文中将会讲解其配置。</p>
</li>
<li><p>第二个resource节点配置的则是各个环境所共有的配置文件目录。<br>通过在build节点增加上述配置，我们可以轻松共有公共配置文件，而对各个环境特有的配置进行单独修改。</p>
</li>
</ol>
<h4 id="配置profiles节点"><a href="#配置profiles节点" class="headerlink" title="配置profiles节点"></a>配置profiles节点</h4><p>在<strong>pom.xml</strong>文件的project节点下增加如下的profiles节点配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deploy.type</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">deploy.type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>beta<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deploy.type</span>&gt;</span>beta<span class="tag">&lt;/<span class="name">deploy.type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deploy.type</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">deploy.type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>观察上面的配置，可以看到：</p>
<ol>
<li>我们在profiles节点下增加了多个profile节点，通过profile节点，我们设置了三个环境：dev、beta、prod</li>
<li>在properties节点下我们设置前面的环境变量<code>${deploy.type}</code>的值，并且在第一个profile节点下设置activation节点下的activeByDefault值为<strong>true</strong>，将dev设置为默认的环境。</li>
<li>在完成以上配置之后，我们还要新建对应的文件夹，并将对于不同环境有差异的配置文件分离为多个文件。配置示例如下，可以看到公共的配置文件都放到了<strong>src/main/resources</strong>目录下，其余配置文件放在了<strong>src/main/resources.${deploy.type}</strong>目录下。<br><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/Maven/Maven%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB%E7%9B%AE%E5%BD%95.png" alt="配置文件"></li>
</ol>
<p>通过以上步骤，我们完成了Maven环境隔离的配置。</p>
<h3 id="IDEA中设置默认环境"><a href="#IDEA中设置默认环境" class="headerlink" title="IDEA中设置默认环境"></a>IDEA中设置默认环境</h3><p>在IDEA右侧Maven Projects，选中本地开发环境对应的开发环境，点击<strong>import change</strong>进行更新。<br><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/Maven/idea%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83.png" alt="idea设置默认环境"></p>
<h3 id="Maven环境隔离编译打包命令"><a href="#Maven环境隔离编译打包命令" class="headerlink" title="Maven环境隔离编译打包命令"></a>Maven环境隔离编译打包命令</h3><p>配置Maven环境隔离后，我们可以使用Maven环境隔离编译打包命令，实现定制打包，其参数为<code>-P{环境标识}</code></p>
<ol>
<li><p>开发环境</p>
<p><code>mvn clean package -Dmaven.test.skip=true -Pdev</code></p>
</li>
<li><p>测试环境</p>
<p><code>mvn clean package -Dmaven.test.skip=true -Pbeta</code></p>
</li>
<li><p>线上环境</p>
<p><code>mvn clean package -Dmaven.test.skip=true -Pprod</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven环境隔离</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术36讲--谈谈你对Java平台的理解</title>
    <url>/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Java%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3.html</url>
    <content><![CDATA[<h4 id="谈谈你对Java平台的理解"><a href="#谈谈你对Java平台的理解" class="headerlink" title="谈谈你对Java平台的理解"></a>谈谈你对Java平台的理解</h4><p>Java 本身是一种面向对象的语言，最显著的特性有两个方面</p>
<ul>
<li>另外就是垃圾收集，Java通过垃圾收集器回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。</li>
</ul>
<h4 id="Java是解释执行是否准确"><a href="#Java是解释执行是否准确" class="headerlink" title="Java是解释执行是否准确"></a>Java是解释执行是否准确</h4><p>​    对于“Java 是解释执行”这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的Oracle JDK提供的Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。 </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok快速入门</title>
    <url>/Lombok%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<p><strong>Lombok</strong>是一个工具，通过它可以使用简单注解来精简代码达到消除冗余代码的目的。</p>
<h4 id="Lombok的优点"><a href="#Lombok的优点" class="headerlink" title="Lombok的优点"></a>Lombok的优点</h4><ul>
<li>提高编码效率</li>
<li>使代码更简洁</li>
<li>消除冗长代码</li>
<li>避免修改字段名字时忘记修改方法名</li>
</ul>
<p>当然，要使用该工具必须要<em>IDE</em>支持才行。</p>
<h4 id="Lombok原理"><a href="#Lombok原理" class="headerlink" title="Lombok原理"></a>Lombok原理</h4><p><strong>Lombok</strong>支持了<em>JSR 269 Pluggable Annotation Processing API</em>，<em>javac</em>从Java6开始支持“JSR 269 API”规范，只要程序实现了该API，就能在javac运行的时候得到调用。</p>
<p>Lombok实现了“JSR 269 API”，在编译时，<em>javac</em>编译代码的具体流程如下</p>
<p><img src="https://east-java.oss-cn-hangzhou.aliyuncs.com/lombok/Lombok%E5%8E%9F%E7%90%86.png" alt="Lombok原理"></p>
<ol>
<li>首先，<em>javac</em>通过分析java源代码，生成抽象语法树(<em>AST</em>)</li>
<li>然后，<em>javac</em>会调用实现了“JSR 269”的Lombok注解处理器(<em>Lombok Annotation Processor</em>)，该处理器会使用<em>Lombok Annotation Handler</em>修改使用了Lombok注解的类相对应的抽象语法树(AST)</li>
<li>最后，javac对修改后的抽象语法树(Modified AST)进行分析，然后生成(Analyze and Generate)字节码文(Byte Code)  </li>
</ol>
<h4 id="使用Lombok"><a href="#使用Lombok" class="headerlink" title="使用Lombok"></a>使用Lombok</h4><p>本篇使用的<em>IDE</em>为<em>IDEA</em>，为了在项目中使用<strong>Lombok</strong>，需要做以下准备</p>
<ol>
<li><p>引入<strong>Lombok</strong>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em>IDE</em>安装<em>Lombok</em>插件<br>1)为了安装该插件，点击菜单<em>File</em>-&gt;<em>Settings…</em>，弹出<em>Settings</em>界面，选择<em>Plugins</em>选项<br><img src="https://east-java.oss-cn-hangzhou.aliyuncs.com/lombok/lombok%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.png" alt="Settings界面"><br>​     2)  选择右侧的<em>Browse repositories</em>按钮，在弹出的界面中搜索<em>Lombok</em>，点击<em>Install</em>，然后重启<em>IDE</em>即可<br><img src="https://east-java.oss-cn-hangzhou.aliyuncs.com/lombok/%E6%90%9C%E7%B4%A2lombok%E6%8F%92%E4%BB%B6.png" alt="安装Lombok插件"></p>
</li>
<li>添加注解<br>|        注解         |                             作用                             |<br>| :—————–: | :———————————————————-: |<br>|        @Data        | @Data注解包含了@Getter、@Setter、@EqualsAndHashCode、@ToString，同时还增加了protected的canEqual方法 |<br>|       @Getter       |                                                              |<br>|       @Setter       |                                                              |<br>| @NoArgsConstructor  |                          无参构造器                          |<br>| @AllArgsConstructor |                       所有参数的构造器                       |<br>|      @ToString      |        可以包含exclude属性排除某字段，of只要某些字段         |<br>| @EqualsAndHashCode  |        可以包含exclude属性排除某字段，of只要某些字段         |<br>|       @Slf4j        | 可以直接使用log对象相关方法打印日志（项目使用logback日志框架时使用） |<br>|       @Log4j        | 可以直接使用log对象相关方法打印日志 （项目使用log4j日志框架时使用） |</li>
</ol>
<p>下面来看一个示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(of=<span class="string">"id"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer parentId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sortOrder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，注解<em>@Getter</em>，<em>@Setter</em>分别用于生成<em>Pojo</em>字段的<em>getter</em>和<em>setter</em>方法，<em>@NoArgsConstructor</em>用于生成无参构造器，<em>@AllArgsConstructor</em>用于生成包含全部参数的构造器，而<em>@EqualsAndHashCode(of=”id”)</em>则用于生成该<em>Pojo</em>的<em>equals</em>和<em>hashCode</em>方法，<em>of</em>属性指定了在这两个方法中，只使用字段<em>id</em>，当<em>id</em>相同时，则表示两实例是同一个。</p>
<h4 id="使用Lombok时的注意事项"><a href="#使用Lombok时的注意事项" class="headerlink" title="使用Lombok时的注意事项"></a>使用Lombok时的注意事项</h4><p>尽管<strong>Lombok</strong>如此好用，但是还是要注意正确使用<em>Lombok</em>，下面是使用过程中的一些注意事项</p>
<ul>
<li>在类需要序列化、反序列化详细控制字段时慎用</li>
<li>使用<strong>Lombok</strong>虽然能够省去手动创建Getter和Setterf方法等繁琐，但是降低了源代码文件的可读性和完整性，降低了阅读源代码的舒适度</li>
<li>使用@Slf4j还是@Log4j看项目使用的日志框架</li>
<li>在适当的地方使用<strong>Lombok</strong>，例如<strong>POJO</strong></li>
</ul>
]]></content>
      <categories>
        <category>Lombok</category>
      </categories>
      <tags>
        <tag>Lombok入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础入门</title>
    <url>/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h3 id="Redis快速入门"><a href="#Redis快速入门" class="headerlink" title="Redis快速入门"></a>Redis快速入门</h3><h4 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h4><p><strong>Redis</strong>全称为<strong>REmote  DIctionary Server</strong>，即远程的字典服务，是一个使用ANSI C语言编写的开源数据库，其主要特点是</p>
<ol>
<li>是一个高性能的key-value数据库</li>
<li>是一个内存数据库，支持数据的持久化</li>
</ol>
<h4 id="Redis相关网站"><a href="#Redis相关网站" class="headerlink" title="Redis相关网站"></a>Redis相关网站</h4><p><strong>Redis</strong>的官方网站地址为<a href="https://redis.io" target="_blank" rel="noopener">Redis官网</a>，其中国官网为<a href="http://redis.cn" target="_blank" rel="noopener">Redis中国</a>。官网提供了<strong>Java</strong>、<strong>C\C++</strong>、<strong>C#</strong>、<strong>PHP</strong>、<strong>JavaScript</strong>、<strong>Perl</strong>、<strong>Object-C</strong>、<strong>Python</strong>、<strong>Ruby</strong>、<strong>Erlang</strong>等语言的客户端。对于Java语言来说，存在多种客户端，实际开发过程中，比较常用的是一种被称为<strong>Jedis</strong>的客户端。</p>
<h4 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h4><p><strong>Redis</strong>常用的数据类型主要有5种</p>
<ul>
<li>string(字符串)</li>
<li>list(链表)</li>
<li>set(无序集合)</li>
<li>sorted set(有序集合)</li>
<li>hash(哈希)</li>
</ul>
<h4 id="Redis版本说明"><a href="#Redis版本说明" class="headerlink" title="Redis版本说明"></a>Redis版本说明</h4><p><strong>Redis</strong>官方并没有提供<strong>Redis</strong>的Windows版本，其Windows下的版本由<strong>Microsoft Open Tech group</strong>维护，可点击链接<a href="https://github.com/MicrosoftArchive/redis" target="_blank" rel="noopener">Redis的Windows版本</a>下载。</p>
<h3 id="Redis安装与启动"><a href="#Redis安装与启动" class="headerlink" title="Redis安装与启动"></a>Redis安装与启动</h3><p>现在，我们开始在Windows 7平台下安装<strong>Redis</strong>，访问前面一节中的<strong>Redis</strong>下载地址，下载名称为<strong>Redis-x64-2.8.2402.zip</strong>的压缩包。</p>
<h4 id="Redis解压缩完成安装"><a href="#Redis解压缩完成安装" class="headerlink" title="Redis解压缩完成安装"></a>Redis解压缩完成安装</h4><p>下载完成后，将该压缩包移动到适当的目录下解压缩即可完成安装。此时，我们启动两个<strong>cmd</strong>窗口，分别执行服务端启动以及客户端连接，先来看一下单实例<strong>Redis</strong>情况下的相关启动关闭命令。</p>
<h4 id="Redis单实例服务端启动"><a href="#Redis单实例服务端启动" class="headerlink" title="Redis单实例服务端启动"></a>Redis单实例服务端启动</h4><ol>
<li>直接执行命令：<code>redis-server</code></li>
<li>指定配置文件启动：<code>redis-server ${redis.conf}</code></li>
<li>指定端口启动：<code></code>redis-server –port ${port}` </li>
</ol>
<h4 id="Redis单实例客户端启动"><a href="#Redis单实例客户端启动" class="headerlink" title="Redis单实例客户端启动"></a>Redis单实例客户端启动</h4><ol>
<li>直接执行命令：<code>redis-cli</code></li>
<li>指定端口启动客户端连接：<code>redis-cli -p ${port}</code></li>
<li>指定ip启动客户端连接：<code>redis-cli-h ${ip}</code></li>
<li>输入密码启动客户端连接：<code>redis-cli -a ${password}</code></li>
</ol>
<h4 id="Redis单实例服务端及客户端关闭"><a href="#Redis单实例服务端及客户端关闭" class="headerlink" title="Redis单实例服务端及客户端关闭"></a>Redis单实例服务端及客户端关闭</h4><p>在客户端执行<code>quit</code>命令后，再按实际情况执行关闭命令</p>
<ol>
<li>执行命令关闭默认端口服务：<code>redis-cli shutdown</code></li>
<li>指定端口关闭服务：<code>redis-cli -p ${port} shutdown</code></li>
<li>指定ip关闭服务：<code>redis-cli -h {ip} shutdown</code></li>
</ol>
<p><strong>注意：若Redis服务端不采用默认方式启动，则客户端启动和关闭时要指定相关参数。例如：服务端执行6380端口启动，则客户端启动和关闭也要指定相同的端口，其余情况类似</strong> 。</p>
<h4 id="Redis单实例环境验证"><a href="#Redis单实例环境验证" class="headerlink" title="Redis单实例环境验证"></a>Redis单实例环境验证</h4><ol>
<li>在打开客户端的<strong>cmd</strong>下执行命令：<code>ping</code>，若返回<strong>PONG</strong>，则服务正常启动</li>
<li>执行redis set命令，使用redis get命令获取到值。若一切正常，则服务正常启动</li>
</ol>
<h4 id="Redis服务端和客户端启动"><a href="#Redis服务端和客户端启动" class="headerlink" title="Redis服务端和客户端启动"></a>Redis服务端和客户端启动</h4><ol>
<li>启动<strong>cmd</strong>，切换到解压缩的<strong>Redis</strong>根目录下，输入<code>redis-server.exe</code>命令启动<strong>Redis</strong>服务端，若启动成功，则显示如下信息</li>
</ol>
<p><img src="https://east-java.oss-cn-hangzhou.aliyuncs.com/Redis/Redis%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8.png" alt="Redis服务端启动"></p>
<p>可以看到，<strong>Redis</strong>服务的进程ID为7444，端口号为6379。</p>
<ol start="2">
<li>然后，我们再打开一个<strong>cmd</strong>窗口，和前面一样，我们进入<strong>Redis</strong>的根目录，输入<code>redis-cli</code>，然后输入<code>set a b</code>并回车此时返回<strong>OK</strong>，再输入<code>keys *</code>，此时返回键”a”，接着，输入<code>get a</code>，得到键a的值”b”</li>
</ol>
<p><img src="https://east-java.oss-cn-hangzhou.aliyuncs.com/Redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8.png" alt="Redis客户端启动"></p>
<p>接着，客户端<strong>cmd</strong>再输入命令<code>set x x</code>回车，再输入命令<code>get x</code>，返回键x的值”x”。输入命令<code>keys *</code>，返回两个键”x”和“a”。</p>
<p><img src="https://east-java.oss-cn-hangzhou.aliyuncs.com/Redis/%E5%AE%A2%E6%88%B7%E7%AB%AFkey%E6%9F%A5%E8%AF%A2.png" alt="keys查询"></p>
<p>通过上述操作的验证，我们确定<strong>Redis</strong>服务和客户端连接正常。</p>
<h3 id="Redis基础命令"><a href="#Redis基础命令" class="headerlink" title="Redis基础命令"></a>Redis基础命令</h3><h4 id="Redis基础命令作用说明"><a href="#Redis基础命令作用说明" class="headerlink" title="Redis基础命令作用说明"></a>Redis基础命令作用说明</h4><p><strong>Redis</strong>基础命令主要是一些系统级别的命令。本节先介绍介绍6个常用的命令，其作用如下</p>
<ul>
<li><code>info</code>命令：该命令会罗列出<strong>Redis</strong>服务端，客户端等系统参数，结果如下</li>
<li><code>flushdb</code>命令：清除当前数据库的数据</li>
<li><code>flushall</code>命令：清除所有数据库的数据</li>
<li><code>dbsize</code>命令：返回当前数据库的key的数量</li>
<li><code>save</code>命令：人工触发对<strong>Redis</strong>数据持久化</li>
<li><code>quit</code>命令：退出客户端连接</li>
</ul>
<h4 id="命令应用实例"><a href="#命令应用实例" class="headerlink" title="命令应用实例"></a>命令应用实例</h4><p>通过上面的说明，我们对<strong>Redis</strong>基础命令有了一定的了解。接下来，我们来实际操作一遍。首先，我们先在客户端<strong>cmd</strong>输入命令<code>info</code>，得到如下结果</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server</span></span><br><span class="line"><span class="attr">redis_version:</span><span class="number">2.8</span><span class="number">.2402</span></span><br><span class="line"><span class="attr">redis_git_sha1:</span><span class="number">00000000</span></span><br><span class="line"><span class="attr">redis_git_dirty:</span><span class="number">0</span></span><br><span class="line"><span class="attr">redis_build_id:</span><span class="string">b2a45a9622ff23b7</span></span><br><span class="line"><span class="attr">redis_mode:</span><span class="string">standalone</span></span><br><span class="line"><span class="attr">os:</span><span class="string">Windows</span></span><br><span class="line"><span class="attr">arch_bits:</span><span class="number">64</span></span><br><span class="line"><span class="attr">multiplexing_api:</span><span class="string">winsock_IOCP</span></span><br><span class="line"><span class="attr">process_id:</span><span class="number">8388</span></span><br><span class="line"><span class="attr">run_id:</span><span class="number">16295</span><span class="string">d3cba108dc92e8aeb13543f7f0cc931ca5b</span></span><br><span class="line"><span class="attr">tcp_port:</span><span class="number">6379</span></span><br><span class="line"><span class="attr">uptime_in_seconds:</span><span class="number">608</span></span><br><span class="line"><span class="attr">uptime_in_days:</span><span class="number">0</span></span><br><span class="line"><span class="attr">hz:</span><span class="number">10</span></span><br><span class="line"><span class="attr">lru_clock:</span><span class="number">10029495</span></span><br><span class="line"><span class="attr">config_file:</span><span class="attr">D:\Redis-x64-2.8.2402\redis.windows.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line"><span class="attr">connected_clients:</span><span class="number">1</span></span><br><span class="line"><span class="attr">client_longest_output_list:</span><span class="number">0</span></span><br><span class="line"><span class="attr">client_biggest_input_buf:</span><span class="number">0</span></span><br><span class="line"><span class="attr">blocked_clients:</span><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line"><span class="attr">used_memory:</span><span class="number">953168</span></span><br><span class="line"><span class="attr">used_memory_human:</span><span class="number">930.83</span><span class="string">K</span></span><br><span class="line"><span class="attr">used_memory_rss:</span><span class="number">919520</span></span><br><span class="line"><span class="attr">used_memory_peak:</span><span class="number">953168</span></span><br><span class="line"><span class="attr">used_memory_peak_human:</span><span class="number">930.83</span><span class="string">K</span></span><br><span class="line"><span class="attr">used_memory_lua:</span><span class="number">36864</span></span><br><span class="line"><span class="attr">mem_fragmentation_ratio:</span><span class="number">0.96</span></span><br><span class="line"><span class="attr">mem_allocator:</span><span class="string">dlmalloc-2.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line"><span class="attr">loading:</span><span class="number">0</span></span><br><span class="line"><span class="attr">rdb_changes_since_last_save:</span><span class="number">0</span></span><br><span class="line"><span class="attr">rdb_bgsave_in_progress:</span><span class="number">0</span></span><br><span class="line"><span class="attr">rdb_last_save_time:</span><span class="number">1536755543</span></span><br><span class="line"><span class="attr">rdb_last_bgsave_status:</span><span class="string">ok</span></span><br><span class="line"><span class="attr">rdb_last_bgsave_time_sec:</span><span class="bullet">-1</span></span><br><span class="line"><span class="attr">rdb_current_bgsave_time_sec:</span><span class="bullet">-1</span></span><br><span class="line"><span class="attr">aof_enabled:</span><span class="number">0</span></span><br><span class="line"><span class="attr">aof_rewrite_in_progress:</span><span class="number">0</span></span><br><span class="line"><span class="attr">aof_rewrite_scheduled:</span><span class="number">0</span></span><br><span class="line"><span class="attr">aof_last_rewrite_time_sec:</span><span class="bullet">-1</span></span><br><span class="line"><span class="attr">aof_current_rewrite_time_sec:</span><span class="bullet">-1</span></span><br><span class="line"><span class="attr">aof_last_bgrewrite_status:</span><span class="string">ok</span></span><br><span class="line"><span class="attr">aof_last_write_status:</span><span class="string">ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line"><span class="attr">total_connections_received:</span><span class="number">1</span></span><br><span class="line"><span class="attr">total_commands_processed:</span><span class="number">0</span></span><br><span class="line"><span class="attr">instantaneous_ops_per_sec:</span><span class="number">0</span></span><br><span class="line"><span class="attr">total_net_input_bytes:</span><span class="number">14</span></span><br><span class="line"><span class="attr">total_net_output_bytes:</span><span class="number">0</span></span><br><span class="line"><span class="attr">instantaneous_input_kbps:</span><span class="number">0.00</span></span><br><span class="line"><span class="attr">instantaneous_output_kbps:</span><span class="number">0.00</span></span><br><span class="line"><span class="attr">rejected_connections:</span><span class="number">0</span></span><br><span class="line"><span class="attr">sync_full:</span><span class="number">0</span></span><br><span class="line"><span class="attr">sync_partial_ok:</span><span class="number">0</span></span><br><span class="line"><span class="attr">sync_partial_err:</span><span class="number">0</span></span><br><span class="line"><span class="attr">expired_keys:</span><span class="number">0</span></span><br><span class="line"><span class="attr">evicted_keys:</span><span class="number">0</span></span><br><span class="line"><span class="attr">keyspace_hits:</span><span class="number">0</span></span><br><span class="line"><span class="attr">keyspace_misses:</span><span class="number">0</span></span><br><span class="line"><span class="attr">pubsub_channels:</span><span class="number">0</span></span><br><span class="line"><span class="attr">pubsub_patterns:</span><span class="number">0</span></span><br><span class="line"><span class="attr">latest_fork_usec:</span><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="attr">role:</span><span class="string">master</span></span><br><span class="line"><span class="attr">connected_slaves:</span><span class="number">0</span></span><br><span class="line"><span class="attr">master_repl_offset:</span><span class="number">0</span></span><br><span class="line"><span class="attr">repl_backlog_active:</span><span class="number">0</span></span><br><span class="line"><span class="attr">repl_backlog_size:</span><span class="number">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset:</span><span class="number">0</span></span><br><span class="line"><span class="attr">repl_backlog_histlen:</span><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line"><span class="attr">used_cpu_sys:</span><span class="number">0.06</span></span><br><span class="line"><span class="attr">used_cpu_user:</span><span class="number">0.08</span></span><br><span class="line"><span class="attr">used_cpu_sys_children:</span><span class="number">0.00</span></span><br><span class="line"><span class="attr">used_cpu_user_children:</span><span class="number">0.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line"><span class="attr">db0:</span><span class="string">keys=2,expires=0,avg_ttl=0</span></span><br></pre></td></tr></table></figure>
<p>注意到最后一个配置<strong>Keyspace</strong>，其<strong>db0</strong>有2个key。打开<strong>Redis</strong>根目录下的<strong>redis.windows.conf</strong>文件，找到下面一段话，可以看到数据库数量默认有16个，其<strong>dbId</strong>介于0到数据库数量减1，且其默认的数据库为<strong>db0</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"># dbid is a number between 0 and &apos;databases&apos;-1</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>
<p>现在，我们使用命令<code>select 1</code>切换到另一个<strong>dbId</strong>为1的数据库，输入命令<code>keys *</code>，返回提示<strong>(empty list or set)</strong>，表明该数据库没有数据。然后，我们输入命令<code>set 1 1</code>并回车，再次使用命令<code>info</code>查看<strong>Redis</strong>相关信息，可以发现最后一项<strong>Keyspace</strong>增加了<strong>db1</strong>的内容。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line"><span class="attr">db0:</span><span class="string">keys=2,expires=0,avg_ttl=0</span></span><br><span class="line"><span class="attr">db1:</span><span class="string">keys=1,expires=0,avg_ttl=0</span></span><br></pre></td></tr></table></figure>
<p>现在，我们想清除<strong>db1</strong>的数据。执行<code>flushdb</code>命令，使用命令<code>keys *</code>查询数据，可以看到<strong>(empty list or set)</strong>提示，此时执行<code>info</code>命令， 则当前结果显示，<strong>db1</strong>的内容已经不存在了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line"><span class="attr">db0:</span><span class="string">keys=2,expires=0,avg_ttl=0</span></span><br></pre></td></tr></table></figure>
<p>我们还想清除<strong>db1</strong>的数据，可以运行<code>flushall</code>命令，再次执行<code>info</code>命令后发现<strong>Keyspace</strong>没有内容了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Keyspace</span></span><br></pre></td></tr></table></figure>
<p>执行<code>dbsize</code>命令，查看当前数据库的key数量，结果为0</p>
<h3 id="Redis-键命令"><a href="#Redis-键命令" class="headerlink" title="Redis 键命令"></a>Redis 键命令</h3><h4 id="Redis键命令作用说明"><a href="#Redis键命令作用说明" class="headerlink" title="Redis键命令作用说明"></a>Redis键命令作用说明</h4><p>在<strong>Redis</strong>中，键命令是用于管理<strong>Redis</strong>各种键值对的命令。本节，我们学习8个命令</p>
<ul>
<li><code>del</code>命令：删除指定键，若成功返回1，否则返回0，其命令格式为<code>del key</code></li>
<li><code>exists</code>命令：判断指定键是否存在，存在返回1，否则返回0，其命令格式为<code>exists key</code></li>
<li><code>ttl</code>命令：查看key的剩余生存时间（单位是秒），若返回-1，表示无过期时间，若返回-2，则表示该键不存在，其命令格式为<code>ttl key</code></li>
<li><code>expire</code>命令：设置键的过期时间，其命令格式为<code>expire key time</code> </li>
<li><code>randomkey</code>命令：产生随机key，直接执行<code>randomkey</code>即可</li>
<li><code>rename</code>命令：用于重命名一个key，若key已经存在，则覆盖原有存在的key，其命令格式为<code>rename key newkey</code></li>
<li><code>renamenx</code>命令：若将某个key名称重命名为一个已经存在的key，返回0，重命名不成功，其命令格式为<code>renamenx key newkye</code></li>
<li><code>type</code>命令：返回key存储的值类型，其命令格式为<code>type key</code></li>
<li><code>keys</code>命令：查找所有符合给定模式( pattern)的 key，其命令格式为<code>keys pattern</code>。常用的形式为<code>keys *</code>，该命令会列出所有key</li>
</ul>
<h4 id="命令应用实例-1"><a href="#命令应用实例-1" class="headerlink" title="命令应用实例"></a>命令应用实例</h4><ol>
<li>首先，先执行命令<code>set test test</code>，再执行命令<code>keys *</code>,此时输出”test”。</li>
<li>其次，我们删除键test，执行命令<code>del test</code>，此时返回“OK”，表示键test被成功删除</li>
<li>然后，执行命令<code>set a a</code>，<code>set b b</code>创建两个键值对，执行命令<code>ttl a</code>，返回-1，表示该键没有过期时间，执行<code>expire a 10</code>，表示设置该键的过期时间为10秒，不断执行命令<code>ttl a</code>，当返回-2时，表示该键已经过期，不存在了。</li>
<li>接着，我们重命名键a，执行命令<code>rename a m</code>，将键a改为键m，此时执行命令<code>get m</code>，取得原键a的值”a”</li>
<li>最后，我们执行命令<code>renamenx m b</code>，由于该键b已经存在，返回0，重命名失败。而如果使用<code>rename a b</code>则会将原来的键b覆盖掉，此时执行命令<code>get b</code>，返回结果“a”</li>
</ol>
<h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><p>前面说过，<strong>Redis</strong>有5种常用的数据类型，下面就一一介绍各种数据结构的主要命令</p>
<h4 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h4><p><strong>String</strong>是<strong>Redis</strong>最基础的数据类型，一个key对应一个 value。可以包含任何数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>set</strong> key value</td>
<td style="text-align:center">设置字符串的值</td>
<td style="text-align:center"><strong>set</strong> a a，<strong>set</strong> word wordword</td>
</tr>
<tr>
<td style="text-align:center"><strong>setex</strong> key time value</td>
<td style="text-align:center">设置字符串值的同时设置过期时间(单位：秒)</td>
<td style="text-align:center"><strong>setex</strong> c 100 c</td>
</tr>
<tr>
<td style="text-align:center"><strong>psetex</strong> key time value</td>
<td style="text-align:center">设置字符串值的同时设置过期时间(单位：毫秒)</td>
<td style="text-align:center"><strong>psetex</strong> d 10000 d</td>
</tr>
<tr>
<td style="text-align:center"><strong>get</strong> key</td>
<td style="text-align:center">获取字符串名称为key的值，若key不存在，则返回nil，表示不存在</td>
<td style="text-align:center"><strong>get</strong> e</td>
</tr>
<tr>
<td style="text-align:center"><strong>getrange</strong> key begin end</td>
<td style="text-align:center">截取获取名称为key的字符串，起始从0开始</td>
<td style="text-align:center"><strong>getrange</strong> word 0 1,返回wo</td>
</tr>
<tr>
<td style="text-align:center"><strong>getset</strong> key newValue</td>
<td style="text-align:center">获取名称为key的字符串，并设置新值，返回字符串旧值</td>
<td style="text-align:center"><strong>getset</strong> a aa，返回”a”</td>
</tr>
<tr>
<td style="text-align:center"><strong>mset</strong>  key1 value1 key2 value2…</td>
<td style="text-align:center">批量设置多个key-value对</td>
<td style="text-align:center"><strong>mset</strong>   a1 a1 b1 b1</td>
</tr>
<tr>
<td style="text-align:center"><strong>mget</strong> key1 key2…</td>
<td style="text-align:center">批量获得多个名称为key的value的值</td>
<td style="text-align:center"><strong>mget</strong> a1 b1</td>
</tr>
<tr>
<td style="text-align:center"><strong>setnx</strong> key value</td>
<td style="text-align:center">这个命令会判断key是否已经存在，若已经存在，则设置字符串的值失败，返回0，否则成功，返回1</td>
<td style="text-align:center"><strong>setnx</strong> a newvalue失败，<strong>setnx</strong> newvalue newvalue成功</td>
</tr>
<tr>
<td style="text-align:center"><strong>strlen</strong> key</td>
<td style="text-align:center">计算字符串长度，返回字符串长度</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>msetnx</strong> key1 value1 key2 value2</td>
<td style="text-align:center">批量设置多个key-value对 ，只要多个当中的其中一个key设置value失败，则返回0，否则返回空</td>
<td style="text-align:center"><strong>msetnx</strong> nn nn uu uu</td>
</tr>
<tr>
<td style="text-align:center"><strong>incr</strong> key</td>
<td style="text-align:center">若值为数值型，可以使用该命令实现递增</td>
<td style="text-align:center"><strong>set</strong> 1 1; <strong>incr</strong> 1得到2,以此类推</td>
</tr>
<tr>
<td style="text-align:center"><strong>incrby</strong> key step</td>
<td style="text-align:center">该命令可以设置步长，按步长大小递增</td>
<td style="text-align:center"><strong>incrby</strong> 1 100得到102</td>
</tr>
<tr>
<td style="text-align:center"><strong>decr</strong> key</td>
<td style="text-align:center">若值为数值型，可以使用该命令实现递减</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>decrby</strong> key step</td>
<td style="text-align:center">该命令可以设置步长，按步长大小递减</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>append</strong> key stringvalue</td>
<td style="text-align:center">追加字符串</td>
<td style="text-align:center"><strong>append</strong> a world;返回追加后新字符串的长度</td>
</tr>
</tbody>
</table>
<h4 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希(hash)"></a>哈希(hash)</h4><p>哈希(hash)是一个键值(key=&gt;value)对集合。哈希(hash)是一个string类型的field和value的映射表，特别适合用于存储对象 。</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>hset</strong> key field value</td>
<td style="text-align:center">设置hash的key及其field value的值</td>
<td style="text-align:center"><strong>hset</strong> map name jim，<strong>hset</strong> age 18</td>
</tr>
<tr>
<td style="text-align:center"><strong>hexists</strong> key field</td>
<td style="text-align:center">查看key下的field是否存在，若不存在返回0，存在返回1</td>
<td style="text-align:center"><strong>hexists</strong> map name 返回1</td>
</tr>
<tr>
<td style="text-align:center"><strong>hget</strong> key field</td>
<td style="text-align:center">可以获取field的value值</td>
<td style="text-align:center"><strong>hget</strong> map name得到值“jim”</td>
</tr>
<tr>
<td style="text-align:center"><strong>hgetall</strong> key</td>
<td style="text-align:center">获取key中的所有值</td>
<td style="text-align:center"><strong>hgetall</strong> map返回“name” “jim” “age” “18”</td>
</tr>
<tr>
<td style="text-align:center"><strong>hkeys</strong> key</td>
<td style="text-align:center">获取key中的所有field</td>
<td style="text-align:center"><strong>hkeys</strong> map返回“name” “age”</td>
</tr>
<tr>
<td style="text-align:center"><strong>hvals</strong> key</td>
<td style="text-align:center">获取key中的所有value</td>
<td style="text-align:center"><strong>hvals</strong> map返回“jim” “18”</td>
</tr>
<tr>
<td style="text-align:center"><strong>hlen</strong> key</td>
<td style="text-align:center">获取key中field数量</td>
<td style="text-align:center"><strong>hlen</strong> map返回2</td>
</tr>
<tr>
<td style="text-align:center"><strong>hmget</strong> key field1 field2</td>
<td style="text-align:center">获取多个field对应的value</td>
<td style="text-align:center"><strong>hmget</strong>  map name age返回“jim” “18”</td>
</tr>
<tr>
<td style="text-align:center"><strong>hmset</strong> key field1 value1 field2 value2</td>
<td style="text-align:center">批量设置key的多个field-value</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>hdel</strong> field1 field2</td>
<td style="text-align:center">批量删除多个field</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>hsetnx</strong> key field value</td>
<td style="text-align:center">若field存在，则设置value值失败</td>
</tr>
</tbody>
</table>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h4><p>列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。 </p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>lpush</strong> key value1 value2 value3</td>
<td style="text-align:center">给名称为key的列表添加多个值</td>
<td style="text-align:center"><strong>lpush</strong> list 1 2 3 4</td>
</tr>
<tr>
<td style="text-align:center"><strong>llen</strong> key</td>
<td style="text-align:center">获取列表长度</td>
<td style="text-align:center"><strong>llen</strong> list得到4</td>
</tr>
<tr>
<td style="text-align:center"><strong>lrange</strong> key begin end</td>
<td style="text-align:center">获取名称为key的列表多个值，越后面push的index值越小</td>
<td style="text-align:center"><strong>lrange</strong>  list 0 1，得到“4” “3”</td>
</tr>
<tr>
<td style="text-align:center"><strong>lset</strong> KEY index value</td>
<td style="text-align:center">设置列表中INDEX对应的值</td>
<td style="text-align:center"><strong>lset</strong> list 0 50</td>
</tr>
<tr>
<td style="text-align:center"><strong>lindex </strong>key index</td>
<td style="text-align:center">获取列表中对应索引的值</td>
<td style="text-align:center"><strong>lindex</strong> list 0 ，得到50</td>
</tr>
<tr>
<td style="text-align:center"><strong>lpop</strong> KEY</td>
<td style="text-align:center">移除列表中索引最小的value</td>
<td style="text-align:center"><strong>lpop</strong> list ，移除50</td>
</tr>
<tr>
<td style="text-align:center"><strong>rpop</strong> KEY</td>
<td style="text-align:center">移除列表中索引最大的value</td>
<td style="text-align:center"><strong>rpop</strong> list，移除1</td>
</tr>
</tbody>
</table>
<h4 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h4><p><strong>Redis</strong>的<strong>Set</strong>是<strong>String</strong>类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>sadd</strong> key member1 member2</td>
<td style="text-align:center">给集合添加元素,若元素已经存在，则添加失败</td>
<td style="text-align:center"><strong>sadd</strong> set1 a b c d，<strong>sadd</strong> set2 e f  c d</td>
</tr>
<tr>
<td style="text-align:center"><strong>scard</strong> key</td>
<td style="text-align:center">获取集合元素数量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>smembers</strong> key</td>
<td style="text-align:center">获取集合元素</td>
<td style="text-align:center"><strong>smembers</strong> set1，返回“a” “b” “c” “d”</td>
</tr>
<tr>
<td style="text-align:center"><strong>sdiff</strong> key1 key2</td>
<td style="text-align:center">获取两个集合的差集</td>
<td style="text-align:center"><strong>sdiff</strong> set1 set2返回 “a” “b”，<strong>sdiff</strong> set2 set1返回 “e” “f”</td>
</tr>
<tr>
<td style="text-align:center"><strong>sinter</strong> key1 key2</td>
<td style="text-align:center">获取两个集合的交集</td>
<td style="text-align:center"><strong>sinter</strong> set1 set2返回”c” “d”</td>
</tr>
<tr>
<td style="text-align:center"><strong>sunion</strong> key1 key2</td>
<td style="text-align:center">获取两个集合的并集</td>
<td style="text-align:center"><strong>sunion</strong> set1 set2返回”a” “b” “c” “d” “e” “f”</td>
</tr>
<tr>
<td style="text-align:center"><strong>srandmember</strong> key number</td>
<td style="text-align:center">获取集合中任意number个元素</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>sismember</strong> key member</td>
<td style="text-align:center">判断value是否是该集合的元素，是则返回1，否则返回0</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>srem</strong> key member1 member2</td>
<td style="text-align:center">移除集合中的一个或多个元素</td>
<td style="text-align:center"><strong>srem</strong> set1 a b返回”c” “d”</td>
</tr>
<tr>
<td style="text-align:center"><strong>spop</strong> key</td>
<td style="text-align:center">移除集合中的任意一个元素并返回被移除的元素</td>
<td style="text-align:center"><strong>spop</strong> set1 返回”c”或“d”</td>
</tr>
</tbody>
</table>
<h4 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合(sorted set)"></a>有序集合(sorted set)</h4><p>有序集合(sorted set)和集合(set) 一样也是String类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。<strong>Redis</strong>正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合(sorted set)的成员是唯一的,但分数(score)却可以重复</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>zadd</strong> key score1 member1  score2 member2</td>
<td style="text-align:center">给有序集合添加元素，元素在集合中存在则更新对应score</td>
<td style="text-align:center"><strong>zadd</strong> sortedset1 100 a 200 b 300 c</td>
</tr>
<tr>
<td style="text-align:center"><strong>zcard</strong> key</td>
<td style="text-align:center">获取有序集合元素个数</td>
<td style="text-align:center"><strong>zcard</strong> sortedset1返回3</td>
</tr>
<tr>
<td style="text-align:center"><strong>zscore</strong> key member</td>
<td style="text-align:center">返回member的值</td>
<td style="text-align:center"><strong>zscore</strong> sortedset1 a返回100</td>
</tr>
<tr>
<td style="text-align:center"><strong>zcount</strong> key value1 value2</td>
<td style="text-align:center">返回有序集合中value值介于value1和value2之间的数</td>
<td style="text-align:center"><strong>zcount</strong>  sortedset1  0 220返回2</td>
</tr>
<tr>
<td style="text-align:center"><strong>zrank</strong> key member</td>
<td style="text-align:center">返回有序集合member的索引值</td>
<td style="text-align:center"><strong>zrank</strong> sortedset1  a返回0</td>
</tr>
<tr>
<td style="text-align:center"><strong>zincrby</strong> key step member</td>
<td style="text-align:center">按给定的步长让有序集合中的member的值递增</td>
<td style="text-align:center"><strong>zincrby</strong> sortedset1 1000 a返回1100</td>
</tr>
<tr>
<td style="text-align:center"><strong>zrange</strong> key begin end withscores</td>
<td style="text-align:center">获得有序集合索引值从begin到end的元素</td>
<td style="text-align:center"><strong>zrange</strong> sortedset1 0 100返回“b” “200” “a” “100” “c ” “1100”</td>
</tr>
</tbody>
</table>
<h3 id="Redis报错解决"><a href="#Redis报错解决" class="headerlink" title="Redis报错解决"></a>Redis报错解决</h3><p>启动<strong>Redis</strong>时，可能会报如下错误</p>
<blockquote>
<p>  The Windows version of Redis allocates a memory mapped heap for sharing with</p>
<p> `the forked process used for persistence operations. In order to share this</p>
<p>  memory, Windows allocates from the system paging file a portion equal to the</p>
<p>  size of the Redis heap. At this time there is insufficient contiguous free</p>
<p> space available in the system paging file for this operation (Windows error</p>
<p> 0x5AF). To work around this you may either increase the size of the system</p>
<p>  paging file, or decrease the size of the Redis heap with the –maxheap flag.</p>
<p> Sometimes a reboot will defragment the system paging file sufficiently for</p>
<p>  this operation to complete successfully.</p>
<p>  Please see the documentation included with the binary distributions for more</p>
<p> details on the –maxheap flag</p>
</blockquote>
<p> 大概意思是：没有足够的可用空间，可以增加系统的大小分页文件，或减少Redis的堆的大小</p>
<p>使用<strong>–maxheap</strong>标志。</p>
<p>解决办法：重启一下电脑或者是在启动的时候配置内存 </p>
<p>具体操作：在根目录下执行命令<code>redis-server.exe redis.windows.conf --maxheap 200m</code></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat与Nginx集群</title>
    <url>/Tomcat%E4%B8%8ENginx%E9%9B%86%E7%BE%A4.html</url>
    <content><![CDATA[<p>在本地开发项目时，我们通常只会将代码部署到一台服务器上。然而，在实际项目中，为了更好地应对突发情况，我们可能将代码部署在多台服务器上，尽可能地避免因为网站发生故障，造成正常服务中断的情况。在Java Web开发过程中，我们使用多台Tomcat服务器搭建服务器集群。</p>
<h3 id="Tomcat集群的作用"><a href="#Tomcat集群的作用" class="headerlink" title="Tomcat集群的作用"></a>Tomcat集群的作用</h3><p>Tomcat集群主要有以下两个作用：</p>
<ul>
<li>提高服务性能，并发能力以及高可用性</li>
<li>提供项目架构的横向扩展能力</li>
</ul>
<h3 id="Tomcat集群实现原理"><a href="#Tomcat集群实现原理" class="headerlink" title="Tomcat集群实现原理"></a>Tomcat集群实现原理</h3><p>在本章中，Tomcat集群的实现是通过Nginx负载均衡进行请求转发而产生的。</p>
<h3 id="Tomcat集群引发的问题及解决方案"><a href="#Tomcat集群引发的问题及解决方案" class="headerlink" title="Tomcat集群引发的问题及解决方案"></a>Tomcat集群引发的问题及解决方案</h3><p>在Tomcat集群的情况下，将会产生了以下问题：</p>
<ul>
<li>Session登录信息存储及读取的问题</li>
<li>服务器定时任务并发的问题，…</li>
</ul>
<p>因此，在使用Tomcat集群的时候，我们要注意到这些问题。</p>
<p>针对上面的Session登录信息存储及读取的问题，我们可以使用下面两种方案：</p>
<ol>
<li><p>采用nginx ip哈希策略，将相同ip的请求转发到同一台服务器上</p>
<ul>
<li><p>优点：可以不改变现有技术架构，直接实现横向扩展</p>
</li>
<li><p>缺点：容易导致服务器请求(负载)不平均，完全依赖ip哈希的结果；在ip变化的环境下将无法服务</p>
</li>
</ul>
</li>
<li><p>将SessionId存储到Cookie中，无论用户在哪台服务器登录，都从Cookie中获取SessionId，并将Session信息存储到Redis中，当用户需要获取登录信息时，从Redis中获取相关信息</p>
</li>
<li><p>为了解决服务器定时任务并发的问题，我们将使用分布式锁来处理该问题。</p>
</li>
</ol>
<h3 id="Nginx负载均衡配置"><a href="#Nginx负载均衡配置" class="headerlink" title="Nginx负载均衡配置"></a>Nginx负载均衡配置</h3><p>对于Nginx来说，负载均衡主要有以下几种配置方式：</p>
<ul>
<li>轮询(默认)</li>
<li>权重</li>
<li>ip哈希</li>
<li>url哈希(第三方)</li>
<li>fair(第三方)</li>
</ul>
<h4 id="轮询方式"><a href="#轮询方式" class="headerlink" title="轮询方式"></a>轮询方式</h4><p>使用轮询进行负载均衡，其主要优缺点如下：</p>
<p>优点：实现简单</p>
<p>缺点：不考虑每台服务器处理能力</p>
<p>轮询方式的主要配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> www.happymmall.com &#123;</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">8080</span>;	</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">9080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="权重方式"><a href="#权重方式" class="headerlink" title="权重方式"></a>权重方式</h4><p>使用权重进行负载均衡，其主要优点如下：</p>
<p>优点：考虑了每台服务器处理能力的不同，在这个配置中使用了weight，若不使用，则默认为1</p>
<p>权重方式的主要配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> www.happymmall.com &#123;</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">8080</span> weight=<span class="number">15</span>;</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">9080</span> weight=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ip哈希方式"><a href="#ip哈希方式" class="headerlink" title="ip哈希方式"></a>ip哈希方式</h4><p>使用ip哈希进行负载均衡，其主要优点如下：</p>
<p>优点：能实现同一用户访问同一个服务器</p>
<p>缺点：根据ip哈希，会造成请求访问分布不平均</p>
<p>ip哈希方式的主要配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> www.happymmall.com &#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">8080</span>;</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">9080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="url哈希方式"><a href="#url哈希方式" class="headerlink" title="url哈希方式"></a>url哈希方式</h4><p>使用url哈希进行负载均衡，其优缺点如下：</p>
<p>优点：能实现同一服务访问同一服务器</p>
<p>缺点：根据url哈希分配请求会不平均，请求频繁的url会请求到同一服务器</p>
<p>url哈希方式的主要配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> www.happymmall.com &#123;</span><br><span class="line">	<span class="attribute">server</span>  www.happymmall.com:<span class="number">8080</span>;</span><br><span class="line">	<span class="attribute">server</span>  www.happymmall.com:<span class="number">9080</span>;</span><br><span class="line">	<span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fair方式"><a href="#fair方式" class="headerlink" title="fair方式"></a>fair方式</h4><p>使用fair进行负载均衡，按后端服务器的响应时间来分配请求，响应时间短的优先分配</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> www.happymmall.com &#123;</span><br><span class="line">	<span class="attribute">server</span>  www.happymmall.com:<span class="number">8080</span>;</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">9080</span>;</span><br><span class="line">	fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tomcat单机部署多应用"><a href="#Tomcat单机部署多应用" class="headerlink" title="Tomcat单机部署多应用"></a>Tomcat单机部署多应用</h3><p>为了实现单机部署多应用，我们需要准备多个Tomcat，在本章中，我们实现两个Tomcat集群，准备两个Tomcat：Tomcat1和Tomcat2</p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>在windows环境下，我们配置6个环境变量：</p>
<ul>
<li><p>Tomcat1：CATALINA_1_BASE、CATALINA_1_HOME、TOMCAT_1_HOME，指向Tomcat1根目录</p>
</li>
<li><p>Tomcat2：CATALINA_2_BASE、CATALINA_2_HOME、TOMCAT_2_HOME，指向Tomcat2根目录</p>
</li>
</ul>
<h4 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h4><p>除了配置环境变量以外，我们还需要配置这两个Tomcat。</p>
<p>Tomcat1：</p>
<ol>
<li><p>修改<strong>bin</strong>目录下的<strong>catalina.bat</strong>：</p>
<ul>
<li><p>查找该文件下的所有<strong>CATALINA_BASE</strong>，替换为<strong>CATALINA_1_BASE</strong></p>
</li>
<li><p>查找该文件下的所有<strong>CATALINA_HOME</strong>，替换为<strong>CATALINA_1_HOME</strong></p>
</li>
</ul>
</li>
<li><p>修改<strong>bin</strong>目录下的<strong>startup.bat</strong>：</p>
<ul>
<li><p>查找该文件下的所有<strong>CATALINA_BASE</strong>，替换为<strong>CATALINA_1_BASE</strong></p>
</li>
<li><p>查找该文件下的所有<strong>CATALINA_HOME</strong>，替换为<strong>CATALINA_1_HOME</strong></p>
</li>
</ul>
</li>
</ol>
<p>Tomcat2：</p>
<ol>
<li><p>修改<strong>conf</strong>目录下的<strong>server.xml</strong>：</p>
<ul>
<li><p>修改<code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code>中的端口<strong>8005</strong>为<strong>9005</strong></p>
</li>
<li><p>修改<code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt;</code>中的端口<strong>8080</strong>改为<strong>9080</strong></p>
</li>
<li><p>修改<code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>中的端口<strong>8009</strong>改为<strong>9009</strong></p>
</li>
</ul>
</li>
<li><p>修改<strong>bin</strong>目录下的<strong>catalina.bat</strong>：</p>
<ul>
<li><p>查找该文件下的所有<strong>CATALINA_BASE</strong>，替换为<strong>CATALINA_2_BASE</strong></p>
</li>
<li><p>查找该文件下的所有<strong>CATALINA_HOME</strong>，替换为<strong>CATALINA_2_HOME</strong></p>
</li>
</ul>
</li>
<li><p>修改<strong>bin</strong>目录下的<strong>startup.bat</strong>：</p>
<ul>
<li><p>查找该文件下的所有<strong>CATALINA_BASE</strong>，替换为<strong>CATALINA_2_BASE</strong></p>
</li>
<li><p>查找该文件下的所有<strong>CATALINA_HOME</strong>，替换为<strong>CATALINA_2_HOME</strong></p>
</li>
</ul>
</li>
</ol>
<h4 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h4><p>启动Tomcat1，查看打印出的CATALINA_1_BASE，CATALINA_1_HOME：</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/Tomcat%E9%9B%86%E7%BE%A4/tomcat1.png" alt="tomcat1"></p>
<p>启动Tomcat2，查看打印出的CATALINA_2_BASE，CATALINA_2_HOME：</p>
<p><img src="http://east-hexo.oss-cn-hangzhou.aliyuncs.com/Tomcat%E9%9B%86%E7%BE%A4/tomcat2.png" alt="tomcat2"></p>
<p>若能够正常启动，且其打印出的信息和服务器相对应，则表示配置成功</p>
<h4 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> www.happymmall.com&#123;</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">8080</span> weight=<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">server</span> www.happymmall.com:<span class="number">9080</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">server_name</span> happymmall.com www.happymmall.com;</span><br><span class="line">    <span class="attribute">access_log</span> D:/access.log combined;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.jsp index.php;</span><br><span class="line">    <span class="comment">#error_page 404 /404.html;</span></span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$query_string</span> <span class="regexp">~* ".*[\;'\&lt;\&gt;].*"</span> )&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://www.happymmall.com ;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h4><p>为了使用Nginx配置的域名，我们修改host文件，添加一条配置<code>127.0.0.1 www.happymmall.com</code></p>
<h3 id="Tomcat多机部署多应用"><a href="#Tomcat多机部署多应用" class="headerlink" title="Tomcat多机部署多应用"></a>Tomcat多机部署多应用</h3><p>多机部署比单机多实例简单得多，只需要在每台主机安装一个Tomcat即可</p>
<ul>
<li>如果一个机器部署一个Tomcat实例，不用修改</li>
<li>如果一个机器部署多个Tomcat实例，参照上一节的方法</li>
<li>若使用不同的机器上的Tomcat实现Tomcat集群，需要保证各机器之间的网络是互通的，Nginx装在任意一台机器上即可，也可把Nginx服务独立出来一台</li>
</ul>
<h3 id="Tomcat与Nginx集群步骤总结"><a href="#Tomcat与Nginx集群步骤总结" class="headerlink" title="Tomcat与Nginx集群步骤总结"></a>Tomcat与Nginx集群步骤总结</h3><p>通过上文，我们可以了解Tomcat与Nginx集群的基本实现步骤</p>
<ol>
<li>配置各Tomcat相应的环境变量CATALINA_BASE、CATALINA_HOME、TOMCAT_HOME</li>
<li>配置各Tomcat配置文件对应的CATALINA_BASE、CATALINA_HOME</li>
<li>配置Nginx负载均衡，通过Nginx负载均衡整合Tomcat实现Tomcat集群</li>
</ol>
]]></content>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>博客内容调整说明</title>
    <url>/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E8%B0%83%E6%95%B4%E8%AF%B4%E6%98%8E.html</url>
    <content><![CDATA[<p>Hexo博客是我去年开通的，距今也快有一年时间了。在过去的2018年，我总结了部分学习内容发布到博客上。</p>
<p>今年，我把原来未连载完成的系列文章删除，并打算将博客内容拆分为两部分：</p>
<ul>
<li>第一部分：文章篇幅较小的，还是发布在<a href="https://codingshenzx.cn/">博客</a>上。</li>
<li>第二部分：文章篇幅较大的，可能形成系列文章的，发布在新的文档平台<a href="https://hangz007.gitee.io/" target="_blank" rel="noopener">knowledge</a>上。</li>
</ul>
<p>希望今年能把被删除的文章整理后发布到新平台上。</p>
]]></content>
      <tags>
        <tag>博客说明</tag>
      </tags>
  </entry>
  <entry>
    <title>日志框架--log4j入门</title>
    <url>/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6-log4j%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<p>对于一个系统来说，日志是其极其重要的一部分。在java的众多日志框架中，log4j是java比较重要的一个日志框架，其提供了多样化的日志服务。</p>
<p>下面介绍一下Maven项目使用log4j日志服务的步骤</p>
<h3 id="引入log4j日志框架依赖"><a href="#引入log4j日志框架依赖" class="headerlink" title="引入log4j日志框架依赖"></a>引入log4j日志框架依赖</h3><p>在项目使用log4j的日志服务之前，需要引入log4j日志服务的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置log4j服务"><a href="#配置log4j服务" class="headerlink" title="配置log4j服务"></a>配置log4j服务</h3><p>引入log4j服务相关依赖后，我们还需要配置log4j服务，具体配置如下</p>
<p>在<code>src/main/resources</code>目录下新建一个配置文件<code>log4j.properties</code></p>
<p>对于log4j来说，需要先配置<em>rootLogger</em></p>
<p>其语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置rootLogger,相当于全局配置</span><br><span class="line">log4j.rootLogger = [level],appenderName,appenderName</span><br></pre></td></tr></table></figure>
<p>其语法含义是:将<em>指定级别及以上级别的日志信息</em>输出到指定的一个或多个位置。下面将逐一介绍<em>level</em>和<em>appender</em>的含义</p>
<h4 id="指定log4j日志级别"><a href="#指定log4j日志级别" class="headerlink" title="指定log4j日志级别"></a>指定log4j日志级别</h4><p>有些时候，我们只想知道程序运行时产生的一些特定信息，这时候，就需要有针对性地输出一些特定级别的日志，指定日志级别可以解决这个问题。</p>
<p>log4j根据日志信息的重要程度，将日志分为下面7个级别，分别是</p>
<p><em>OFF</em>、<em>FATAL</em>、<em>ERROR</em>、<em>WARN</em>、<em>INFO</em>、<em>DEBUG</em>、<em>ALL</em></p>
<p>但是，log4j官方建议实际使用以下四个级别，它们的优先级从高到低分别是:</p>
<p><em>ERROR</em>、<em>WARN</em>、<em>INFO</em>、<em>DEBUG</em></p>
<p>在上面的<em>rootLogger</em>配置中就可以指定<em>level</em>的值为日志级别中的这些值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#rootLogger配置</span><br><span class="line">log4j.rootLogger = DEBUG</span><br></pre></td></tr></table></figure>
<h4 id="指定log4j输出类型"><a href="#指定log4j输出类型" class="headerlink" title="指定log4j输出类型"></a>指定log4j输出类型</h4><p>解决了输出哪些级别的日志之后，需要解决的就是如何输出这些日志信息的问题。这就要配置log4j的输出类型了。</p>
<h5 id="log4j输出类型的实现"><a href="#log4j输出类型的实现" class="headerlink" title="log4j输出类型的实现"></a>log4j输出类型的实现</h5><p>log4j官方的<em>appender</em>给出了以下5种实现</p>
<ul>
<li><code>org.apache.log4j.ConsoleAppender</code>（控制台） </li>
<li><code>org.apache.log4j.FileAppender</code>（文件）</li>
<li><code>org.apache.log4j.DailyRollingFileAppender</code>（每天产生一个日志文件）</li>
<li><code>org.apache.log4j.RollingFileAppender</code>（文件大小到达指定尺寸的时候产生一个新的文件）</li>
<li><code>org.apache.log4j.WriterAppender</code>（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<h5 id="log4j输出类型的选择"><a href="#log4j输出类型的选择" class="headerlink" title="log4j输出类型的选择"></a>log4j输出类型的选择</h5><p>实际开发过程中，比较常用的是第1、第3、第4种，其它两种比较少用</p>
<p>那么，该怎么选择和使用这些<em>appender</em>实现呢？</p>
<ol>
<li><p>一般来说，输出到控制台是必须的</p>
</li>
<li><p>假如日志数据量不是很大，我们可以追加使用<em>DailyRollingFileAppender</em>每天产生一个日志，方便查看</p>
</li>
<li><p>假如日志数据量很大，我们一般用<em>RollingFileAppender</em>，限制单个日志文件的大小。可以使用MaxFileSize属性指定单个日志文件最大的大小，单位为<em>KB</em>，当文件大小超出指定大小时，就会产生一个新的文件 。</p>
</li>
<li><p>对于服务器来说，存储空间是毕竟是有限的，在一定条件下需要删除或覆盖一些早前的日志文件。因此，可以使用日志的MaxBackupIndex属性指定日志文件的个数，当日志文件数量超过该上限时，则覆盖旧的日志文件</p>
</li>
</ol>
<p>至此，日志配置发展到下面的形式，可以根据实际情况选用合适实现</p>
<p>示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG, Console ,File ,DailyRollingFile ,RollingFile</span><br><span class="line"></span><br><span class="line"># 新增配置，指定rootLogger输出的具体实现</span><br><span class="line"></span><br><span class="line">#Console  输出日志到控制台</span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender</span><br><span class="line"></span><br><span class="line">#File 输出日志到文件</span><br><span class="line">log4j.appender.File = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.File.File = C://log2.log</span><br><span class="line"></span><br><span class="line">#DailyRollingFile 每天生成一个日志文件</span><br><span class="line">log4j.appender.DailyRollingFile = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.DailyRollingFile.File = C://log3.log</span><br><span class="line"></span><br><span class="line">#RollingFile 指定单个日志文件最大大小，达到上限自动生成新文件；指定日志文件最大数量，达到上限，覆盖旧文件</span><br><span class="line">log4j.appender.RollingFile = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.RollingFile.File = C://log4.log</span><br><span class="line">log4j.appender.RollingFile.MaxFileSize=1KB</span><br><span class="line">log4j.appender.RollingFile.MaxBackupIndex=3</span><br></pre></td></tr></table></figure>
<h4 id="指定log4j日志信息格式"><a href="#指定log4j日志信息格式" class="headerlink" title="指定log4j日志信息格式"></a>指定log4j日志信息格式</h4><p>对于日志来说，我们还要指定日志输出信息的格式，在log4j中主要提供了以下实现</p>
<ul>
<li><code>org.apache.log4j.HTMLLayout</code>（以HTML表格形式布局），  </li>
<li><code>org.apache.log4j.PatternLayout</code>（可以灵活地指定布局模式），  </li>
<li><code>org.apache.log4j.SimpleLayout</code>（包含日志信息的级别和信息字符串），  </li>
<li><code>org.apache.log4j.TTCCLayout</code>（包含日志产生的时间、线程、类别等等信息）</li>
</ul>
<p>其中，在这些实现中，第1、3、4比较简单，log4j直接指定了日志信息格式。在实际开发中，最常用的是第2种，其有个<em>ConversionPattern</em>属性，通过该属性能够灵活配置输出，其可配置的属性如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%m</td>
<td style="text-align:center">输出代码中指定的消息</td>
</tr>
<tr>
<td style="text-align:center">%M</td>
<td style="text-align:center">输出打印该条日志的方法名</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</td>
</tr>
<tr>
<td style="text-align:center">%r</td>
<td style="text-align:center">输出自应用启动到输出该log信息耗费的毫秒数</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">输出所属的类目，通常就是所在类的全名</td>
</tr>
<tr>
<td style="text-align:center">%t</td>
<td style="text-align:center">输出产生该日志事件的线程名</td>
</tr>
<tr>
<td style="text-align:center">%n</td>
<td style="text-align:center">输出一个回车换行符，Windows平台为”rn”，Unix平台为”n”；</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">输出日志时间点的日期或时间，默认格式为<em>ISO8601</em>，也可以在其后指定格式，比如：<em>%d{yyyy-MM-dd HH:mm:ss,SSS}</em>，输出类似：2002-10-18 22:10:28,921</td>
</tr>
<tr>
<td style="text-align:center">%l</td>
<td style="text-align:center">输出日志事件的发生位置，及在代码中的行数</td>
</tr>
</tbody>
</table>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG, Console ,File ,DailyRollingFile ,RollingFile</span><br><span class="line">   </span><br><span class="line">#Console  </span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender  </span><br><span class="line">## 新增，配置日志信息格式</span><br><span class="line">log4j.appender.Console.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.Console.layout.ConversionPattern= %d [%t] %-5p [%c] - %m%n</span><br><span class="line">   </span><br><span class="line">#File</span><br><span class="line">log4j.appender.File = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.File.File = C://log2.log</span><br><span class="line">## 新增，配置日志信息格式</span><br><span class="line">log4j.appender.File.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.File.layout.ConversionPattern = %d [%t] %-5p [%c] - %m%n</span><br><span class="line"></span><br><span class="line">#DailyRollingFile</span><br><span class="line">log4j.appender.DailyRollingFile = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.DailyRollingFile.File = C://log3.log</span><br><span class="line">## 新增，配置日志信息格式</span><br><span class="line">log4j.appender.DailyRollingFile.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.DailyRollingFile.layout.ConversionPattern = %d [%t] %-5p [%c] - %m%n</span><br><span class="line"> </span><br><span class="line">#RollingFile</span><br><span class="line">log4j.appender.RollingFile = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.RollingFile.File = C://log4.log</span><br><span class="line">log4j.appender.RollingFile.MaxFileSize=1KB</span><br><span class="line">log4j.appender.RollingFile.MaxBackupIndex=3</span><br><span class="line">## 新增，配置日志信息格式</span><br><span class="line">log4j.appender.RollingFile.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.RollingFile.layout.ConversionPattern = %d [%t] %-5p [%c] - %m%n</span><br></pre></td></tr></table></figure>
<h5 id="指定输出日志的等级"><a href="#指定输出日志的等级" class="headerlink" title="指定输出日志的等级"></a>指定输出日志的等级</h5><p>有时候，我们需要将指定的日志级别<strong>单独输出</strong>到文件中，这时就可以使用<em>Threshold</em>属性指定日志级别</p>
<p><strong>当然这里有个提前<em>rootLogger</em>里配置的<em>level</em>小于Threshold层级,否则无效，日志还是会按照总的<em>rootLogger</em>里配置的<em>level</em>来输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注意到这里增加的两个DFile ,EFILE和下面配置的对应</span><br><span class="line">log4j.rootLogger=DEBUG, Console ,DFile ,EFILE </span><br><span class="line"></span><br><span class="line">#DEBUGFile</span><br><span class="line">log4j.appender.DFile = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.DFile.File = C://DEBUG.log</span><br><span class="line">log4j.appender.DFile.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.DFile.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n</span><br><span class="line">#新增</span><br><span class="line">#下面这一行是设置DFILE的日志级别，将DEBUG级别的日志单独输入到该文件</span><br><span class="line">log4j.appender.DFile.Threshold = DEBUG</span><br><span class="line"></span><br><span class="line">#ERRORFile</span><br><span class="line">log4j.appender.EFILE = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.EFILE.File = C://ERROR.log</span><br><span class="line">log4j.appender.EFILE.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.EFILE.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n</span><br><span class="line">#新增</span><br><span class="line">#下面这一行是设置EFILE的日志级别，将ERROR级别的日志单独输入到该文件</span><br><span class="line">log4j.appender.EFILE.Threshold = ERROR</span><br></pre></td></tr></table></figure>
<h5 id="指定是否追加内容"><a href="#指定是否追加内容" class="headerlink" title="指定是否追加内容"></a>指定是否追加内容</h5><p>log4j默认是不断的把日志内容追加到日志文件中的，可以通过设置属性<em>Append</em>值来控制是否追加内容到日志文件中。</p>
<ul>
<li>若<em>Append</em>设置为<em>true</em>，则表示追加内容到日志文件</li>
<li>若<em>Append</em>设置为<em>false</em>，则表示不追加内容到日志文件，直接覆盖前面的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG, Console ,DFile ,EFILE</span><br><span class="line"></span><br><span class="line">#Console  </span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.Console.layout=org.apache.log4j.TTCCLayout  </span><br><span class="line"></span><br><span class="line">#DEBUGFile</span><br><span class="line">log4j.appender.DFile = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.DFile.File = C://DEBUG.log</span><br><span class="line">log4j.appender.DFile.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.DFile.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n</span><br><span class="line">log4j.appender.DFile.Threshold = DEBUG</span><br><span class="line">#新增</span><br><span class="line">#这里设置是否在文件中追加日志信息，默认为true，代表追加日志，反之false</span><br><span class="line">log4j.appender.DFile.Append = false</span><br><span class="line"></span><br><span class="line">#ERRORFile</span><br><span class="line">log4j.appender.EFILE = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.EFILE.File = C://ERROR.log</span><br><span class="line">log4j.appender.EFILE.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.EFILE.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n</span><br><span class="line">log4j.appender.EFILE.Threshold = ERROR</span><br></pre></td></tr></table></figure>
<h4 id="java代码中使用日志"><a href="#java代码中使用日志" class="headerlink" title="java代码中使用日志"></a>java代码中使用日志</h4><p>可以在java类中增加该代码，该代码引入了一个日志对象，可以使用该日志对象的方法输出信息，帮助我们更方便地查找程序错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger=Logger.getLogger(xxx.class);</span><br></pre></td></tr></table></figure>
<h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><ul>
<li><code>pom.xml</code>文件(文件头忽略)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>log4.properties</code>文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG, Console ,DFile ,EFILE</span><br><span class="line"></span><br><span class="line">#Console  </span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.Console.layout=org.apache.log4j.TTCCLayout  </span><br><span class="line"></span><br><span class="line">#DEBUGFile</span><br><span class="line">log4j.appender.DFile = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.DFile.File = C://DEBUG.log</span><br><span class="line">log4j.appender.DFile.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.DFile.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n</span><br><span class="line">log4j.appender.DFile.Threshold = DEBUG</span><br><span class="line">#这里设置是否在文件中追加日志信息，默认为true，代表追加日志，反之false</span><br><span class="line">log4j.appender.DFile.Append = false</span><br><span class="line"></span><br><span class="line">#ERRORFile</span><br><span class="line">log4j.appender.EFILE = org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.EFILE.File = C://ERROR.log</span><br><span class="line">log4j.appender.EFILE.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.EFILE.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n</span><br><span class="line">log4j.appender.EFILE.Threshold = ERROR</span><br></pre></td></tr></table></figure>
<ul>
<li><code>java</code>代码文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger=Logger.getLogger(Test.class); <span class="comment">// 获取logger实例</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		logger.info(<span class="string">"普通Info信息222"</span>);</span><br><span class="line">		logger.debug(<span class="string">"调试debug222信息"</span>);</span><br><span class="line">		logger.error(<span class="string">"报错error信息"</span>);</span><br><span class="line">		logger.warn(<span class="string">"警告warn信息"</span>);</span><br><span class="line">		logger.fatal(<span class="string">"严重错误fatal信息"</span>);		</span><br><span class="line">		logger.error(<span class="string">"报错信息"</span>, <span class="keyword">new</span> IllegalArgumentException(<span class="string">"非法参数"</span>));	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了在java程序中使用log4j日志服务，需要做以下事情</p>
<ol>
<li>首先，在<code>pom.xml</code>文件中引入log4j所必须的依赖</li>
<li>然后，在<code>src/main/resources</code>目录下创建<code>log4j.properties</code>，并依次配置<em>rootLogger</em>，<em>appender</em>,<em>layout</em></li>
<li>在java代码中创建<em>Logger</em>对象，在相关代码前后使用该对象相关方法</li>
</ol>
]]></content>
      <categories>
        <category>日志框架</category>
      </categories>
      <tags>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/%E9%80%92%E5%BD%92.html</url>
    <content><![CDATA[<h2 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h2><p>指在当前方法中自己调用自己的情况</p>
<h2 id="递归的分类"><a href="#递归的分类" class="headerlink" title="递归的分类"></a>递归的分类</h2><p>递归分为两种：直接递归和间接递归</p>
<ul>
<li>直接递归：方法直接调用自己</li>
<li>间接递归：A方法调用B方法，B方法调用C方法，C方法调用A方法，这种不直接调用自己的递归，称为间接递归。</li>
</ul>
<h2 id="递归的注意事项"><a href="#递归的注意事项" class="headerlink" title="递归的注意事项"></a>递归的注意事项</h2><ul>
<li>递归一定要有一定的条件限定，保证递归能够停下来，否则会发生栈内存溢出。</li>
<li>在递归中虽然有限定条件，但是递归的次数不宜过多，否则也会发生栈内存溢出。</li>
<li>构造方法，要禁止递归。</li>
</ul>
<h2 id="递归遍历多级目录"><a href="#递归遍历多级目录" class="headerlink" title="递归遍历多级目录"></a>递归遍历多级目录</h2><p>为了更好理解递归，我们选定目录<code>E:\文档</code>，遍历其子目录及文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\文档&quot;</span>);</span><br><span class="line">        getAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        System.out.println(dir);</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                getAllFiles(file); <span class="comment">//递归调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归遍历特定文件搜索"><a href="#递归遍历特定文件搜索" class="headerlink" title="递归遍历特定文件搜索"></a>递归遍历特定文件搜索</h2><p>在这个例子中，我们需要递归搜索以<code>.pdf</code>结尾的文件，因此，我们在<code>else</code>语句中增加判断是否以<code>.pdf</code>结尾的文件，再打印输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\文档&quot;</span>);</span><br><span class="line">        getAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                getAllFiles(file);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(file.getName().endsWith(<span class="string">&quot;.pdf&quot;</span>))&#123;</span><br><span class="line">                    System.out.println(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java输入输出</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
